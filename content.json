{"pages":[{"title":"","text":"由于篇幅短小和时间仓促, 若你发现了错误请告知我。希望我没有误导你，而是带你看了小小的新世界。如果您阅读后有所收获或对您有帮助; 不妨打赏我一下，请我喝杯茶或咖啡! 您小小的支持都是对作者莫大的鼓励！","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"C++51行贪吃蛇","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;deque&gt;#include &lt;windows.h&gt;using namespace std;COORD gSize{32, 16}, pos{1, 0}, food = gSize;deque&lt;COORD&gt; snake(1, {0, 0});int cdprintf(COORD cd, const char *s){ return SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cd), printf(s);}int isLegal(COORD cd){ for (deque&lt;COORD&gt;::iterator it = snake.begin(); it != snake.end(); ++it) if (it-&gt;X == cd.X &amp;&amp; it-&gt;Y == cd.Y) return 0; return 0 &lt;= cd.X &amp;&amp; cd.X &lt; gSize.X &amp;&amp; 0 &lt;= cd.Y &amp;&amp; cd.Y &lt; gSize.Y;}int main(){ for (int i = 0; i &lt; gSize.Y; ++i) cdprintf({gSize.X, i}, \"♂\"); cdprintf({0, gSize.Y}, \"←↑↓→方向键移动，Space键暂停\"); for (int SCORE = 0, FOOD = 0, BACK = 0; isLegal({snake.front().X + pos.X, snake.front().Y + pos.Y}); Sleep(255)) { if (BACK) --BACK; else cdprintf(snake.back(), \" \"), snake.pop_back(); snake.push_front({snake.front().X + pos.X, snake.front().Y + pos.Y}); cdprintf(snake.front(), \"*\"); if (!isLegal(food)) { char s[63]; sprintf(s, \"WuK的贪吃蛇 %d分\", SCORE += FOOD), SetConsoleTitle(s); for (BACK += FOOD; !isLegal(food = {rand() % gSize.X, rand() % gSize.Y});) ; sprintf(s, \"%d\", FOOD = rand() % 3 + 1), cdprintf(food, s); } if (GetAsyncKeyState(VK_SPACE)) MessageBox(NULL, \"游戏很好玩？\\n请联系wu.kan@foxmail.com\", \"By WuK\", NULL); else if (GetAsyncKeyState(VK_UP) &amp;&amp; pos.Y != 1) pos = {0, -1}; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; pos.Y != -1) pos = {0, 1}; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; pos.X != 1) pos = {-1, 0}; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; pos.X != -1) pos = {1, 0}; } MessageBox(NULL, \"Game Over\", \"By WuK\", NULL);}","link":"/2017/10/04/2017-10-04-C++51行贪吃蛇/"},{"title":"爬取网易财经中股票的历史交易数据","text":"爬取网易财经中股票的历史交易数据需求分析 得到股票代码 股票代码的信息是在东方财富网中获取(http://quote.eastmoney.com/stocklist.html) 得到股票的历史交易记录 股票的历史交易记录是可以在网易财经中直接下载excel表的，地址(http://quotes.money.163.com/trade/lsjysj_603088.html#06f01)这是某一股票的历史交易记录详情，我们可以在页面中找到下载的链接地址。 代码撸起来 首先我们需要在东方财富网中获取到股票的代码，在(http://quote.eastmoney.com/stocklist.html)页面中我们可以看到股票代码，我们可以利用xpath结合正则表达式将这些股票代码获取到 获取股票代码列表的代码： 1234567891011121314151617181920212223242526272829class StockCode(object): def __init__(self): self.start_url = \"http://quote.eastmoney.com/stocklist.html#sh\" self.headers = { \"User-Agent\": \":Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\" } def parse_url(self): # 发起请求，获取响应 response = requests.get(self.start_url, headers=self.headers) if response.status_code == 200: return etree.HTML(response.content) def get_code_list(self, response): # 得到股票代码的列表 node_list = response.xpath('//*[@id=\"quotesearch\"]/ul[1]/li') code_list = [] for node in node_list: try: code = re.match(r'.*?\\((\\d+)\\)', etree.tostring(node).decode()).group(1) print code code_list.append(code) except: continue return code_list def run(self): html = self.parse_url() return self.get_code_list(html) 分析网易财经中历史交易记录下载页面获取到下载的链接。 使用谷歌浏览器检查工具，切换到network，在我们在点击下载的时候可以得到请求接口： 上图中，我们分析到，在点击下载时的url地址，需要传递的参数就是我们的股票代码和下载的起始时间和结束的时间，以及fields后面跟着的一堆参数值，在这里需要注意的是请求的url中股票代码前还多了一位是0。那么我们在爬取的时候，就需要理由xpath来提取页面中要下载数据的起始时间和结束时间，然后将在东方财富网中获取到的股票代码和url进行拼接，拼接成我们想要请求的下载连接。 下载历史交易记录的代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Download_HistoryStock(object): def __init__(self, code): self.code = code self.start_url = \"http://quotes.money.163.com/trade/lsjysj_\" + self.code + \".html\" print self.start_url self.headers = { \"User-Agent\": \":Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\" } def parse_url(self): response = requests.get(self.start_url) print response.status_code if response.status_code == 200: return etree.HTML(response.content) return False def get_date(self, response): # 得到开始和结束的日期 start_date = ''.join(response.xpath('//input[@name=\"date_start_type\"]/@value')[0].split('-')) end_date = ''.join(response.xpath('//input[@name=\"date_end_type\"]/@value')[0].split('-')) return start_date,end_date def download(self, start_date, end_date): download_url = \"http://quotes.money.163.com/service/chddata.html?code=0\"+self.code+\"&amp;start=\"+start_date+\"&amp;end=\"+end_date+\"&amp;fields=TCLOSE;HIGH;LOW;TOPEN;LCLOSE;CHG;PCHG;TURNOVER;VOTURNOVER;VATURNOVER;TCAP;MCAP\" data = requests.get(download_url) f = open(self.code + '.csv', 'wb') for chunk in data.iter_content(chunk_size=10000): if chunk: f.write(chunk) print '股票---',self.code,'历史数据正在下载' def run(self): try: html = self.parse_url() start_date,end_date = self.get_date(html) self.download(start_date, end_date) except Exception as e: print e 运行项目，开始下载数据： 12345678if __name__ == '__main__': code = StockCode() code_list = code.run() for temp_code in code_list: time.sleep(1) download = Download_HistoryStock(temp_code) download.run() 下载数据的时候发现，获取到的股票代码2-5开头的都下载不到历史的交易记录，但是从6开始，是可以下载了，下面是下载来的数据效果：","link":"/2019/07/14/2017-08-14-爬取网易财经中股票的历史交易数据/"},{"title":"函数程序设计实验一：分式","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374--import Test.QuickCheckmodule MyFraction whereFraction=(Integer,Integer)--分式化简ratreduction::Fraction-&gt;Fractionratreduction(x,y)=(div x g,div y g)where g=gcd x y--加法ratplus::Fraction-&gt;Fraction-&gt;Fractionratplus(a,b)(c,d)=ratreduction(a*d+b*c,b*d)--减法，调用加法实现ratminus::Fraction-&gt;Fraction-&gt;Fractionratminus(a,b)(c,d)=ratplus(a,b)(-c,d)--乘法rattimes::Fraction-&gt;Fraction-&gt;Fractionrattimes(a,b)(c,d)=ratreduction(a*c,b*d)--除法，调用乘法实现ratdiv::Fraction-&gt;Fraction-&gt;Fractionratdiv(a,b)(c,d)=rattimes(a,b)(d,c)--取整ratfloor::Fraction-&gt;Integerratfloor(a,b)=div a b--转成浮点ratfloat::Fraction-&gt;Floatratfloat(a,b)=fromInteger a/fromInteger b--判断相等rateq::Fraction-&gt;Fraction-&gt;Boolrateq(a,b)(c,d)=a*d==b*c--重载运算符(&lt;+&gt;)::Fraction-&gt;Fraction-&gt;Fraction(a,b)&lt;+&gt;(c,d)=ratplus(a,b)(c,d) (&lt;-&gt;)::Fraction-&gt;Fraction-&gt;Fraction(a,b)&lt;-&gt;(c,d)=ratminus(a,b)(c,d)(&lt;-*-&gt;)::Fraction-&gt;Fraction-&gt;Fraction(a,b)&lt;-*-&gt;(c,d)=rattimes(a,b)(c,d)(&lt;/&gt;)::Fraction-&gt;Fraction-&gt;Fraction(a,b)&lt;/&gt;(c,d)=ratdiv(a,b)(c,d)(&lt;==&gt;)::Fraction-&gt;Fraction-&gt;Bool(a,b)&lt;==&gt;(c,d)=rateq(a,b)(c,d)--确定运算优先级infixl 6 &lt;-*-&gt;,&lt;/&gt;infixl 5 &lt;+&gt;,&lt;-&gt;infixl 4 &lt;==&gt;{---检查任意分数+(0,1)之后仍然等于其本身prop_ratplus_unit :: Fraction -&gt; Propertyprop_ratplus_unit (a,b) = b &gt; 0 ==&gt;(a, b) &lt;+&gt; (0,1) &lt;==&gt; (a, b)--检查任意分数加上相反数之后为0prop_ratplus_inv :: Fraction -&gt; Propertyprop_ratplus_inv (a,b) = b &gt; 0 ==&gt;(a, b) &lt;+&gt; (-a,b) &lt;==&gt; (0, 1)--检查任意非零分数乘上倒数之后为1prop_rattimes_inv :: Fraction -&gt; Propertyprop_rattimes_inv (a,b) = a/=0&amp;&amp;b &gt; 0 ==&gt;(a, b) &lt;-*-&gt; (b,a) &lt;==&gt; (1, 1)-- 检查乘法分配律prop_rattimes_plus_distr :: Fraction -&gt; Fraction -&gt; Fraction -&gt;Propertyprop_rattimes_plus_distr (a,b) (c,d) (e,f) = b &gt; 0 &amp;&amp; d &gt; 0 &amp;&amp; f &gt; 0 ==&gt; (a,b) &lt;-*-&gt; ((c,d) &lt;+&gt; (e,f)) &lt;==&gt; ((a,b) &lt;-*-&gt; (c,d)) &lt;+&gt; ((a,b) &lt;-*-&gt; (e,f))-}","link":"/2018/10/16/2018-10-16-分式/"},{"title":"函数程序设计实验二：递归练习","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172module HW where{-1. 定义求两个非负整数最大公因子的函数：mygcd ::Integer -&gt;Integer -&gt;Integer-}mygcd ::Integer -&gt;Integer -&gt;Integermygcd a 0=amygcd a b=mygcd b (mod a b){-2. 定义阶乘函数fac :: Integer -&gt; Integer -}fac :: Integer -&gt; Integer fac 0=1fac n=n* fac (n-1){-3. 定义下列函数：sumFacs :: Integer -&gt; Integer使得sumFacs n = fac 0 + fac 1 + ... + fac n-}sumFacs :: Integer -&gt; IntegersumFacs 0=fac 0sumFacs n=fac n+sumFacs (n-1){-4. 上述函数sumFacs可以对输入n返回和fac 0 + fac 1 + ... + fac n。任意给定一个函数f, 一个非负整数n, 能否求出和f 0 + f 1 + ... + f n呢？答案是肯定的。请您定义这样的函数：sumFun :: (Integer -&gt; Integer) -&gt; Integer -&gt; Integer使得sumFun f n = f 0 + f 1 + ... + f n-}sumFun :: (Integer -&gt; Integer) -&gt; Integer -&gt; IntegersumFun f 0=f 0sumFun f n=f n+sumFun f (n-1){-5. 定义函数maxFun :: (Integer -&gt; Integer) -&gt; Integer -&gt; Integer使得maxFun f n 等于f 0 ， f 1 ， ... ， f n中的最大值。-}maxFun :: (Integer -&gt; Integer) -&gt; Integer -&gt; IntegermaxFun f 0=f 0maxFun f n=max (f n) (maxFun f n-1){-6. 定义函数：fib :: Integer -&gt;Integer使得fib n 返回第n个斐波那契数，如fib 0 =0, fib 1 = 1, fib 2 = 1, fib 3 = 2, fib 4 = 5 ,...。-}fib :: Integer -&gt;Integerfib n=if(n&lt;2)then n else fib (n-1)+fib(n-2){-7. 利用我们可以利用下列迭代公式求2的近似平方根： xn+1 = (xn + 2/xn)/2方法是从任意一个初值x0开始，如x0 = 1, x1 = (x0 +2/x0)/2 =1.5, x2 = (x1 + 2/x1)/2= 1.41667, ...请定义一个函数sqrt2 :: Float -&gt;Integer -&gt;Float使得sqrt2 x0 n 等于第n个逼近值xn, 例如，sqrt2 1.0 0 = 1.0, sqrt2 1.0 1 = 1.5, sqrt2 1.0 2 = 1.41667, ...。-}sqrt2 :: Float -&gt; Integer -&gt; Floatsqrt2 x0 0=x0sqrt2 x0 n=(x + 2/x)/2 where x=sqrt2 x0 (n-1){-8. 完成解求一元二次方程根的函数。-}roots::(Float,Float,Float)-&gt;(Float,Float)roots (a,b,c)=((-b-sqrtDelta)/2/a,(-b+sqrtDelta)/2/a) where sqrtDelta=sqrt (b*b-4*a*c)","link":"/2018/10/16/2018-10-16-递归练习/"},{"title":"函数程序设计实验三：使用Newton-Raphson方式计算平方根","text":"12345678910111213module Newton_Raphson wheresquareroot2 :: Float -&gt; Integer -&gt; Floatsquareroot2 x0 n=squareroot 2 x0 nsquareroot :: Float -&gt; Float -&gt; Integer -&gt; Floatsquareroot r x0 0=x0squareroot r x0 n=(x+r/x)/2 where x=squareroot r x0 (n-1)sqrtSeq :: Float -&gt; Float -&gt; [Float]sqrtSeq r x0=x0:sqrtSeq r (squareroot r x0 1)squareroot' :: Float -&gt; Float -&gt; Float -&gt; Floatsquareroot' r x0 eps=f (sqrtSeq r x0) eps where f (y:ys) eps=if abs((head ys)-y)&lt;eps then y else f ys eps","link":"/2018/10/23/2018-10-23-函数程序设计实验三：使用Newton-Raphson方式计算平方根/"},{"title":"函数程序设计实验四：列表练习（2）","text":"123456789101112131415161718192021222324{-称一个三元组(x,y,z)是毕达哥拉斯三元组，如果x*x + y*y == z*z。例如，(3,4,5), (4,3,5), (6,8,10)等。请定义一个函数triads :: Int -&gt; [(Int, Int, Int)] 使得triads n 给出[1 .. n]中的毕达哥拉斯三元组，如 &gt; triads 5 [(3,4,5),(4,3,5)] &gt; triads 13 [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(12,5,13)]-}triads :: Int -&gt; [(Int, Int, Int)]triads n=[(x,y,z)|x&lt;-[1..n],y&lt;-[1..n],z&lt;-[1..n],x*x+y*y==z*z]{-以上结果中(3,4,5)和(4,3,5)实际上没有区别。请改进该函数，使得结果中不出现这种重复意义的三元组，实现函数 triads2 :: Int -&gt; [(Int, Int, Int)]使得 &gt; triads2 5 [(3,4,5)] &gt; triads2 13 [(3,4,5),(5,12,13),(6,8,10)]-}triads2 :: Int -&gt; [(Int, Int, Int)]triads2 n=[(x,y,z)|x&lt;-[1..n],y&lt;-[x..n],z&lt;-[y..n],x*x+y*y==z*z]","link":"/2018/11/08/2018-11-08-列表练习（2）/"},{"title":"函数程序设计实验八：模拟随机事件","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778{-Newton–Pepys problemFrom Wikipedia, the free encyclopediaJump to navigationJump to searchThe Newton–Pepys problem is a probability problem concerning the probability of throwing sixes from a certain number of dice.[1]In 1693 Samuel Pepys and Isaac Newton corresponded over a problem posed by Pepys in relation to a wager he planned to make. The problem was:Which of the following three propositions has the greatest chance of success?A. Six fair dice are tossed independently and at least one “6” appears.B. Twelve fair dice are tossed independently and at least two “6”s appear.C. Eighteen fair dice are tossed independently and at least three “6”s appear.[2]Pepys initially thought that outcome C had the highest probability, but Newton correctly concluded that outcome A actually has the highest probability.请你通过模拟的方法找到问题的答案。要求：1. 说明模拟方法和过程；2. 提交代码，并说明如何运行程序，得到问题答案。-}import System.Randomimport Text.Printfmain::IO()main= do let n=1000 a&lt;-getProbablity eventA n b&lt;-getProbablity eventB n c&lt;-getProbablity eventC n putStrLn(printf \"P(A)=%.7f,P(B)=%.7f,P(C)=%.7f\" a b c)getProbablity::(IO Bool)-&gt;Int-&gt;IO FloatgetProbablity event n=do xs&lt;-happen event n return ((fromIntegral xs)/(fromIntegral n))happen::(IO Bool)-&gt;Int-&gt;(IO Int)happen event 0=return 0happen event n= do e&lt;-event y&lt;-happen event (n-1) if e==True then return (1+y) else return ygetDices::Int-&gt;IO [Int]getDices 0=return []getDices x=do y&lt;-randomRIO(1,6) ys&lt;-getDices(x-1) return (y:ys)eventA::IO BooleventA= do xs&lt;-getDices 6 return ((countSix xs)&gt;0)eventB::IO BooleventB= do xs&lt;-getDices 12 return ((countSix xs)&gt;1)eventC::IO BooleventC= do xs&lt;-getDices 18 return ((countSix xs)&gt;2)countSix::[Int]-&gt;IntcountSix []=0countSix (x:xs)= if x==6 then (countSix xs)+1 else countSix xs","link":"/2018/11/14/2018-11-14-函数程序设计实验八：模拟随机事件/"},{"title":"函数程序设计实验七：石头、剪刀和布","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169{-设计一个交互程序，实现计算机（我）和用户（您）玩猜拳“石头、剪刀和布”。 例如，运行程序实现下来交互游戏：*Main&gt; play请您出手 (R)石头, (S)剪刀, (P)布:p, 您出了布, 我出了石头您赢了这手我的得分: 0您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:s, 您出了剪刀, 我出了布您赢了这手我的得分: 0您的得分: 2请您出手 (R)石头, (S)剪刀, (P)布:r, 您出了石头, 我出了剪刀您赢了这手我的得分: 0您的得分: 3算您赢了这轮。*Main&gt; play请您出手 (R)石头, (S)剪刀, (P)布:s, 您出了剪刀, 我出了布您赢了这手我的得分: 0您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:r, 您出了石头, 我出了石头这一手平手我的得分: 0您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:p, 您出了布, 我出了剪刀我的得分: 1您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:p, 您出了布, 我出了剪刀我的得分: 2您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:r, 您出了石头, 我出了剪刀您赢了这手我的得分: 2您的得分: 2请您出手 (R)石头, (S)剪刀, (P)布:s, 您出了剪刀, 我出了石头我的得分: 3您的得分: 2哈哈，我赢了！作业要求：1. 模块命名为Game, 程序命名为play:: IO ();2. 程序要仿照以上例子，输出交互过程和相关详细信息；3. 使用下面的手势类型及instance定义，需要 import System.Random:data Hand = Rock | Scissor | Paper deriving (Enum)instance Random Hand where random g = case randomR (0,2) g of (r, g') -&gt; (toEnum r, g') randomR (a,b) g = case randomR (fromEnum a, fromEnum b) g of (r, g') -&gt; (toEnum r, g')你也可以自己将Hand定义为Random的实例，以便能够使用随机手势，如 randomIO :: IO Hand4. 用户（您）的输入用字母表示：r, s和p（不分大小写）分别表示用户选择的石头、剪刀和布5. 建议适当定义一些辅助函数，不要把所有的命令都写在函数play中6. 一点提示：猜数和猜单词中定义了函数：guess :: Int (或者String) -&gt; IO ()其中输入参数是要猜的数或单词，在一系列猜测过程中需要这个信息，以便决定是停止还是继续猜（递归）。那么，猜拳时可能也需要类似的信息。提交要求：1. 提交模块Game;2. 仿照以上例子，至少给出计算机（我）和用户（您）各赢一次的运行截图。-}module Game whereimport System.Randomimport Text.Printfdata Hand = Rock | Scissor | Paper deriving (Enum,Eq)instance Random Hand where random g = case randomR (0,2) g of (r, g') -&gt; (toEnum r, g') randomR (a,b) g = case randomR (fromEnum a, fromEnum b) g of (r, g') -&gt; (toEnum r, g')getHand::IO HandgetHand= do s&lt;-getLine if (s==\"r\")||(s==\"R\") then return Rock else if (s==\"s\")||(s==\"S\") then return Scissor else return PaperisWin::Hand-&gt;Hand-&gt;Bool isWin p c=(p==Rock&amp;&amp;c==Scissor)||(p==Scissor&amp;&amp;c==Paper)||(p==Paper&amp;&amp;c==Rock)toStr::Hand-&gt;StringtoStr Rock=\"石头\"toStr Scissor=\"剪刀\"toStr Paper=\"布\"play::IO()play=game 0 0game::Int-&gt;Int-&gt;IO()game a b= do putStrLn \"请您出手 (R)石头, (S)剪刀, (P)布:\" ta&lt;-getHand tb&lt;-randomIO::IO Hand putStrLn(printf \"您出了%s, 我出了%s\" (toStr ta) (toStr tb)) if isWin ta tb then do putStrLn(printf \"您赢了这手\\n我的得分: %d\\n您的得分: %d\" b (a+1)) if a&gt;1 then putStrLn \"算您赢了这轮。\" else game (a+1) b else if isWin tb ta then do putStrLn(printf \"我赢了这手\\n我的得分: %d\\n您的得分: %d\" (b+1) a) if b&gt;1 then putStrLn \"哈哈，我赢了！\" else game a (b+1) else do putStrLn(printf \"这一手平手\\n我的得分: %d\\n您的得分: %d\" b a) game a b--main::IO()--main=play","link":"/2018/11/14/2018-11-14-函数程序设计实验七：石头、剪刀和布/"},{"title":"第一章：引言(Introduction)","text":"参考了斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 欢迎第一个视频主要讲了什么是机器学习，机器学习能做些什么事情。 机器学习是什么Arthur Samuel：他定义机器学习为，在进行特定编程的情况下，给予计算机学习能力的领域。Tom Mitchell提出：一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。目前存在几种不同类型的学习算法。主要的两种类型被我们称之为监督学习和无监督学习。监督学习这个想法是指，我们将教计算机如何去完成任务，而在无监督学习中，我们打算让它自己进行学习。 监督学习Supervised Learning监督学习指的就是我们给学习算法一个数据集，并通过数据集做出预测。这个数据集由“正确答案”组成。 回归问题术语“回归”，意味着要预测这一系列值的属性。 分类问题目标是推出离散的结果。 无监督学习Unsupervised Learning不同于监督学习的数据的样子，即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。所以我们已知数据集，却不知如何处理，也未告知每个数据点是什么。别的都不知道，就是一个数据集。我们没有提前告知算法一些信息。要自动地聚类那些个体到各个类，我没法提前知道哪些是哪些。因为我们没有给算法正确答案来回应数据集中的数据，所以这就是无监督学习。无监督学习算法可能会把这些数据分成两个不同的簇。所以叫做聚类算法。聚类只是无监督学习中的一种。","link":"/2018/11/29/2018-11-29-引言/"},{"title":"第二章：单变量线性回归(Linear Regression with One Variable)","text":"参考了斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 模型表示我们将要用来描述这个回归问题的标记如下:$m$ 代表训练集中实例的数量$x$ 代表特征/输入变量$y$ 代表目标变量/输出变量$(x,y)$ 代表训练集中的实例$(x^{(i)},y^{(i)})$ 代表第 $i$ 个观察实例$h$ 代表学习算法的解决方案或函数也称为假设（hypothesis）一种可能的表达方式为：$h_\\theta(x)=\\theta_0+\\theta_1x$，因为只含有一个特征/输入变量，因此这样的问题叫作单变量线性回归问题。 代价函数引入一些术语我们现在要做的便是为我们的模型选择合适的参数（parameters）$\\theta_{0}$ 和 $\\theta_{1}$，在房价问题这个例子中便是直线的斜率和在$y$ 轴上的截距。我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距就是建模误差（modeling error）。我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。即使得代价函数 $J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$最小。则可以看出在三维空间中存在一个使得$J(\\theta_0,\\theta_1)$最小的点。代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。在后续课程中，我们还会谈论其他的代价函数，但我们刚刚讲的选择是对于大多数线性回归问题非常合理的。 代价函数的直观理解I总结上一节的内容： Hypothesis $h_\\theta(x)=\\theta_0+\\theta_1x$ Parameters $\\theta_0,\\theta_1$ Cost Function $J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$ Goal $minimize_{\\theta_0,\\theta_1}J(\\theta_0,\\theta_1)$ 代价函数的直观理解II轮廓图：看起来比较像等高线图。 梯度下降${\\theta_{j} }:={\\theta_{j} }-\\alpha \\frac{\\partial }{\\partial {\\theta_{j} } }J\\left( \\theta \\right)$ 梯度下降的直观理解Repeat {${\\theta_{0} }:={\\theta_{0} }-a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{ \\left({ {h}{\\theta } }({ {x}^{(i)} })-{ {y}^{(i)} } \\right)}$${\\theta{1} }:={\\theta_{1} }-a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{\\left( \\left({ {h}_{\\theta } }({ {x}^{(i)} })-{ {y}^{(i)} } \\right)\\cdot { {x}^{(i)} } \\right)}$} 接下来的内容对线性代数进行一个快速的复习回顾。如果你从来没有接触过向量和矩阵，那么这课件上所有的一切对你来说都是新知识，或者你之前对线性代数有所了解，但由于隔得久了，对其有所遗忘，那就请学习接下来的一组视频，我会快速地回顾你将用到的线性代数知识。通过它们，你可以实现和使用更强大的线性回归模型。事实上，线性代数不仅仅在线性回归中应用广泛，它其中的矩阵和向量将有助于帮助我们实现之后更多的机器学习模型，并在计算上更有效率。正是因为这些矩阵和向量提供了一种有效的方式来组织大量的数据，特别是当我们处理巨大的训练集时，如果你不熟悉线性代数，如果你觉得线性代数看上去是一个复杂、可怕的概念，特别是对于之前从未接触过它的人，不必担心，事实上，为了实现机器学习算法，我们只需要一些非常非常基础的线性代数知识。通过接下来几个视频，你可以很快地学会所有你需要了解的线性代数知识。具体来说，为了帮助你判断是否有需要学习接下来的一组视频，我会讨论什么是矩阵和向量，谈谈如何加、减 、乘矩阵和向量，讨论逆矩阵和转置矩阵的概念。","link":"/2018/11/29/2018-11-29-单变量线性回归/"},{"title":"第三章：线性代数回顾(Linear Algebra Review)","text":"参考了斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 矩阵和向量矩阵的维数即行数$\\times$列数矩阵元素（矩阵项）：$A=\\left[ \\begin{matrix} 1402 &amp; 191 \\ 1371 &amp; 821 \\ 949 &amp; 1437 \\ 147 &amp; 1448 \\\\end{matrix} \\right]$$A_{ij}$指第$i$行，第$j$列的元素。向量是一种特殊的矩阵，讲义中的向量一般都是列向量，如：$y=\\left[ \\begin{matrix} {460} \\ {232} \\ {315} \\ {178} \\\\end{matrix} \\right]$为四维列向量（$4\\times 1$）。如下图为1索引向量和0索引向量，左图为1索引向量，右图为0索引向量，一般我们用1索引向量。$y=\\left[ \\begin{matrix} { {y}{1} } \\ { {y}{2} } \\ { {y}{3} } \\ { {y}{4} } \\\\end{matrix} \\right]$，$y=\\left[ \\begin{matrix} { {y}{0} } \\ { {y}{1} } \\ { {y}{2} } \\ { {y}{3} } \\\\end{matrix} \\right]$ 加法和标量乘法矩阵的加法：行列数相等的可以加。组合算法也类似。 矩阵向量乘法$m\\times n$的矩阵乘以$n\\times 1$的向量，得到的是$m\\times 1$的向量。 矩阵乘法$m\\times n$矩阵乘以$n\\times o$矩阵，变成$m\\times o$矩阵。 矩阵乘法的性质矩阵的乘法不满足交换律：$A\\times B≠B\\times A$矩阵的乘法满足结合律。即：$A\\times (B\\times C)=(A\\times B)\\times C$单位矩阵：在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的1,我们称这种矩阵为单位矩阵．它是个方阵，一般用 $I$ 或者 $E$ 表示，本讲义都用 $I$ 代表单位矩阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1以外全都为0。如：$A{ {A}^{-1} }={ {A}^{-1} }A=I$对于单位矩阵，有$AI=IA=A$ 逆、转置矩阵的逆：如矩阵$A$是一个$m\\times m$矩阵（方阵），如果有逆矩阵，则：$A{ {A}^{-1} }={ {A}^{-1} }A=I$我们一般在OCTAVE或者MATLAB中进行计算矩阵的逆矩阵。矩阵的转置：设$A$为$m\\times n$阶矩阵（即$m$行$n$列），第$i $行$j $列的元素是$a(i,j)$，即：$A=a(i,j)$定义$A$的转置为这样一个$n\\times m$阶矩阵$B$，满足$B=a(j,i)$，即 $b (i,j)=a(j,i)$（$B$的第$i$行第$j$列元素是$A$的第$j$行第$i$列元素），记${ {A}^{T} }=B$。(有些书记为A’=B）直观来看，将$A$的所有元素绕着一条从第1行第1列元素出发的右下方45度的射线作镜面反转，即得到$A$的转置。例：${ {\\left| \\begin{matrix} a&amp; b \\ c&amp; d \\ e&amp; f \\\\end{matrix} \\right|}^{T} }=\\left|\\begin{matrix} a&amp; c &amp; e \\ b&amp; d &amp; f \\\\end{matrix} \\right|$矩阵的转置基本性质:$ { {\\left( A\\pm B \\right)}^{T} }={ {A}^{T} }\\pm { {B}^{T} } $${ {\\left( A\\times B \\right)}^{T} }={ {B}^{T} }\\times { {A}^{T} }$${ {\\left( { {A}^{T} } \\right)}^{T} }=A $${ {\\left( KA \\right)}^{T} }=K{ {A}^{T} } $matlab中矩阵转置：直接打一撇，x=y'。","link":"/2018/11/30/2018-11-30-线性代数回顾/"},{"title":"函数程序设计实验十一：词频统计","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126{-给定一个文本文件，构建文件中所有单词及其出现次数的词频表，并将词频表按照格式要求写到一个文件中。词频表按照单词出现次数从高到低次序排列，出现次数相同的按照字典序排列。第十四周上课提交。输入文件样例（见text0.txt ）：Mind-controlled MouseThe three study participants are part of a clinical trial to test a brain-computer interface (BCI) called BrainGate. BrainGate translates participant’s brain activity into commands that a computer can understand. In the new study, researchers first implanted microelectrode arrays into the area of the brain that governs hand movement. The participants trained the system by thinking about moving their hands, something the BCI learned to translate into actions on the screen.输出文件样例（见text0Fre.txt ）：the:8a:3into:3bci:2brain:2braingate:2of:2participants:2study:2that:2to:2about:1actions:1activity:1are:1area:1arrays:1brain-computer:1by:1called:1can:1clinical:1commands:1computer:1first:1governs:1hand:1hands:1implanted:1in:1interface:1learned:1microelectrode:1mind-controlled:1mouse:1movement:1moving:1new:1on:1part:1participant:1researchers:1screen:1something:1system:1test:1their:1thinking:1three:1trained:1translate:1translates:1trial:1understand:1建议：main ::IO main = do ls &lt;- readFile inputfile let result = string2listofpairs ls let formatedResult = formatting result writeFile formatedResult其中string2listofpairs :: String -&gt;[(String, Int)] -- 计算输入串中所有单词及其频率，并排序formatting :: [(String, Int)] -&gt;String -- 按照要求将词频列表转换为输出格式串几点注意事项：1. 大小写不敏感，所有结果用小写字母；2. It's 视为单词 it；3. brain-computer 视为一个单词。-}import System.IOimport Text.Printfimport Data.Charinputfile=\"text0.txt\"outputfile=\"text0Fre.txt\"main::IO()main=do ls&lt;-readFile inputfile let result = string2listofpairs ls let formatedResult=formatting result writeFile outputfile formatedResultstring2listofpairs::String-&gt;[(String,Int)]string2listofpairs s=sortG(cal(group(sortS(words(tolow s)))))sortS::[String]-&gt;[String]sortS []=[]sortS (x:xs)=(sortS[y|y&lt;-xs,y&lt;x])++[x]++(sortS[y|y&lt;-xs,x&lt;=y])cmp::(String,Int)-&gt;(String,Int)-&gt;Boolcmp (a,b) (c,d)= if b/=d then b&gt;d else a&lt;csortG::[(String,Int)]-&gt;[(String,Int)]sortG []=[]sortG (x:xs)=(sortG[y|y&lt;-xs,cmp y x])++[x]++(sortG[y|y&lt;-xs,cmp y x==False])group::[String]-&gt;[[String]]group []=[]group (x:xs)=[[x]++[y|y&lt;-xs,y==x]]++(group[y|y&lt;-xs,y/=x])tolow::String-&gt;Stringtolow []=[]tolow (x:xs)= if (isSpace x)||(isAlphaNum x)||(x=='-') then ((toLower x):(tolow xs)) else tolow xscal::[[String]]-&gt;[(String,Int)]cal []=[]cal (x:xs)=((x!!0,length x):(cal xs))formatting :: [(String, Int)] -&gt;String -- 按照要求将词频列表转换为输出格式串formatting []=[]formatting ((a,b):xs)=(printf \"%s:%d\\n\" a b)++(formatting xs)","link":"/2018/12/03/2018-12-03-词频统计/"},{"title":"函数程序设计实验十二：带变量的布尔表达式","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141module Lab3 whereimport Data.List{-一个布尔表达式就像一个算术表达式，只是这里的值都是布尔值True和False，其中的变量也只能代入布尔值，各种运算用运算表给出。布尔表达式的另一种解读是表示命题，如文件lab3.pdf所讲。如果不理解命题，就看作布尔表达式好了。本作业要求判断一个布尔表达式是不是永真式：即无论将变量代入什么值，其结果总是True。一、定义命题类型及其Show特例命题的集合可以如下定义-真命题(记作T)和假命题(记作F)是命题；-由一个字母表示的命题变元是一个命题；-如果P是命题,则它的否定是一个命题,记作~P；\"~\"称为否定联结词；-如果p,q是命题,则它们的合取是一个命题,记作p&amp;&amp;q; \"&amp;&amp;\"称为合取联结词；-如果p,q是命题,则它们的析取是一个命题,记作p||q; \"||\"称为析取联结词；-如果p,q是命题,则它们的蕴含是一个命题,记作p=&gt;q; \"=&gt;\"称为蕴含联结词；-所有的命题由以上规则经过有限步生成。所以,命题的集合是一个归纳定义的集合,可以用代数类型描述：-}data Prop=Const Bool | Var Char | Not Prop | And Prop Prop | Or Prop Prop | Imply Prop Prop deriving Eq{-习题1试将类型Prop定义成类Show的特例,使得Prop中元素能够显示成定义中我们习惯的表示。例如,Var 'A',And (Var 'P') (Var 'Q')分别显示成A和P&amp;&amp;Q等。-}instance Show Prop where show (Const True)=\"True\" show (Const False)=\"False\" show (Var x)=[x] show (Not x)=\"~\"++show x show (And x y)=(show x)++\"&amp;&amp;\"++(show y) show (Or x y)=(show x)++\"||\"++(show y) show (Imply x y)=(show x)++\"=&gt;\"++(show y){-习题2定义下列值p1,p2,p3::Prop使得它们个表示下列命题:A&amp;&amp;~AA||~AA=&gt;(A&amp;&amp;B)-}p1=And (Var 'A') (Not (Var 'A'))p2=Or (Var 'A') (Not (Var 'A'))p3=Imply (Var 'A') (And (Var 'A') (Var 'B')){-二、命题真值表一个命题或者真,或者假。例如,不包含变元的命题T表示真命题,命 题F表示假命题。包含变元的命题的真假依赖于变元表示命题的真假,所以,一个命题可以看作它包含的变元的函数,称为真值函数,其中每个变元的取 值为真或者假,分别用TVue和False表示。每个命题的取值和其中变元的关系可以用一个表来表示,称之为命题函数的真值表。以下是命题联结词的真值表：对应任意的命题函数，给定变元的一个代换，根据上述真值表可计算相应的真值。例如,命题p3:A=&gt;(A &amp;&amp; B)在代换[('A',True),('B',False)]的真值是False。我们可以用下列类型表示代换：-}type Subst=[(Char,Bool)]{-习题3试根据以上解释定义函数:-}eval::Subst-&gt;Prop-&gt;Bool{-例如&gt;eval [('A',True),('B',False)] p3False-}eval sub (Const p)=peval sub (Var p)=(getBool sub p) where getBool sub x= if length xs &gt;1 then error \"Variable has more than 2 values.\" else head xs where xs=[k|(y,k)&lt;-sub,x==y]eval sub (Not p)=not (eval sub p)eval sub (And p q)=(eval sub p)&amp;&amp;(eval sub q)eval sub (Or p q)=(eval sub p)||(eval sub q)eval sub (Imply p q)=((eval sub p)&amp;&amp;(eval sub q))||(not (eval sub p)){-习题4试定义下列函数：-}vars::Prop-&gt;[Char]substs::Prop-&gt;[Subst]{-其中vars p给出命题p中出现的所有不同变元,substs p给出命题p中变元的所有可能代换。例如vars p3=['A','B']substs p3= [ [('A',True),('B',True)], [('A',True),('B',False)], [('A',False),('B',True)], [('A',False),('B',False)] ]-}vars (Const x)=[]vars (Var x)=[x]vars (Not p)=vars pvars (And p q)=nub((vars p)++(vars q))vars (Or p q)=nub((vars p)++(vars q))vars (Imply p q)=nub((vars p)++(vars q))substs p=getsub (vars p) where getsub []=[] getsub [x]=[[(x,True)]]++[[(x,False)]] getsub (x:xs)=[(x,True):a|a&lt;-getsub(xs)]++[(x,False):a|a&lt;-getsub(xs)]{-三、定义一个判断命题是否永真的函数如果一个命题函数在变元的任意代换下真值是True,则称之为永真式。例如,命题p2是永真式。试定义判定一个命题是否永真式的函数,并说明你的函 数定义的正确性：习题5-}isTaut::Prop-&gt;Bool{-例如&gt;isTaut p1False&gt;isTaut p2True-}isTaut p=testisTaut p (substs p) where testisTaut p [x]=(eval x p) testisTaut p (x:xs)=if (eval x p) then testisTaut p xs else False","link":"/2018/12/11/2018-12-11-带变量的布尔表达式/"},{"title":"C++语言相关","text":"GCC内置位运算12345int __builtin_clz(unsigned int x); //求前缀0的个数int __builtin_ctz(unsigned int x); //求后缀0的个数int __builtin_ffs(unsigned int x); //x的二进制末尾最后一个1的位置，从1开始int __builtin_popcount(unsigned int x); //x二进制中1的个数，相当于bitset::count()int __builtin_parity(unsigned int x); //判断x的二进制中1的个数的奇（1）偶（0）性，这些函数都有相应的usigned long和usigned long long版本，只需要在函数名后面加上l或ll就可以了，比如__builtin_clzll 开栈For C++1#pragma comment(linker, \"/STACK:102400000,102400000\") //For C++ For G++123456int main() //For G++{ int size = 256 &lt;&lt; 20; //256MB char *p = (char *)malloc(size) + size; __asm__ __volatile__(\"movq %0, %%rsp\\n\" ::\"r\"(p)); //64bit，一定要最后写一句`exit(0);`退出程序，否则会得到非零退出的错误，可能RE。} 读入优化C文件指针版12345678910111213141516171819ll getll(FILE *in = stdin){ ll val = 0, sgn = 1, ch = getc(in); for (; !isdigit(ch) &amp;&amp; ch != EOF; ch = getc(in)) if (ch == '-') sgn = -sgn; for (; isdigit(ch); ch = getc(in)) val = val * 10 + ch - '0'; return ungetc(ch, in), sgn * val;}lf getlf(FILE *in = stdin){ lf val = getll(in), p = val &lt; 0 ? -1 : 1; ll ch = getc(in); if (ch == '.') for (ch = getc(in); isdigit(ch); ch = getc(in)) val += (p /= 10) * (ch - '0'); return ungetc(ch, in), val;} 仿C++IO流沙雕版使用前 使用后 12345678910111213141516171819202122232425262728293031323334#define cin kinstruct Istream{ char b[20 &lt;&lt; 20], *i, *e; //20MB Istream(FILE *in) : i(b), e(b + fread(b, sizeof(*b), sizeof(b) - 1, in)) {} bool eof() const { return i == e; } Istream &amp;operator&gt;&gt;(long long &amp;val) { return val = strtoll(i, &amp;i, 10 /*进制，取值2~36*/), *this; } Istream &amp;operator&gt;&gt;(ll &amp;val) //极限快 { while (*i &lt; '0') ++i; //无符号 for (val = 0; *i &gt;= '0'; ++i) val = (val &lt;&lt; 3) + (val &lt;&lt; 1) + *i - '0'; return *this; } Istream &amp;operator&gt;&gt;(double &amp;val) { return val = strtod(i, &amp;i), *this; } Istream &amp;operator&gt;&gt;(string &amp;s) { while (!eof() &amp;&amp; isspace(*i)) ++i; for (s.clear(); !eof() &amp;&amp; !isspace(*i); ++i) s += *i; return *this; }} kin(stdin);","link":"/2019/02/03/2019-02-03-C++语言相关/"},{"title":"离散数学","text":"归并排序求逆序对12345678910111213141516171819ll merge_sort(ll *b, ll *e) //int存答案可能会爆{ if (e - b &lt; 2) return 0; ll i = 0, j = 0, *m = b + (e - b) / 2, ans = merge_sort(b, m) + merge_sort(m, e); vector&lt;ll&gt; l(b, m), r(m, e); while (i &lt; l.size() &amp;&amp; j &lt; r.size()) { if (r[j] &lt; l[i]) *(b++) = r[j++], ans += l.size() - i; else *(b++) = l[i++]; } while (i &lt; l.size()) *(b++) = l[i++]; while (j &lt; r.size()) *(b++) = r[j++]; return ans;} 约瑟夫问题123456789ll josephus(ll n, ll k) //编号0~n-1，每k个出列，时间复杂度O(min(n,k)){ if (n &lt; 3) return k % n; if (n &lt; k) return (Josephus(n - 1, k) + k) % n; ll ret = Josephus(n - n / k, k) - n % k; return ret &lt; 0 ? ret + n : ret + ret / (k - 1);} 蔡勒公式$w=(\\lfloor\\frac{c}{4}\\rfloor-2c+y+\\lfloor\\frac{y}{4}\\rfloor+\\lfloor\\frac{13(m+1)}{5}\\rfloor+d-1)\\mod7$ w：$0,1,\\ldots,6$对应周日，周一，$\\ldots$，周六 c：世纪减1（即年份前两位数）。 y：年份后两位数。 m：月（$3\\leq m\\leq14$，即在蔡勒公式中，1、2月要看作上一年的13、14 月来计算）。 d：日。 曼哈顿距离的变换$\\mid x_1−x_2\\mid +\\mid y_1−y_2\\mid=\\max (\\mid (x_1 + y_1)−(x_2 + y_2)\\mid ,\\mid (x_1 −y_1)−(x_2 −y_2)\\mid )$ 皮克定理顶点坐标均是整点（或说正方形格点）的简单多边形中，面积S和内部格点数目n、边上格点数目m的满足关系$S=n+\\frac{m}{2}-1$。 矩形面积并、矩形面积交、矩形周长并（线段树、扫描线总结）详见这篇博文。","link":"/2019/02/03/2019-02-03-离散数学/"},{"title":"组合数学","text":"组合数取模使用示例 为方便，记$C(n,m)=C_n^m=\\binom{n}{m}$。 12345678910111213141516171819202122struct Factorial : Mod{ vector&lt;ll&gt; fac, ifac; Factorial(int N, ll M) : fac(N, 1), ifac(N, 1), Mod(M) { for (int i = 2; i &lt; N; ++i) fac[i] = mul(fac[i - 1], i), ifac[i] = mul(M - M / i, ifac[M % i]); for (int i = 2; i &lt; N; ++i) ifac[i] = mul(ifac[i], ifac[i - 1]); } ll c(int n, int m) { return mul(mul(fac[n], ifac[m]), ifac[n - m]); } ll lucas(ll n, ll m) //卢卡斯定理求C(n,m)%M，适用于模数M小于N的情况，或者m较小的时候也可以暴力求 { if (!m) return 1; if (n &lt; m || n % M &lt; m % M) return 0; if (n &lt; M &amp;&amp; m &lt; M) return c(n, m); return mul(lucas(n / M, m / M), lucas(n % M, m % M)); }}; 组合数LCM$(n + 1)lcm(C(n,0),C(n,1),\\ldots,C(n,k))=lcm(n+1,n,n−1,n−2,\\ldots,n−k+1)$ 区间lcm的维护：对于一个数，将其分解质因数，若有因子$p^k$，那么拆分出k个数 $p^1,p^2,\\ldots,p^k$，权值都为p，那么区间$[l,r]$内所有数的lcm的答案=所有在该区间中出现过的数的权值之积，可持久化线段树维护之。 Stirling数第一类斯特林数第一类斯特林数$S(p,k)$的一个的组合学解释是：将p个物体排成k个非空循环排列的方法数。 递推公式：$S(p,k)=(p−1)S(p−1,k)+S(p−1,k−1),1\\leq k\\leq p−1;S(p,0)=0,p\\ge1;S(p,p)=1,p\\ge0$ 第二类斯特林数第二类斯特林数$S(p,k)$的一个的组合学解释是：将p个物体划分成k个非空不可辨别的（可以理解为盒子没有编号）集合的方法数。 递推公式：$S(p,k)=kS(p−1,k)+S(p−1,k−1),1\\leq k\\leq p−1;S(p,0)=0,p\\ge 1;S(p,p)=1,p\\ge0$ 卷积形式：$S(n,m)=\\frac{1}{m!}\\sum_{k=0}^m(-1)^kC(m,k)(m-k)^n=\\sum_{k=0}^m\\frac{(-1)^k}{k!}\\frac{(m-k)^n}{(m-k)!}$ 同时有转化：$x^k=\\sum_{i=1}^ki!C(x,i)S(k,i)$ 斯特林近似公式$n!\\approx\\sqrt{2\\pi n}(\\frac{n}{e})^n$ 小球入盒模型通解 k个球 m个盒子 空盒子 方案数 各不相同 各不相同 允许 $m^k$ 各不相同 各不相同 无 $m!Stirling2(k,m)$ 各不相同 完全相同 允许 $\\sum_{i=1}^mStirling2(k,i)$ 各不相同 完全相同 无 $Stirling2(k,m)$ 完全相同 各不相同 允许 $C(m+k−1,k)$ 完全相同 各不相同 无 $C(k−1,m−1)$ 完全相同 完全相同 允许 $\\frac{1}{(1−x)(1−x^2)…(1−x^m)}的x^k项的系数$ 完全相同 完全相同 无 $\\frac{x^m}{(1−x)(1−x^2)…(1−x^m)}的x^k项的系数$ 置换使用示例 12345678910111213141516171819202122232425262728293031struct Permutation : vector&lt;int&gt;{ Permutation(int n = 0) : vector&lt;int&gt;(n) {} friend Permutation operator*(const Permutation &amp;f, const Permutation &amp;g) { Permutation ans(f.size()); for (int i = 0; i &lt; f.size(); ++i) ans[i] = g[f[i]]; return ans; } friend Permutation inv(const Permutation &amp;f) { Permutation ans(f.size()); for (int i = 0; i &lt; f.size(); ++i) ans[f[i]] = i; return ans; } friend vector&lt;vector&lt;int&gt;&gt; cycle(const Permutation &amp;f) { vector&lt;int&gt; vis(f.size(), 0); vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; f.size(); ++i) if (!vis[i]) { ans.push_back(vector&lt;int&gt;()); for (int j = i; !vis[j]; j = f[j]) vis[j] = 1, ans.back().push_back(j); } return ans; }}; 生成字典序下一排列对给定的排列$a_1a_2\\ldots a_n$，找到$a_j$使得$a_j&lt;a_{j+1},a_{j+1}&gt;a_{j+2}&gt;\\ldots&gt;a_n$即这列数中最后一个相邻递增数对，然后把$a_{j+1},a_{j+2},\\ldots,a_n$中大于$a_j$的最小数放到位置j，然后$a_j\\ldots a_n$中剩余的数从小到大排序放到$[j+1,n]$中。 1234567891011bool nextPermutation(ll *b, ll *e) //标准库有这个函数next_permutation{ ll *i = e - 1, *j = e - 2; while (j &gt;= b &amp;&amp; *j &gt;= *(j + 1)) --j; if (j &lt; b) return 0; while (*i &lt;= *j) --i; return swap(*i, *j), reverse(j + 1, e), 1;} 二项式反演$f(n)=\\sum_{k=0}^nC(n,k)g(k),g(n)=\\sum_{k=0}^n(−1)^{n−k}C(n,k)f(k)$ 第k小期望$f(n,k)$表示有n个变量，和为1，第k小的期望。 $f(n,k)=\\frac{1}{n^2}+(1-\\frac{1}{n})f(n-1,k-1),f(n,0)=0$ 错排数考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数$D_n$满足递推公式：$D_1=0,D_2=1,D_n=(n−1)(D_{n−2}+D_{n−1})$ 通项：$D(n)=n![\\frac{(-1)^2}{2!}+\\ldots+\\frac{(-1)^{n-1} }{(n-1)!}+\\frac{(-1)^n}{n!}]=\\lfloor\\frac{n!}{e}+\\frac{1}{2}\\rfloor$ Bonuli数使用示例 $B_n = -\\frac{1}{C(n+1,n)}(C(n+1,0)B_0+C(n+1,1)B_1+\\ldots+C(n+1,n-1)B_{n-1})=-\\frac{1}{n+1}(C(n+1,0)B_0+C(n+1,1)B_1+\\ldots+C(n+1,n-1)B_{n-1})$ 可用于计算任意正整数次数的幂和：$\\sum_{i=1}^ni^k=\\frac{1}{k+1}\\sum_{j=0}^kC(k+1,j)B_jn^{k+1-j}$ 1234567891011121314151617181920struct Bonuli : Factorial{ vector&lt;ll&gt; b; Bonuli(int N, ll M) : Factorial(N, M), b(N, 0) { for (int i = b[0] = 1; i &lt; N; ++i) { for (int j = 0; j &lt; i; ++j) b[i] = (b[i] + mul(b[j], c(i + 1, j), M)) % M; b[i] = (M - mul(mul(fac[i], ifac[i + 1], M), b[i], M)) % M; } } ll ask(ll n, int k) //return $\\sum_{i=1}^ni^k\\mod M$ { ll r = 0, w = 1, u = (n + 1) % M; for (int i = 1; i &lt;= k + 1; ++i) r = (r + mul(mul(b[k + 1 - i], c(k + 1, i), M), w = mul(w, u, M), M)) % M; return mul(mul(fac[k], ifac[k + 1], M), r, M); }}; Catalan数$h_1=1,h_n=\\frac{4n−2}{n+1}h_{n−1}=\\frac{C(2n,n)}{n+1}=C(2n,n)−C(2n,n−1)$。 在一个格点阵列中，从$(0,0)$点走到$(n,m)$点且不经过对角线$x=y$的方法数：$C(n+m−1,m)−C(n+m−1,m−1),x&gt;y;C(n+m,m)−C(n+m,m−1),x\\ge y$。 常见的Catalan数：括号序的个数、凸多边形三角剖分的方案数等。 Bell数把n个带标号的物品划分为若干不相交集合的方案数称为贝尔数，其递推公式：$B_n=\\sum_{i=0}^{N-1}C_{n-1}^iB_i$ 前几项贝尔数： 11,2,5,15,52,203,877,4140,21147,115975,678570,4213597,27644437,190899322,1382958545,... 下为$O(P^2\\log P)$求$B_n$对P取模。 1234567891011121314151617181920212223242526272829303132struct Bell{ static const int P=999999598,N=7284; int a[4],f[N],s[2][N],i,j,x; Bell() { a[0]=2,a[1]=13,a[2]=5281,a[3]=7283;//P的质因数分解 f[0]=f[1]=s[0][0]=1,s[0][1]=2; for(i=2,x=1; i&lt;N; i++,x^=1) for(f[i]=s[x][0]=s[x^1][i-1],j=1; j&lt;=i; ++j) s[x][j]=(s[x^1][j-1]+s[x][j-1])%P; } int cal(int x,ll n) { int i,j,k,m=0,b[N],c[N],d[70]; for(i=0; i&lt;=x; i++)b[i]=f[i]%x; while(n)d[m++]=n%x,n/=x; for(i=1; i&lt;m; i++)for(j=1; j&lt;=d[i]; j++) { for(k=0; k&lt;x; k++)c[k]=(b[k]*i+b[k+1])%x; c[x]=(c[0]+c[1])%x; for(k=0; k&lt;=x; k++)b[k]=c[k]; } return c[d[0]]; } ll ask(ll n) { if(n&lt;N)return f[n]; ll t=0; for(int i=0; i&lt;4; ++i)t=(t+(P/a[i])*pow(P/a[i],a[i]-2,a[i])%P*cal(a[i],n)%P)%P; return t; }}; 等价类容斥考虑容斥，Bell(p)枚举所有等价情况。对于一种情况，强制了一个等价类里面的数都要相同，其它的可以相同也可以不同。 容斥系数为：$(−1)^{p−等价类个数}(每个等价类大小−1)!之积$。 Grey码格雷序列第i个是i^(i&gt;&gt;1)。长为n的01序列共$2^n$个，下标从$0\\ldots 2^n-1$。 扩展Cayley公式对于n个点，m个连通块的图，假设每个连通块有a[i]个点，那么用s−1条边把它连通的方案数为$n^{s−2}a[1]a[2]\\ldots a[m]$。 超立方体n维超立方体有$2^{n−i}C(n,i)$个i维元素。 枚举位集I的非空子集J1for(J=I; J; J=I&amp;J−1) {}","link":"/2019/02/03/2019-02-03-组合数学/"},{"title":"线性代数","text":"矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Matrix{ static int n; //方阵代替矩阵 ll a[N][N]; Matrix(ll k = 0) { for (int i = 0; i &lt; n; ++i) fill(a[i], a[i] + n, 0), a[i][i] = k; } friend Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) { Matrix r(0); for (int i = 0; i &lt; r.n; ++i) for (int j = 0; j &lt; r.n; ++j) for (int k = 0; k &lt; r.n; ++k) r.a[i][j] = M.add(r.a[i][j], M.mul(a.a[i][k], b.a[k][j])); return r; } friend Matrix pow(Matrix a, ll b) { Matrix r(1); for (; b; b &gt;&gt;= 1, a = a * a) if (b &amp; 1) r = r * a; return r; } friend ll det(Matrix a) //矩阵a的n阶行列式 { ll ans = 1; for (int i = 0; i &lt; a.n; ++i) { for (int j = i + 1; j &lt; a.n; ++j) while (fabs(a[j][i]) &gt; EPS) { ll t = a[i][i] / a[j][i]; for (int k = i; k &lt; n; ++k) a[i][k] -= t * a[j][k], swap(a[i][k], a[j][k]); } if (fabs(ans *= a[i][i]) &lt; EPS) return 0; } return ans; }};//int Matrix::n=N; 高斯消元1234567891011121314151617181920212223struct GaussElimination : Matrix{ void ask() //a为增广矩阵，要求n*n的系数矩阵可逆，运行结束后a[i][n]为第i个未知数的值 { for (int i = 0, r; i &lt; n; ++i) { for (int j = r = i; j &lt; n; ++j) if (fabs(a[r][i]) &lt; fabs(a[j][i])) r = j; if (r != i) swap_ranges(a[r], a[r] + n + 1, a[i]); for (int j = n; j &gt;= i; --j) for (int k = i + 1; k &lt; n; ++k) a[k][j] -= a[k][i] * a[i][j] / a[i][i]; } for (int i = n - 1; ~i; --i) { for (int j = i + 1; j &lt; n; ++j) a[i][n] -= a[j][n] * a[i][j]; a[i][n] /= a[i][i]; } }}; 线性基向量线性基add返回要插入的向量z是否与已插入的线性无关。 123456789101112131415161718struct Base{ vector&lt;vector&lt;double&gt;&gt; v; Base(int N) : v(N, vector&lt;double&gt;(N, 0)) {} //R^N的子空间 bool add(vector&lt;double&gt; x) { for (int i = 0; i &lt; x.size(); ++i) if (fabs(x[i]) &gt; EPS) { if (fabs(v[i][i]) &lt; EPS) return v[i] = x, 1; double t = x[i] / v[i][i]; for (int j = 0; j &lt; x.size(); ++j) x[j] -= t * v[i][j]; } return 0; }}; 异或线性基若要查询第k小子集异或和，则把k写成二进制，对于是1的第i位，把从低位到高位第i个不为0的数异或进答案。若要判断是否有非空子集的异或和为0，如果不存在自由基，那么说明只有空集的异或值为0，需要高斯消元来判断。 1234567891011121314151617181920212223242526272829303132struct BaseXOR{ vector&lt;ll&gt; a; BaseXOR() : a(64, 0) {} ll ask() //查询最大子集异或和 { ll t = 0; for (int i = a.size() - 1; ~i; --i) t = max(t, t ^ a[i]); return t; } bool add(ll x) { for (int i = a.size() - 1; ~i; --i) if (x &gt;&gt; i &amp; 1) { if (a[i]) x ^= a[i]; else return a[i] = x, 1; } return 0; } bool check(ll x) //判断一个数是否能够被异或出，0根据需要特判 { for (int i = a.size() - 1; ~i; --i) if (x &gt;&gt; i &amp; 1) if (x ^= a[i], !x) return 1; return 0; }};","link":"/2019/02/03/2019-02-03-线性代数/"},{"title":"配置TensorFlow","text":"该补上的文章🕊了太久了… 工具准备jupyter notebookAnacondaAnaconda集成了很多 Python的第三方库。 安装它之后就可以不用再去一个一个地下载这些库并解决它们之间的依赖关系了，是十分方便的。在Anaconda Distribution上下载。运行下述脚本 1bash Anaconda3-2018.12-Linux-x86_64.sh 运行下述命令检查 1conda list 报错：conda:未找到命令修改环境变量 1vim ~/.bashrc 在最后添加： 1export PATH=~/anaconda3/bin:$PATH 重启环境变量： 1source ~/.bashrc TensorFlow 坑 建立TensorFlow的运行环境，并将其激活，执行： 12conda create -n tensorflow python=3.7source activate tensorflow 这样就激活了虚拟环境。执行以下代码进行 TensorFlow 的安装： 12345678pip3 install tensorflow``` 执行以下代码测试 TensorFlow 是否安装成功，运行一个 Hello TensorFlow```pythonimport tensorflow as tfhello = tf.constant(&apos;Hello, TensorFlow!&apos;)sess = tf.Session()print sess.run(hello) 1Hello, TensorFlow!","link":"/2019/02/06/2019-02-06-配置TensorFlow/"},{"title":"一个基于MINST数据集的神经网络实验","text":"照着官方文档按图索骥…算是熟悉一下TF的用法吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960python3 fully_connected_feed.py/home/wuk/anaconda3/envs/tensorflow/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: compiletime version 3.6 of module &apos;tensorflow.python.framework.fast_tensor_util&apos; does notmatch runtime version 3.7 return f(*args, **kwds)WARNING:tensorflow:From fully_connected_feed.py:120: read_data_sets (fromtensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.Instructions for updating:Please use alternatives such as official/mnist/dataset.py from tensorflow/models.WARNING:tensorflow:From /home/wuk/anaconda3/envs/tensorflow/lib/python3.7/site-packages/tensorflow/contrib/learn/python/learn/datasets/mnist.py:260: maybe_download (from tensorflow.contrib.learn.python.learn.datasets.base) is deprecated and will be removed in a future version.Instructions for updating:Please write your own downloading logic.WARNING:tensorflow:From /home/wuk/anaconda3/envs/tensorflow/lib/python3.7/site-packages/tensorflow/contrib/learn/python/learn/datasets/mnist.py:262: extract_images (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.Instructions for updating:Please use tf.data to implement thisfunctionality.Extracting /tmp/tensorflow/mnist/input_data/train-images-idx3-ubyte.gzWARNING:tensorflow:From /home/wuk/anaconda3/envs/tensorflow/lib/python3.7/site-packages/tensorflow/contrib/learn/python/learn/datasets/mnist.py:267: extract_labels (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.Instructions for updating:Please use tf.data to implement thisfunctionality.Extracting /tmp/tensorflow/mnist/input_data/train-labels-idx1-ubyte.gzExtracting /tmp/tensorflow/mnist/input_data/t10k-images-idx3-ubyte.gzExtracting /tmp/tensorflow/mnist/input_data/t10k-labels-idx1-ubyte.gzWARNING:tensorflow:From /home/wuk/anaconda3/envs/tensorflow/lib/python3.7/site-packages/tensorflow/contrib/learn/python/learn/datasets/mnist.py:290: DataSet.__init__ (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.Instructions for updating:Please use alternatives such as official/mnist/dataset.py from tensorflow/models.2019-02-06 19:33:58.080074: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was notcompiled to use: AVX2 FMAStep 0: loss = 2.31 (0.568 sec)Step 100: loss = 2.15 (0.003 sec)Step 200: loss = 1.93 (0.003 sec)Step 300: loss = 1.51 (0.004 sec)Step 400: loss = 1.28 (0.002 sec)Step 500: loss = 1.01 (0.003 sec)Step 600: loss = 0.77 (0.002 sec)Step 700: loss = 0.67 (0.002 sec)Step 800: loss = 0.69 (0.004 sec)Step 900: loss = 0.43 (0.003 sec)Training Data Eval:Num examples: 55000 Num correct: 47163 Precision @ 1: 0.8575Validation Data Eval:Num examples: 5000 Num correct: 4319 Precision @ 1: 0.8638Test Data Eval:Num examples: 10000 Num correct: 8663 Precision @ 1: 0.8663Step 1000: loss = 0.54 (0.044 sec)Step 1100: loss = 0.47 (0.552 sec)Step 1200: loss = 0.51 (0.003 sec)Step 1300: loss = 0.39 (0.003 sec)Step 1400: loss = 0.46 (0.003 sec)Step 1500: loss = 0.26 (0.003 sec)Step 1600: loss = 0.46 (0.003 sec)Step 1700: loss = 0.29 (0.003 sec)Step 1800: loss = 0.45 (0.003 sec)Step 1900: loss = 0.49 (0.003 sec)Training Data Eval:Num examples: 55000 Num correct: 49275 Precision @ 1: 0.8959Validation Data Eval:Num examples: 5000 Num correct: 4508 Precision @ 1: 0.9016Test Data Eval:Num examples: 10000 Num correct: 9014 Precision @ 1: 0.9014","link":"/2019/02/06/2019-02-06-一个基于MINST数据集的神经网络实验/"},{"title":"卷积网络做图片分类","text":"一个用CNN做图片分类的例子，是把 CNN 应用于 CIFAR-10 上的 一个实验过程 123\"\"\"挖坑待填…\"\"\"","link":"/2019/02/08/2019-02-08-卷积网络做图片分类/"},{"title":"前馈神经网络","text":"节日快乐（并不）… “机器学习”顾名思义就是机器通过对观测到的事物进行归纳，进而总结出它们之间的规律、关系一类。 各神经元从输入层开始，接收前一级输入，并输入到下一级，直至输出层。整个网络中无反馈，可用一个DAG（有向无环图）表示。 在这么多神经元更新的时候，让它们每个值都往一个方向变，什么方向呢？就是刚刚我们说的使得损失函数向不断降低的方向变，降低模型预测结果和给定的目标值之间的差距， 这点记住了就足够了。更为复杂的神经网络构建方式，从本质来讲都一样，是通过不断调整各个神经元中的待定系数使得损失函数向不断降低的方向移动。 通过凸优化的方式能够顺利求出损失函数的极值。然而我们在真正的生产环境遇到的各种神经网络中包含着非常多的线性和非线性分类器函数组合，这也就意味着，在这种复杂的网络环境中，损失函数极有可能，甚至可以说几乎 一定不是凸函数一一在这个函数的空间中会呈现出“层峦叠幢”、 “坑坑洼洼”的不规则形 状，而非前面我们画出来的一个大碗。 因此，在真正的商用框架中——比如 Tensor Flow 会用很多技巧来寻找在整个向量空间中拥有极小值点的参数向量。对于这种不规则形状的非凸函数来说，当然也是可以通过遗传算法、随机梯度下降等多种方式相结合的方法来不断试探找到极小值点位置的。当然，这些过程对于一个普通的 TensorFlow 的使用者来说是透明的，它们已经由那些数据科学家们实现并封装在框架中了。 下面整理一些学习笔记。 网络结构BP（前馈神经）网络是所有的神经网络中结构最为单纯的一种，如下图。分成输入层、隐藏层、输出层。节点数目可以不一样而且不对称。神经网络本身就有很多种设计模式，并且会在不同的模式下 产生不同的训练效果和运用特点。 损失函数管这种函数叫Cost或者Loss。深度学习中的损失函数其实是不一而足的，每种损失函数在当初诞生的时候都是有－些客观环境和理由的。但不管是哪种损失函数，都有这样几个特点。 恒非负。都说是损失了，最圆满的情况就是没损失，或者说损失为 0，但凡有一点拟合的偏差那 就会让损失增加。 所以损失函数都是恒非负的，否则也无法出现合理的解释了。 误差越小函数值越小。这个性质也是非常重要的，如果函数定义的不好，优化起来没有方向或者逻辑过于复 杂，那对于问题处理显然是不利的。 收敛快。指在我们优化这个损失函数Loss的迭代过程中需要让它比较快地逼近极小值，逼近函数值的低点。同等情况下一个钟头能得到解那绝对没必要花三个钟头，好的损失函数的定义会让这个训练时间在一定程度上缩短的。这个条件不能算是必要条件，因为它只要不影响正确性，慢一点其实也不能算作“错误”。 训练过程回过头来再看我们初始化$(w_0,b_0,Loss_0)$后下一步怎么做。$w_1=w_0-\\eta\\frac{\\partial Loss}{\\partial w},b_1=b_0-\\eta\\frac{\\partial Loss}{\\partial b}$再次强调一下，不求梯度（偏导数）的情况下，通过改变$w$或$b$的值是一定能够比较 出来移动的方向的，但是问题是不知道移动多少比较适宜。 而有了偏导数与学习率$\\eta$的乘积后，当这个点逐步接近“碗底”的时候，偏导数也随之降低，移动的步伐也会慢慢减小，收敛更为平缓，不会轻易出现“步子太大”而越过最低点的情况。一轮一轮进行迭代，直到每次更新的值非常小，损失值不再明显减少就可以判断为训 练结束。此时得到的$w,b$值就是我们要求的模型。","link":"/2019/02/14/2019-02-14-前馈神经网络/"},{"title":"","text":"什么是计算机网络？ 计算机网络(computer network)是自主计算机的互连集合。（ANDREW S. TANENBAUM） 计算机网络是利用通信设备和线路将地理位置不同的、功 能独立的多个计算机系统***连接***起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。 简单来说就是连接两台或多台计算机进行通信的系统。（维基百科） 直接连接的网络12graph LRA--链路（link），专用介质（dedicated medium）---B,节点(node)或主机(host) 点到点网络 (point-to-point network) 单向(simplex) 半双工(half duplex) 全双工(full duplex) 12graph LR共享介质(shared medium), 广播, 碰撞(collision) 多路访问网络 (multiple access network) 单播(unicast) 多播(multicast) 广播(broadcast) 间接连接的网络 中间节点、路由器(router) 包(packet) 存储转发(store-and-forward) 路由选择(routing) 路由(route) 目的地(destination),下一跳(next hop) 路由表(routing table) 网络互连用路由器(或网关)连接起来构成的网络称为互连网络(internetwork 或internet)。因特网 (Internet) 是一种互连网络。 1234graph TB路由器---网络1路由器---网络2路由器---网络3 系统域网(System Area Network, SAN) 局域网(Local Area Network, LAN) 城域网(Metropolitan Area Network, MAN) 广域网(Wide Area Network, WAN) 局域网（LAN）：一般限定在较小的区域内（小于10km的范围），通常采用有线的方法连接起来。城域网（MAN）：规模局限在一座城市的范围内。广域网（WAN）：网络跨越国界、洲界，甚至遍及全球范围。个人区域网（PAN）：一般指家庭一台或多台电脑所使用的网络无线局域网（WLAN）：是指通过无线设备建立的，给支持无线通信的设备使用的，比如无线网卡，或手机上的WIFI。 什么是因特网？ISP ( Internet Service Provider) – 因特网服务提供商 终端系统(end system)：主机 运行网络应用程序 (例如，浏览器) 通信链路(communication link) 光纤, 铜线, 无线电, 卫星 传输速率=带宽 路由器(router) 因特网体系结构网络提供的服务数据链路层一般都提供3种基本服务，即无确认的无连接服务、有确认的无连接服务、有确认 的面向连接的服务。 （1）无确认的无连接服务 无确认的无连接服务是源机器向目的机器发送独立的帧，而目的机器对收到的帧不作确认。如果由于线路上的噪声而造成帧丢失，数据链路层不作努力去恢复它，恢复工作留给上层去完成。这类服务适用于误码率很低的情况，也适用于像语音之类的实时传输，实时传输情况下有时数据延误比数据损坏影响更严重。大多数局域网在数据链路层都使用无确认的无连接服务。 （2）有确认的无连接服务 这种服务仍然不建立连接，但是所发送的每一帧都进行单独确认。以这种方式，发送方就会知道帧是否正确地到达。如果在某个确定的时间间隔内，帧没有到达，就必须重新发此帧。 （3）有确认的面向连接的服务 采用这种服务，源机器和目的机器在传递任何数据之前，先建立一条连接。在这条连接上所发送的每一帧都被编上号，数据链路层保证所发送的每一帧都确实已收到。而且，它保证每帧只收到一次，所有的帧都是按正确顺序收到的。面向连接的服务为网络进程间提供了可靠地传送比特流的服务。 开放系统互连参考模型网络性能分析","link":"/2019/04/11/2019-03-06-计算机网络 第一章 概述/"},{"title":"计算机网络 第二章 物理层","text":"通信系统(Communication System)Information(信息) can be interpreted as a message(data), recorded as signs(符号), transmitted as signals(信号), measured as the entropy(熵)。 信号(signal) : optical signal, electronic signal, radio signal 模拟信号(analog signal)：连续取值的信号 数字信号(digitial signal)：用离散值表示的信号（跳变信号） 模拟传输(analog transmission): 模拟信号(analog signal), 放大器(amplifier) 数字传输( digital transmission): 数字信号(digital signal), 中继器(repeater) 正弦波信号 $\\omega_c$ ：角频率。$\\omega_c=2\\pi f$ f：频率 (frequency) $f=1/T$ T:周期 (period) A:振幅 (amplitude) $\\phi$: 相位 (phase) ( 初 相 ) 。 频移键控 (Frequency-Shift Keying, FSK)幅移键控 (Amplitude-Shift Keying, ASK)相移键控 (Phase-Shift Keying, PSK)正交调幅 (QAM –quadrature amplitude modulation)编码单极编码(unipolar encoding)不归零编码 (Non-Return-to-Zero,NRZ或NRZ-L)不归零编码是一种双极编码(bipolar encoding)。双极编码的波形就是二 进制符号，0、1分别与正、负电位相对应。它的电脉冲之间也无间隔。 RS-232C的接口电压就是采用双极编码 曼彻斯特编码(Manchester Encoding)曼彻斯特码的编码规则(以太网)是：0 → 10， 1 → 01 差分曼彻斯特编码 (Differential Manchester Encoding)差分曼彻斯特码是一种差分双相码，先把输入的NRZ波形变换成差分波形 ，再用绝对双相码(第一个规则)编码，即，”1”起始不跳变，”0”起始跳变， 再用Manchester编码第一规则按当前电平进行编码。简单描述：起始是否 跳变确定是否0或1，中间一定跳变。 4B/5B编码用5比特表示4比特。 每个编码没有多于1个的前导零和多于2个的末端 零。如果结合NRZI编码，就可以既防止跳变过多，又消除基线漂移和 时钟漂移。其它编码用于控制，如，11111表示空闲。 物理介质(Physical Media)有线介质非屏蔽双绞线(Unshielded Twisted Pair) 四对线: 绿 绿白，橙 橙白，蓝 蓝白，棕棕白 每对线先逆时针绞在一起，然后所有线对再逆时针绞在一起。 标准568A：绿白 1，绿 2，橙白 3，蓝 4，蓝白 5，橙 6，棕白 7，棕 8 标准568B：橙白 1，橙 2，绿白 3，蓝 4，蓝白 5，绿 6，棕白 7，棕 8 屏蔽双绞线 (Shielded Twisted Pair)光导纤维 (Optical Fiber) 在玻璃纤维传输光脉冲, 每个脉冲一比特 全反射条件: 入射角大于临界角 单模光纤和多模光纤阶跃光纤渐变光纤无线介质(大气) 地面微波 45 Mbps channels WiFI 54 Mbps(802.11g),600Mbps(802.11n) 3G网络 ~ 1 Mbps 卫星 1 Kbps ~ 45Mbps 270 msec 延迟 电磁谱多路复用和电路交换 时分多路复用(Time Division Multiplexing) (STDM–Synchronous TDM) 频分多路复用(Frequency Division Multiplexing) 波分多路复用(Wavelength Division Multiplexing) 码分多路复用(Code Division Multiplexing)：3G中使用的CDMA通过编码的方式 波分多路复用和统计多路复用","link":"/2019/03/06/2019-03-06-计算机网络 第二章 物理层/"},{"title":"计算机网络 第三章 数据链路层","text":"概述 数据链路层负责把数据包从一个节点通过链路（直连网络或物理网络）传给相邻的另一个节点。 主机和路由器是节点(nodes) 连接相邻节点的通道是链路(links) 有线链路(wired links) 无线链路(wireless links) 局域网(LANs) 第2层的数据包(packet)是帧(frame) 功能 形成帧 (framing) 差错检测(error detect)：比特错，纠错 差错控制(error control)：丢包、重复、错序。流控制(flow control) 介质访问控制(medium access control): 多路访问，碰撞(collision) 差错检测1234567graph LR数据报--&gt;数据报|校验码数据报|校验码--链路--&gt;可能发生比特错可能发生比特错--&gt;数据报&apos;|校验码&apos;数据报&apos;|校验码&apos;--&gt;有错？有错？--有--&gt;纠错或丢弃有错？--无--&gt;数据报 奇偶校验检验和(Checksum)由于需要使用加法器实现算法，校验和一般不用于数据链路层 ，而是更高层，例如 ，IP层和传输层。 循环冗余校验码(Cyclic Redundancy Check, CRC)如果传输过程中没有出现比特错，接 收方用相同的除数去除数据加CRC校 验码，余数应该为0。(Cyclic Redundancy Check, CRC) 采用模2除法：做减法时没有借位，类似于按位异或。 链路层常用CRC检验，因为容易用硬件实现，速度快，检错率很高。 CRC-CCITT(x16+x12+x5+1)的错误检测能力：可以检出所 有随机奇数位错误和双位错，可以检出所有长度小于等 于16位的突发错；对于长度等于17位的突发错误，检错 率为99.9969%；长度大于等于18位的突发错误，检错率 为99.9985%。 可靠数据传输停等协议滑动窗口协议PPP协议","link":"/2019/03/08/2019-03-08-计算机网络 第三章 数据链路层/"},{"title":"Deepin中安装配置ChromeDriver","text":"查看当前的Chrome版本信息在谷歌浏览器地址栏中输入chrome://version/可以查看当前的Chrome信息： 1234567891011Google Chrome： 62.0.3202.62 (正式版本) （64 位）修订版本： 9da914b118cb0d10d715ccc4ad20575a0305a304-refs/branch-heads/3202@{#700}操作系统： LinuxJavaScript： V8 6.2.414.32Flash： 29.0.0.113 /home/wenbin/.config/google-chrome/PepperFlash/29.0.0.113/libpepflashplayer.so用户代理： Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36命令行： /usr/bin/google-chrome-stable --flag-switches-begin --flag-switches-end可执行文件路径： /opt/google/chrome/google-chrome个人资料路径： /home/wenbin/.config/google-chrome/Default其他变体： c134752e-b8b72c88 .............. chromedriver版本 支持的Chrome版本 v2.34 v61-63 v2.33 v60-62 v2.32 v59-61 v2.31 v58-60 v2.30 v58-60 v2.29 v56-58 v2.28 v55-57 v2.27 v54-56 v2.26 v53-55 v2.25 v53-55 v2.24 v52-54 v2.23 v51-53 v2.22 v49-52 v2.21 v46-50 v2.20 v43-48 v2.19 v43-47 v2.18 v43-46 v2.17 v42-43 v2.13 v42-45 v2.15 v40-43 v2.14 v39-42 v2.13 v38-41 v2.12 v36-40 v2.11 v36-40 v2.10 v33-36 v2.9 v31-34 v2.8 v30-33 v2.7 v30-33 v2.6 v29-32 v2.5 v29-32 v2.4 v29-32 下载对应的Chromedriver版本下载地址： 1http://npm.taobao.org/mirrors/chromedriver/ 配置将下载来的ChromeDriver解压，得到一个ChromeDriver文件我们只需要将ChromeDriver文件放到/uer/bin/路径下 1sudo cp chromedriver /usr/bin/ 测试安装是否成功编写py文件写入以下代码： 1234from selenium import webdriverdriver = webdriver.Chrome()driver.get(&quot;https://www.baidu.com&quot;) 运行之后，如果能过弹出Chrome页面，就说明安装成功：","link":"/2018/06/22/Deepin中安装配置ChromeDriver/"},{"title":"Python解释器的安装与配置","text":"下载python解释器 如下图所示，在浏览器中打开python官方网站：https://www.python.org/ 点击Downloads进入下载页面 如下图所示： 注：关于Python解释器版本的选择补充说明 附官方文档截图说明： 下载完成后选择软件包安装路径 注：路径最好不要出现中文 因为我的电脑只有一个C盘，所以为了方便管理安装的软件，我创建了一个software文件夹，然后再在software文件夹里创建对应安装包的安装文件夹 如下图：C:\\software\\python3.7 进行安装 ​ 出现如下安装界面 ​ ​ 添加python解释器的环境变量 ​ 这里我们可以选择安装到自己指定的安装目录 ​ ​ 点击进入指定目录安装，勾选的选项默认就好，不需修改 ​ 勾选的选项默认就好，不需修改 ​ 点击Browse修改Python解释器的默认安装路径 ​ 修改后的安装路径显示 ​ 点击Install进行安装 ​ ​ ​ ​ 如图所示即安装成功 ​ 测试是否安装成功 按下 win+R 组合键打开windows系统的命令终端 ​ 命令终端如下图所示 ​ 至此Python解释器即安装成功啦由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。","link":"/2018/05/15/Python解释器的安装与配置/"},{"title":"Ubuntu安装chrome浏览器和chromedriver","text":"安装chrome步骤 一. 下载chrome安装包 使⽤ubuntu上的⽕狐浏览器打开如下地址：http://www.google.cn/intl/zhCN/chrome/browser/desktop/index.html 选择安装版本，接受并安装a. 选择64bit.deb(适⽤于Deblan/Ubuntu) 点击接受并安装后，选择保存到本地a. ‘Save file’或者‘保存到本地’ 下载下来后，会保存在Dowdload⽂件中cd ~/Dowdload 切换到下载⽂件⽬录中ls 进⾏查看 二. 安装chrome浏览器 打开终端，切换到root⽤户，进⼊下载⽂件夹a. cd ~/Dowdloadb. sudo dpkg -i google-chrome-stable_current_amd64.deb 初次安装如果出现 Errors where encountered whileprocessing:google-chrome-stable 这个错误，就需要安装googlechrome-stablea. apt-get install google-chrome-stable 如果安装了google-chrome-stable后，还报错，错误信息为： Unmetdependencies. “Try apt-get -f install” with no packages (orspecify ….)a. 这个时候按照提示执⾏apt-get -f install 如果中间提示”是否继续安装” 输⼊ y v. 安装完毕后，重新执⾏第⼀步的命令 sudo dpkg -i google-chromestable_current_amd64.deb 如果此时没有报错就说明已经安装成功 三.安装chromedriver 通过百度，搜索“淘宝NPM” 寻找chromedriver下载地址，点击进⼊ 通过百度，搜索“chrome和chromedriver的对照表”，选择⾃⼰的合适的chromedriver 返回第⼀步打开的chromedriver版本⽹⻚，下载适合⾃⼰浏览器的chromedriver 下载之后，在下载⽂件夹中找到，点击右键，选择解压到当前⽬录 打开终端，将解压后的chromedriver执⾏程序，拷⻉到 /usr/bin ⽬录下cd~/Downloadsudo cp chromedriver /usr/bin 运⾏程序如果没有报错，说明选择的chromedriver的版本是正确的，如果还报错说明版本没有选对，删除下载⽂件夹中的chromedriver⽂件和 /usr/bin 中的chromedriver，重复上述步骤，选在适合⾃⼰浏览器的chromedriver下载安装","link":"/2018/07/22/Ubuntu安装chrome浏览器和chromedriver/"},{"title":"Ubuntu系统安装MySQL数据库","text":"UBuntu16.04安装MySQL 一.安装MySQl 安装前先更新软件包列表： 12在终端执行如下命令：sudo apt-get update 在Ubuntu16.04上安装MySQL： 12在终端执行如下命令：sudo apt-get install mysql-server mysql-client 在安装过程中需要你输入MySQL管理员用户（root）密码，如下图 如上即代表安装完成 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。","link":"/2018/07/22/Ubuntu系统安装MySQL数据库/"},{"title":"Ubuntu系统搭建配置Python虚拟开发环境","text":"我们知道使用Python的过程中会安装各种库、包，甚至有时候还需要Python2和Python3两种环境混合使用，慢慢的你的Python运行环境会越来越臃肿，这倒还是其次，最可怕的是，有些应用会使用到某个Python包的特定版本，我们知道同一个Python运行环境里面是不能存在同一个包的不同版本的。所有这些都是你为什么要使用Virtualenv的理由。 Virtualenv给你一个干净的Python运行环境，并能让你不同的应用,使用不同版本的包文件提供了可能，甚至使 用它可以让Python2和Python3和谐地共存。对于我们来说，我们用它的原因主要有以下几点： 12341.我们需要一个干净的Python环境，这个环境只针对我目前开发的应用；2.我们不希望多安装一个和项目无关的包，也不希望出现和其它应用有包版本冲突的问题；3.我们还需要生成一个requirements.txt用来告诉其他人我项目的依赖；4.我们不希望使用pyinstaller打包发布的过程中，给我加进来一堆没有用处的文件。 1231.搭建虚拟环境主要是为了保证环境得统一性，对于不同得应用建立专属得python环境，比如针对后台开发得django可以建立一个虚拟环境，针对爬虫开发得应用可以在建立一个虚拟环境，避免环境之间产生冲突。2.可以避免一个环境造成得安装包过的多，导致环境加载缓慢. 搭建寻开发环境详细步骤 首先检查系统是否有安装pip 123456在终端输入如下命令：pip # 查看是否安装有pippip --version# 查看安装的pip版本___________________________________pip3 # 查看是否安装有pippip3 --version # 查看安装的pip3版本 安装pip sudo apt install python-pip 安装pip3 sudo apt install python3-pip 安装 virtualenv 和 virtualenvwrapper 1234567在终端输入如下命令：pip install virtualenvpip install virtualenvwrapper# 如果python2和python3共存，则需要同时安装pip3 install virtualenvpip3 install virtualenvwrapper# virtualenvwrapper是virtualenv的扩展包，可以更⽅便的新增、删除、复制、切换虚 拟环境。 Python2的安装 Python3的安装 找到 virtualenvwrapper.sh 的路径 修改virtualenvwrapper.sh的路径 测试 python3 解释器能否正常导入 virtualenvwrapper 如下图所示即代表成功 配置环境变量 修改 .bashrc 文件（mac电脑是 .bash_profile文件） 将下列内容添加到~/.bashrc 文件中 12345#Setting virtualenv PATH for python3VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source /usr/local/bin/virtualenvwrapper.sh # virtualenvwrapper.sh的路径export WORKON_HOME=&quot;/home/python/workspace&quot; # workspace是盛放虚拟环境的文件夹（根据自己的修改）# export WORKON_HOME=$HOME/.virtualenvs # 盛放虚拟环境的文件夹也可以设置为.virtualenvs 更新环境变量 执行source ~/.bashrc 创建虚拟开发环境 Django虚拟环境 mkvitualenv -p python3 django_py3 AI虚拟环境 如此，虚拟环境即创建成功 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。","link":"/2019/07/22/Ubuntu系统搭建配置Python虚拟开发环境/"},{"title":"Ubuntu纯净卸载软件","text":"如果你关注搜索到这篇文章，那么我可以合理怀疑你被apt-get的几个卸载命令有点搞晕了。 apt-get的卸载相关的命令有remove/purge/autoremove/clean/autoclean等。具体来说： 123apt-get purge / apt-get --purge remove 删除已安装包（不保留配置文件)。 如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文件 12apt-get autoremove 删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。 12apt-get remove 删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。 12apt-get autoclean APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。 12apt-get clean 使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。 那么如何彻底卸载软件呢？具体来说可以运行如下命令： 删除软件及其配置文件1apt-get --purge remove &lt;package&gt; 删除没用的依赖包1apt-get autoremove &lt;package&gt; 此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：1dpkg -l |grep ^rc|awk &apos;{print $2}&apos; |sudo xargs dpkg -P 当然如果要删除暂存的软件安装包，也可以再使用clean命令。","link":"/2018/07/22/Ubuntu纯净卸载软件/"},{"title":"Windows系统安装配置Pycharm","text":"下载Pycharm 使用浏览器打开Pycharm官方网站：http://www.jetbrains.com/pycharm 选择对应的系统安装包，点击DOWNLOAD进行下载(文档以Windows系统举例) 选择Pycharm软件包的安装位置 安装Pycharm 运行Windows Denfender SmartScreen 更改Pycharm默认安装位置 选择自定义Pycharm安装位置 补充说明： 64-bit 表示跟64位操作系统相关(如下图所示) .py 表示关联后缀为.py的Python相关文件 等待安装完成 配置&amp;激活Pycharm 选择主题颜色 激活Pycharm的两种方式 1.选择免费试用30天(如下图所示) 2.破解激活 通过搜索引擎搜索：lanyus 修改Windows系统的hosts文件 hosts文件所在路径：C:\\Windows\\System32\\drivers\\etc 获得’注册码‘ 如此即代表安装安装配置成功 编写并运行你的第一个Python程序 修改程序的默认存放路径 修改完程序存放路径后，需要制定Python解释器 我的安装在C:\\software\\python3.7 找到 C:\\software\\python3.7 下的 python.exe 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。","link":"/2018/05/22/Windows系统安装配置Pycharm/"},{"title":"ubuntu-安装Pycharm，简单粗暴的方法，三行命令行","text":"对于Ubuntu 16.10和Ubuntu 17.04，通过Ctrl + Alt + T打开终端，或通过从应用启动器搜索“terminal”，打开后，执行以下步骤： .通过命令添加PPA存储库：sudo add-apt-repository ppa:mystic-mirage/pycharm 2.如果您安装了以前的版本，请通过软件更新程序升级PyCharm。 运行命令来检查更新并安装IDE（社区版本）sudo apt updatesudo apt install pycharm-professional 或运行命令来检查更新并安装IDE（社区版本）：sudo apt updatesudo apt install pycharm 3.卸载PyCharm：要卸载PyCharm Python IDE，只需运行命令：专业版: sudo apt remove --autoremove pycharm pycharm-professional社区版: sudo apt remove --autoremove pycharm pycharm-community","link":"/2018/07/22/ubuntu-安装pycharm，简单粗暴的方法，三行命令行/"},{"title":"在Deepin系统下安装Anaconda","text":"运行安装Anaconda1bash Anaconda3-4.3.1-Linux-x86_64.sh 安装具体步骤在执行上一步骤之后会出现以下： 123456Welcome to Anaconda3 5.0.1In order to continue the installation process, please review the licenseagreement.Please, press ENTER to continue&gt;&gt;&gt; 按ENTER继续，然后按ENTER读取许可证。读完许可证后，系统会提示您批准许可条款： 1Do you accept the license terms? [yes|no] 选择yes继续安装此时，系统将提示您选择安装的位置。您可以按ENTER接受默认位置，或指定其他位置以进行修改。在这里我选择了其它路径的安装，安装过程需要一些时间 123456789101112131415[/root/anaconda3] &gt;&gt;&gt; /home/wenbin/anaconda3PREFIX=/home/wenbin/anaconda3installing: python-3.6.3-hc9025b9_1 ...Python 3.6.3 :: Anaconda, Inc.installing: ca-certificates-2017.08.26-h1d4fec5_0 ...installing: conda-env-2.6.0-h36134e3_1 ...installing: intel-openmp-2018.0.0-h15fc484_7 ...installing: libgcc-ng-7.2.0-h7cc24e2_2 ...installing: libgfortran-ng-7.2.0-h9f7466a_2 ...installing: libstdcxx-ng-7.2.0-h7a57d05_2 ...installing: bzip2-1.0.6-h0376d23_1 ...installing: expat-2.2.4-hc00ebd1_1 ...installing: gmp-6.1.2-hb3b607b_0 .......................... 完成后，您将收到以下输出： 1234installation finished.Do you wish the installer to prepend the Anaconda3 install locationto PATH in your /root/.bashrc ? [yes|no][no] &gt;&gt;&gt; yes 键入yes ，以便可以使用conda命令。接下来将看到以下输出： 1234567Appending source /home/wenbin/anaconda3/bin/activate to /root/.bashrcA backup will be made to: /root/.bashrc-anaconda3.bakFor this change to become active, you have to open a new terminal.Thank you for installing Anaconda3! 如果你选择了no，那么你就需要手动的将Anaconda3添加的环境变量当中请打开文本编辑器并从主目录打开文件.bashrc或.bash_profile。添加该行。 1export PATH=&quot;/&lt;path to anaconda&gt;/bin:$PATH&quot; 注意：将&lt;path-to-anaconda&gt;替换为安装的anaconda文件的实际路径。保存文件。如果您打开任何终端窗口，请关闭它们，然后打开一个新窗口。您可能需要重新启动计算机才能使PATH更改生效。 为了激活安装，你应该来源~/.bashrc文件： 1source ~/.bashrc 之后你可以验证你的安装通过使用conda命令，例如与list ： 123456789wenbin@wenbin:~$ conda list# packages in environment at /home/wenbin/anaconda3:#_ipyw_jlab_nb_ext_conf 0.1.0 py36he11e457_0 alabaster 0.7.10 py36h306e16b_0 anaconda 5.0.1 py36hd30a520_1 anaconda-client 1.6.5 py36h19c0dcd_0 anaconda-navigator 1.6.9 py36h11ddaaa_0 .............. 设置Anaconda环境查看可用的Python解释器版本： 1conda search &quot;^python$&quot; 使用最新版本的Python 3创建一个环境。我们可以通过将版本3分配给python参数来实现。 我们将调用环境my_python ，但是您可能希望为您的环境使用更具描述性的名称，特别是如果您使用环境来访问多个版本的Python。 1conda create --name my_python python=3 通过一下命令来激活环境 1source activate my_python 通过一下命令添加其他包，比如requests 1conda install --name my_python requests","link":"/2018/06/12/在Deepin系统下安装Anaconda/"},{"title":"种一棵树最好的时间是十年前其次是现在","text":"“随着年龄的增长，你会失去很多东西，你的爱人，你的工作，你的头发，你的视力。 但当你开始学习新东西的时候，不管是编程还是弹钢琴，这些都是一种加分，是一种激励” ——若宫雅子，82岁程序员。","link":"/2018/03/14/种一棵树最好的时间是十年前其次是现在/"},{"title":"安装Ubuntu后要做的事","text":"Ubuntu 16.04安装完成后，还需要做一些配置才能愉快的使用，所以装完系统后还要进行一系列的优化。1.删除libreofficelibreoffice虽然是开源的，但是Java写出来的office执行效率实在不敢恭维，装完系统后果断删掉 sudo apt-get remove libreoffice-common 2.删除Amazon的链接sudo apt-get remove unity-webapps-common 3.删掉基本不用的自带软件（用的时候再装也来得及）123sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-installsudo apt-get remove onboard deja-dup 这样系统就基本上干净了。 4.安装Vim居然默认没有集成Vim神器，只能手动安装了。 sudo apt-get install vim 5.设置时间使用UTCsudo vim /etc/default/rcS 将UTC=no改为UTC=yes 6.安装Chrome通过直接下载安装Google Chrome浏览器deb包。 打开Ubuntu终端，以下为32位版本，使用下面的命令。 wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb 以下为64位版本，使用下面的命令。 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 下载好后 —————————— 32 位安装命令: sudo dpkg -i google-chrome-stable_current_i386.deb 64 位安装命令: sudo dpkg -i google-chrome-stable_current_amd64.deb —————————— 添加 Google Chrome 的PPA 安装Google Chrome浏览器官方PPA，打开终端然后运行下面的命令，下载签名密钥： wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add 然后 12345sudo sh -c &apos;echo &quot;deb http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google-chrome.list&apos;sudo apt-get updatesudo apt-get install google-chrome ———————————————— 安装Google Chrome unstable 版本： sudo apt-get install google-chrome-beta ———————————————— 安装Google Chrome beta 版本： sudo apt-get install google-chrome-unstable 7.安装搜狗输入法123456789vim /etc/apt/sources.list.d/ubuntukylin.list文件，加入ubuntu kylin的apt源deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty main然后sudo apt-get updatesudo apt-get install sogoupinyin 这样就可以apt安装和更新搜狗输入法了。 其实Ubuntu16.04自带的中文输入法挺好用的，特别对于需要经常输入拉丁字符、希腊字符的朋友。不过由于用户习惯，Sougou拼音还是需要安装的 8.安装WPS OfficeMS一直未出Linux版的Office，只能凑合着用WPS了 sudo apt-get install wps-office 9.安装Oracle Java12345sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer 由于系统自带的是OpenJDK，卸载OpenJDK之后会带有残留，导致运行 java -version 时第一行不是java的版本号，会是Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar这个提示，导致很多检测java版本号的脚本会运行出错，因此需要手动清除残留。 sudo rm /usr/share/upstart/sessions/jayatana.conf 删除/usr/share/upstart/sessions/jayatana.conf文件，重启之后再运行java -version就不会再有Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar提示了。 10.安装Sublime Text 312345sudo add-apt-repository ppa:webupd8team/sublime-text-3sudo apt-get updatesudo apt-get install sublime-text 11.安装经典菜单指示器12345sudo add-apt-repository ppa:diesch/testingsudo apt-get updatesudo apt-get install classicmenu-indicator 12.安装系统指示器SysPeek12345sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install syspeek 13.自定义DHCP网络的DNS Server IP地址12345sudo vim /etc/dhcp/dhclient.conf文件，在第21行#prepend domain-name-servers 127.0.0.1;下一行添加如下2行使用aliyun和114的DNSprepend domain-name-servers 114.114.114.114;prepend domain-name-servers 223.5.5.5; 这样可以优先使用aliyun的dns，次要使用114的DNS。 14.安装git和vpncgit和vpn大家都懂的，程序员的好工具。 sudo apt-get install vpnc git 15.安装axelaxel是Linux命令行界面的多线程下载工具，比wget的好处就是可以指定多个线程同时在命令行终端里下载文件。 sudo apt-get install axel 安装之后，就可以代替wget用多线程下载了。 16.安装openssh-serversudo apt-get install openssh-server 安装之后，就可以在Win下用ssh工具远程登陆了，当然也多了一个安全隐患，如果不想远程登陆本机的话，可以不装openssh-server。 17.安装CMake和Qt CreatorCMake和Qt Creator是Linux下开发C++程序的神器，Ubuntu 17.10已经集成了最新版的Qt Creator （4.4.1）。 sudo apt-get install cmake qtcreator 18.安装ExFat文件系统驱动Ubuntu默认不支持exFat文件系统的挂载，需要手动安装exfat的支持 sudo apt-get install exfat-fuse 装上exfat-fuse之后就可以挂载exfat分区的磁盘了。 19.安装lnavlnav工具是在终端界面看日志的神器 sudo apt-get install lnav 装上之后在终端里就可以用lnav彩色显示日志了。 20.安装unrar系统默认不带解压缩rar文件的功能，手动安装unrar程序 sudo apt-get install unrar 装上之后就可以用命令解压缩rar文件了。 使用如下命令解压缩文件到当前目录。 unrar x test.rar","link":"/2018/06/22/安装Ubuntu后要做的事/"},{"title":"安装谷歌拼音","text":"linux下面的中文输入法一直不给力，Ubuntu里正常使用的搜狗输入法经常突然无法输出中文（具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示）虽然用惯了搜狗输入法但是实在忍不了啦，于是痛定思痛果断换掉。 现在,google拼音输入法可以用了！ 这得感谢下面这个项目： libgooglepinyin ( A fork from google pinyin on android) 项目地址：http://code.google.com/p/libgooglepinyin/ 安装之后记录了下来，希望能为同样遇到输入法问题的人提供参考 一、1sudo apt-get install fcitx-googlepinyin 二、 在settings-&gt;Language Support里将keyboard input method system设置为fcitx 三 、注销系统，再登录 在settings-&gt;Text Entry里，添加输入源，搜索google-pinyin添加即可。","link":"/2018/06/22/安装谷歌拼音/"},{"title":"Python中的垃圾回收机制","text":"1、小整数对象池在程序中整数的使用非常的广泛，Python为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存的空间。Python中对象小整数的定义是[-5,256]，这些整数的对象是提前建立好的，不会被垃圾回收。在一个Python的程序中，所有位于这个范围内的整数使用的都是同一个对象。 1234567891011121314151617181920212223242526272829In [1]: a = -5In [2]: id(a)Out[2]: 10911520In [3]: b = -5In [4]: id(b)Out[4]: 10911520In [5]: c = 256In [6]: id(c)Out[6]: 10919872In [7]: d = 256In [8]: id(d)Out[8]: 10919872In [9]: e = 257In [10]: id(e)Out[10]: 139826489334128In [11]: f = -6In [12]: id(f)Out[12]: 139826489334064 ​ 上面中，我们可以看到范围在[-5,256]之间的整数，包含-5和256，对象在内存中的地址是相同的，同理，单个字母也是这样。 ​ 但是当定义两个相同的字符串时，引用计数为0,那么就会触发垃圾回收。 2、大整数对象池每一个大整数，均创建一个新的对象。 123456789In [14]: a = 1234In [15]: id(a)Out[15]: 139826489334576In [16]: b = 1234In [17]: id(b)Out[17]: 139826489334640 3、intern机制假如有好多个对象： 12345678a1 = \"HelloWorld\"a2 = \"HelloWorld\"a3 = \"HelloWorld\"a4 = \"HelloWorld\"a5 = \"HelloWorld\"a6 = \"HelloWorld\"a7 = \"HelloWorld\"a8 = \"HelloWorld\" python会不会创建8个对象呢？会不会在内存中开辟8个内存 空间？答案是不会的，想一下，如果我们写10000个对象，像上面那样，那岂不是会在内存中开辟10000个空间，那得占用多少的内存。所以在Python中有这样的一个机制—-&gt;intern机制， 让他只占用一个“HelloWorld”所占的空间，靠引用计数去维护何时释放。 123456789101112131415161718192021In [19]: a = 'abcd'In [20]: id(a)Out[20]: 139826471344368In [21]: b = 'abcd'In [22]: id(b)Out[22]: 139826471344368In [23]: c = bIn [24]: id(c)Out[24]: 139826471344368In [25]: del aIn [26]: del bIn [27]: id(c)Out[27]: 139826471344368 总结 小整数[-5,256]共用内存，常驻内存。 单个字符公用内存，常驻内存 单个单词，不可修改，默认开启intern机制，公用内存，引用计数为0，则销毁 字符串(含有空格)，不可修改，没开启intern机制，不共用对象，引用计数为0，销毁 12345678910111213141516171819In [30]: a = 'hello world'In [31]: b = 'hello world'In [32]: id(a)Out[32]: 139826489193264In [33]: id(b)Out[33]: 139826489192816In [34]: c = 'helloworld'In [35]: d = 'helloworld'In [36]: id(c)Out[36]: 139826486896048In [37]: id(d)Out[37]: 139826486896048 大整数不共用内存，引用计数为0，销毁 数值类型和字符串类型在Python中都是不可变的数据类型，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建了一个新的对象。 12345678910111213141516171819In [39]: a = 110 In [40]: id(a) Out[40]: 10915200 In [41]: a += 1 In [42]: id(a) Out[42]: 10915232 In [43]: b = 'hello' In [44]: id(b) Out[44]: 139826471345768 In [45]: b = 'world' In [46]: id(b) Out[46]: 139826471344368 4、Garbage collection(GC垃圾回收)python采用的是引用计数机制为主，分代收集机制为辅的策略 当引用计数为0时，该对象的生命就结束了 引用计数机制的优点： 简单 实时性：一旦没有引用，即引用计数为0，内存就直接释放了。不用像其他机制等到特定的时机，实时性还带来一个好处：处理回收内存的时间分摊到了平时 引用计数机制的缺点： 维护引用计数消耗资源 循环引用 1234list1 = []list2 = []list1.append(list2)list2.append(list1) list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。(分代收集) GC系统所承担的工作远比”垃圾回收”多得多。实际上，它们负责三个重要任务： 为新生成的对象分配内存 识别哪些垃圾对象 从垃圾对象那回收内存 5、垃圾回收机制 1、导致引用计数+1的情况 对象被创建，如：a = 10 对象被引用，如：b = a 对象被作为参数，传递到一个函数中，如：func(a) 对象作为一个元素，存储在容器中，如：list = [a, a] 2、导致引用计数-1的情况： 对象的别名被显示销毁，如：del a 对象的别名被赋予新的对象，如：a = 20 一个对象离开他的作用域， 如函数f执行完毕时，func函数中的局部变量(全局变量不会) 对象所在的容器被销毁，或从容器中删除对象 3、查看一个对象的引用计数 123import sysa = \"hello world\"sys.getrefcount(a) 可以查看a对象的应用计数，但是比正常计数大1，因为在调用函数的时候传入a，这会让a的引用计数+1 6、循环引用导致内存泄露​ 内存泄露： ​ 申请了某些内存，但是忘记了释放，那么这就造成了内存的浪费，久而久之内存就不够用了. 12345678910111213141516171819import gcclass ClassA(): def __init__(self): print('object born,id:%s'%str(id(self)))def f2(): while True: c1 = ClassA() c2 = ClassA() c1.t = c2 c2.t = c1 del c1 del c2#python默认是开启垃圾回收的，可以通过下面代码来将其关闭gc.disable()f2() ​ 执行f2()，进程占用的内存会不断增大。 创建了c1，c2后这两块内存的引用计数都是1，执行c1.t=c2和c2.t=c1后，这两块内存的引用计数变成2. 在del c1后，引用计数变为1，由于不是为0，所以c1对象不会被销毁;同理，c2对象的引用数也是1。 python默认是开启垃圾回收功能的，但是由于以上程序已经将其关闭，因此导致垃圾回收器都不会回收它们，所以就会导致内存泄露。 7、垃圾回收123456789101112131415161718class ClassA(): def __init__(self): print('object born,id:%s'%str(id(self)))def f2(): while True: c1 = ClassA() c2 = ClassA() c1.t = c2 c2.t = c1 del c1 del c2 gc.collect()#手动调用垃圾回收功能，这样在自动垃圾回收被关闭的情况下，也会进行回收#python默认是开启垃圾回收的，可以通过下面代码来将其关闭gc.disable()f2() ​ 有三种情况会触发垃圾回收 当gc模块的计数器达到阀值的时候，自动回收垃圾 调用gc.collect()，手动回收垃圾 程序退出的时候，python解释器来回收垃圾 8、gc模块的自动垃圾回收触发机制在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。 gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取。 例如(488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。例如： 12345print gc.get_count() # (590, 8, 0)a = ClassA()print gc.get_count() # (591, 8, 0)del aprint gc.get_count() # (590, 8, 0) 3是指距离上一次二代垃圾检查，一代垃圾检查的次数，同理，0是指距离上一次三代垃圾检查，二代垃圾检查的次数。 gc模快有一个自动垃圾回收的阀值，即通过gc.get_threshold函数获取到的长度为3的元组，例如(700,10,10)，每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器。 例如，假设阀值是(700,10,10)： 1234&gt; 当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)&gt; 当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)&gt; 当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)&gt;","link":"/2019/07/14/2017-11-17-垃圾回收/"},{"title":"函数程序设计实验六：字符放大","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463module MyPicture whereimport Data.Charimport Data.Listimport Text.Printfsayit::String-&gt;IO()sayit s=putStr(say s)say::String-&gt;Stringsay s=unlines(says s)getid::Char-&gt;Intgetid c= if oc&gt;=97 then (oc-97+10) else if oc&gt;=65 then (oc-65+10) else (oc-48) where oc=ord csays::String-&gt;[String]says []=[]says (x:xs)=merge (alphabet!!(getid x)) (says xs)merge::[String]-&gt;[String]-&gt;[String]merge [] x=xmerge x []=xmerge (x:xs) (y:ys)=(x++y):(merge xs ys)alphabet= [[ \" #### \", \" ## ## \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" # \", \" ## \", \" ### \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \" ],[ \" #### \", \" # ## \", \" ## ## \", \" # ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" # \", \" # \", \" ###### \" ],[ \" #### \", \" ## # \", \" # ## \", \" ## \", \" # \", \" ### \", \" ## \", \" # \", \" # ## \", \" ## ## \", \" #### \" ],[ \" ## \", \" ## \", \" ### \", \" # # \", \" # # \", \" ## # \", \" # # \", \" ###### \", \" # \", \" # \", \" # \" ],[ \" ###### \", \" ## \", \" # \", \" ##### \", \" ## ## \", \" ## \", \" # \", \" # \", \" # ## \", \" ## # \", \" ### \" ],[ \" ### \", \" # ## \", \" ## # \", \" ## \", \" # ### \", \" ## ## \", \" ## # \", \" # # \", \" ## # \", \" # ## \", \" ### \" ],[ \" ###### \", \" ## \", \" # \", \" # \", \" # \", \" ## \", \" # \", \" # \", \" ## \", \" # \", \" # \" ],[ \" ### \", \" ## # \", \" # ## \", \" # ## \", \" ## # \", \" #### \", \" ## ## \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" ### \", \" ## # \", \" # ## \", \" # ## \", \" # ## \", \" ## ## \", \" ##### \", \" ## \", \" # ## \", \" ## # \", \" ### \" ],[ \" ## \", \" ## \", \" ## \", \" #### \", \" # # \", \" # # \", \" # # \", \" ###### \", \" # # \", \" # # \", \"## ##\" ],[ \" ##### \", \" # ## \", \" # # \", \" # # \", \" # ## \", \" ##### \", \" # ## \", \" # # \", \" # # \", \" # ## \", \" ##### \" ],[ \" ### \", \" # ## \", \" ## # \", \" # # \", \" # \", \" # \", \" # \", \" # # \", \" # # \", \" # ## \", \" ### \" ],[ \" #### \", \" # # \", \" # ## \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # ## \", \" # # \", \" #### \" ],[ \" ###### \", \" # \", \" # \", \" # \", \" # \", \" ###### \", \" # \", \" # \", \" # \", \" # \", \" ###### \" ],[ \" ###### \", \" # \", \" # \", \" # \", \" # \", \" ##### \", \" # \", \" # \", \" # \", \" # \", \" # \" ],[ \" ### \", \" # ## \", \" # # \", \" # # \", \" # \", \" # ### \", \" # # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" ###### \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \" ],[ \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \" ],[ \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" # ## \", \" # # \", \" # ## \", \" # ## \", \" ### \", \" #### \", \" # # \", \" # ## \", \" # # \", \" # ## \", \" # # \" ],[ \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" ###### \" ],[ \" ## ## \", \" ## ## \", \" ## ## \", \" ## ## \", \" ## ## \", \" ###### \", \" # ## # \", \" # ## # \", \" # ## # \", \" # ## # \", \" # ## # \" ],[ \" # # \", \" ## # \", \" ## # \", \" ### # \", \" # # # \", \" # # # \", \" # # # \", \" # # # \", \" # ## \", \" # ## \", \" # ## \" ],[ \" #### \", \" ## ## \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" ##### \", \" # ## \", \" # # \", \" # # \", \" # # \", \" # ## \", \" ##### \", \" # \", \" # \", \" # \", \" # \" ],[ \" #### \", \" ## ## \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # ### \", \" # ### \", \" ## ## \", \" ##### \" ],[ \" ##### \", \" # ## \", \" # # \", \" # # \", \" # ## \", \" ##### \", \" # # \", \" # ## \", \" # # \", \" # ## \", \" # # \" ],[ \" #### \", \" ## ## \", \" # # \", \" # \", \" # \", \" ## \", \" ## \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" ###### \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \" ],[ \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \"## ##\", \" # # \", \" # # \", \" ## ## \", \" ## # \", \" # # \", \" # ## \", \" #### \", \" ## \", \" ## \", \" ## \" ],[ \"## ## ##\", \"## ## ##\", \"## ## # \", \" # ## # \", \" # ## # \", \" ## ### \", \" ## ## \", \" ## ## \", \" ## ## \", \" ## ## \", \" ## # \" ],[ \" # # \", \" ## # \", \" # # \", \" ### \", \" ## \", \" ## \", \" ## \", \" # ## \", \" # # \", \" ## ## \", \" # # \" ],[ \" # # \", \" # # \", \" # # \", \" # # \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \" ],[ \" ###### \", \" ## \", \" # \", \" ## \", \" # \", \" ## \", \" # \", \" # \", \" ## \", \" # \", \" ###### \" ]]","link":"/2018/11/08/2018-11-08-字符放大/"},{"title":"数学分析","text":"增长趋势$n\\to+\\infty,\\forall p,q&gt;0,a&gt;1,{(\\ln n)}^q\\ll n^p\\ll a^n\\ll n!\\ll n^n$ 积分表反读可得导数表，此处略。 $\\int k,\\mathrm{d}x=kx+C$ $\\int x^a,dx=\\frac{x^{a+1}}{a+1}+C$ $\\int\\frac{1}{x},dx=\\ln\\mid x\\mid +C$ $\\int e^x,dx=e^x + C$ $\\int a^x,dx=\\frac{a^x}{\\ln a}+C$ $\\int\\cos x,dx=\\sin x+C$ $\\int\\sin x,dx=-\\cos x+C$ $\\int\\frac{1}{cos^2x},dx=\\int\\sec^2 x,dx=\\tan x+C$ $\\int\\frac{1}{sin^2x},dx=\\int\\csc^2 x,dx=-\\cot x+C$ $\\int\\frac{1}{\\sqrt{1-x^2}},dx=\\arcsin x+C=-\\arccos x+C$ $\\int\\frac{1}{1+x^2},dx=\\arctan x+C=-arccot,x+C$ $\\int\\sec x\\tan x,dx=\\sec x+C$ $\\int\\csc x\\cot x,dx=-\\csc x+C$ $\\int\\tan x,dx=-\\ln\\mid \\cos x\\mid +C$ $\\int\\cot x,dx=\\ln\\mid \\sin x\\mid +C$ $\\int\\sec x,dx=\\ln\\mid \\sec x+\\tan x\\mid +C$ $\\int\\csc x,dx=\\ln\\mid \\csc x-\\cot x\\mid +C$ $\\int sh,x,dx=ch,x+C$ $\\int ch,x,dx=sh,x+C$ $\\int\\frac{1}{x^2+a^2},dx=\\frac{1}{a}\\arctan\\frac{x}{a}+C$ $\\int\\frac{1}{x^2-a^2},dx=\\frac{1}{2a}\\ln\\mid \\frac{x-a}{x+a}\\mid +C$ $\\int\\frac{1}{\\sqrt{a^2-x^2}},dx=\\arcsin\\frac{x}{a}+C$ $\\int\\frac{1}{\\sqrt{x^2-a^2}},dx=\\ln\\mid x+\\sqrt{x^2-a^2}\\mid +C$ $\\int\\frac{1}{\\sqrt{x^2+a^2}},dx=\\ln\\mid x+\\sqrt{x^2+a^2}\\mid +C$ 积分求几何量弧长若简单闭曲线 $\\begin{cases}x=x(t),\\ y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$ 端点处重合（$x(\\alpha)=x(\\beta),y(\\alpha)=y(\\beta)$）且其他地方不自交，$x(t),y(t)$连续且满足 $[x’(t)]^2+[y’(t)]^2\\ne0,\\forall t\\in[\\alpha,\\beta]$ 此时称曲线光滑，其长度 $s=\\int_\\alpha^\\beta\\sqrt{[x’(t)]^2+[y’(t)]^2},dt$ 此式可对称推广到高维空间曲线。极坐标下， $r=r(\\theta),\\theta\\in[\\alpha,\\beta]$ 的长度为 $s=\\int_\\alpha^\\beta\\sqrt{[r(\\theta)]^2+[r’(\\theta)]^2},d\\theta$ 面积若简单闭曲线 $\\begin{cases}x=x(t),\\ y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$ 端点处连续（$x(\\alpha)=x(\\beta),y(\\alpha)=y(\\beta)$）且其他地方不自交，$x(t),y(t)$都逐段有连续微商，则此闭合曲线围起来的有界区域面积 $S=-\\int_\\alpha^\\beta x’(t)y(t),dt=-\\int_\\alpha^\\beta y(t),dx(t)=-\\oint_\\Gamma y,dx=\\oint_\\Gamma x,dy$ 等式右边称为曲线$\\Gamma$上的积分，其计算方法是带入参数方程到定积分计算式中，积分上下限为始点与终点对应的参数值。下限并不总是小于上限，参数从下限到上限变化时对应曲线的正向（沿正向观察时，曲线所围的区域永远在左侧）。极坐标下，连续非负曲线$r=r(\\theta)$与向径$\\theta=\\alpha,\\theta=\\beta$，其中 $0\\leq\\beta-\\alpha\\leq2\\pi$所围成的平面图形面积$S=\\frac{1}{2}\\int_\\alpha^\\beta r^2(\\theta),d\\theta$ 体积记立体过x点且垂直于x轴的截面面积为$S(x)$，则其体积$V=\\int_a^bS(x),dx$连续曲线$y=f(x)\\ge 0,x\\in[a,b]$绕x轴旋转一周产生的旋转体体积$V=\\pi\\int_a^by^2,dx$ 旋转体侧面积若曲线由参数方程 $\\begin{cases}x=x(t),\\ y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$ 给出，则其绕x轴旋转体的侧面积 $s=2\\pi\\int_\\alpha^\\beta y(t)\\sqrt{[x’(t)]^2+[y’(t)]^2},dt$ 方向导数设三元函数$u=f(x,y,z)$在点$P_0(x_0,y_0,z_0)$的某邻域内有定义，任意给定始于点$P_0$的射线$l$，$P(x,y,z)$为l上且含于定义域内的点。若极限 $\\lim_{r(p,p_0)\\to0^+}\\frac{f(P)-f(P_0)}{r(P,P_0)}=\\lim_{r(p,p_0)\\to0^+}\\frac{\\Delta_lf(P_0)}{r(P,P_0)}$ 存在，则称该极限值为函数$f$在点$P_0$沿方向$l$的方向导数，记为$\\frac{\\partial f}{\\partial l}\\mid _{P_0}$或$\\frac{\\partial f(P_0)}{\\partial l}$，$\\frac{\\Delta_lf(P_0)}{r(P,P_0)}$称为函数在$P_0$点沿$l$方向的增量。 特别地，$\\frac{\\partial f(P_0)}{\\partial x}$就是函数在$P_0$点沿$x$轴正向的方向导数，$y,z$轴上的方向导数同理。若函数在$P_0$点可微，则其在$P_0$沿任何方向$l$的方向导数都存在，则有以下公式 $\\frac{\\partial f(P_0)}{\\partial l}=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z})\\mid _{P_0}\\cdot\\vec{l_0}$ 其中$\\vec{l_0}=(\\cos\\alpha,\\cos\\beta,cos\\gamma)=\\frac{1}{\\rho}(\\Delta x,\\Delta y,\\Delta z)$为$l$的方向余弦。 曲率若曲线由参数方程 $\\begin{cases}x=x(t),\\ y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$ 给出且有二阶微商，则其在一点的曲率 $K=\\frac{\\mid y’’x’-y’x’’\\mid }{[x’^2+y’^2]^{\\frac{3}{2}}}$ 若$y=f(x)$，则 $K=\\frac{\\mid y’’\\mid }{(1+y’^2)^\\frac{3}{2}}$ 同时记$\\frac{1}{K}$为曲率半径。 空间曲线的切线与法平面若已知曲线上一点$P(x_0,y_0,z_0)$处的切向量为$\\tau(x_0,y_0,z_0)=(A,B,C)$则曲线在该点的切线方程为 $\\frac{x-x_0}A=\\frac{y-y_0}B=\\frac{z-z_0}C$ 法平面方程为 $A(x-x_0)+B(y-y_0)+C(z-z_0)=0$ 当曲线由参数方程 $\\begin{cases}x=x(t),\\ y=y(t),\\ z=z(t),\\end{cases}t\\in[\\alpha,\\beta]$ 给出时，曲线在P点的切向量为 $\\tau=\\pm(x’(t_0),y’(t_0),z’(t_0))$ 更一般地，若曲线用两曲面的交线给出 $\\begin{cases}F(x,y,z)=0,\\ G(x,y,z)=0,\\end{cases}$ 且在P点的某邻域能确定函数组$y=y(x),z=z(x)$满足$y_0=y(x_0),z_0=z(x_0)$，且$y’(x),z’(x)$存在，则曲线在P点的切向量 $\\tau=\\pm(\\frac{\\partial(F,G)}{\\partial(y,z)},\\frac{\\partial(F,G)}{\\partial(z,x)},\\frac{\\partial(F,G)}{\\partial(x,y)})$ 空间曲面的切平面与法线若已知曲面上一点$P(x_0,y_0,z_0)$处的切平面的法向量为$\\vec n=(A’,B’,C’)$则曲线在该点的法线方程为 $\\frac{x-x_0}{A’}=\\frac{y-y_0}{B’}=\\frac{z-z_0}{C’}$ 切平面方程为 $A’(x-x_0)+B’(y-y_0)+C’(z-z_0)=0$ 当曲面方程为$\\pi:F(x,y,z)=0$在曲面上任取一条过P的曲线，设其方程为 $\\begin{cases}x=x(t),\\ y=y(t),\\ z=z(t),\\end{cases}t\\in[\\alpha,\\beta]$ 此时有$F(x(t),y(t),z(t))=0$令$t=t_0$两边对t求导，并写成向量的内积式，得 $(F_x,F_y,F_z)_P\\cdot(x’(t_0),y’(t_0),z’(t_0))=0$ 则曲线在P点的法向量为$\\vec{n}=\\pm(F_x,F_y,F_z)_P$ 若曲线由参数方程给出 $\\begin{cases}x=x(u,v),\\ y=y(u,v),\\ z=z(u,v),\\end{cases}$ 则曲线在P点的法向量 $\\vec{n}=\\pm(\\frac{\\partial(y,z)}{\\partial(u,v)},\\frac{\\partial(z,x)}{\\partial(u,v)},\\frac{\\partial(x,y)}{\\partial(u,v)})$ 高阶导数与泰勒公式用$f^{(n)}(x)$表示f(x)的n阶导数，只要让余项&lt;EPS即可计算指定函数到任意精确度，特别取a=0时称为麦克劳林公式。 $f(x)=f(a)+f^{(1)}(a)(x-a)+\\frac{f^{(2)}(a)}{2!}(x-a)^2+\\ldots+\\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)$ $R_n(x)=o((x-a)^n)$，佩亚诺余项 $R_n(x)=\\frac{1}{n!}\\int_a^x(x-t)^nf^{(n+1)}(t),dt$，积分余项 $R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-a)^{n+1},a&lt;\\xi&lt;x$，拉格朗日余项 $R_n(x)=\\frac{(x-a)^{n+1}}{n!}(1-\\theta)^nf^{(n+1)}(a+\\theta(x-a)),0&lt;\\theta&lt;1$，柯西余项 对数函数$[\\ln(1+x)]^{(n)}=(-1)^{n-1}(n-1)!(1+x)^{-n}$ $\\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+\\ldots+(-1)^{n-1}\\frac{x^n}{n}+R_n(x)$ 幂函数$[(1+x)^a]^{(n)}=a(a-1)\\ldots(a-n+1)(1+x)^{a-n}$ $(1+x)^a=1+ax+\\frac{a(a-1)}{2!}x^2+\\dots+\\frac{a(a-1)\\ldots(a-n+1)}{n!}x^n+R_n(x)$ 三角函数$(\\sin x)^{(n)}=\\sin(x+\\frac{n\\pi}{2})$ $\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\ldots+(-1)^{k-1}\\frac{x^{2k-1}}{(2k-1)!}+R_{2k}(x)$ $R_{2k}(x)=(-1)^k\\frac{\\cos\\theta x}{(2k+1)!}x^{2k+1}$ $(\\cos x)^{(n)}=\\cos(x+\\frac{n\\pi}{2})$ $\\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\ldots+(-1)^{k-1}\\frac{x^{2k-2}}{(2k-2)!}+R_{2k-1}(x)$ $R_{2k-1}(x)=(-1)^k\\frac{\\cos\\theta x}{(2k)!}x^{2k}$ 指数函数$(e^x)^{(n)}=e^x$ $e^x=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\ldots+\\frac{x^n}{n!}+R_n(x)$ $R_n(x)=\\frac{e^{\\theta x}}{(n+1)!}x^{n+1},\\xi=\\theta x,0&lt;\\theta&lt;1$ 二元函数设$f(x,y)$在$P_0(x_0,y_0)$的某邻域$O(P_0)$内有直到$n+1$阶连续偏导数，则对$O(P_0)$内$\\forall(x_0+\\Delta x,y_0+\\Delta y),\\exists\\theta\\in(0,1)$，使得 $f(x_0+\\Delta x,y_0+\\Delta y)=\\sum_{k=0}^n\\frac{1}{k!}(\\frac{\\partial}{\\partial x}\\Delta x+\\frac{\\partial}{\\partial y}\\Delta y)^kf(x_0,y_0)+R_n$ 其中 $R_n=\\frac{1}{(n+1)!}(\\frac{\\partial}{\\partial x}\\Delta x+\\frac{\\partial}{\\partial y}\\Delta y)^{n+1}f(x_0+\\theta\\Delta x,y_0+\\theta\\Delta y)$ 级数部分和幂级数快速计算幂级数的部分和$\\sum_{i=1}^ni^k\\mod M$可借助伯努利数，详见组合数学模板。 $\\sum_{i=1}^ni^1=\\frac 1 2n(n+1)$ $\\sum_{i=1}^ni^2=\\frac 1 6n(n+1)(2n+1)$ $\\sum_{i=1}^ni^3=\\frac 1 4[n(n+1)]^2$ $\\sum_{i=1}^ni^4=\\frac 1{30}n(n+1)(2n+1)(3n^2+3n-1)$ $\\sum_{i=1}^ni^5=\\frac 1{12}[n(n+1)]^2(2n^2+2n-1)$ $\\sum_{i=1}^ni^6=\\frac 1{42}n(n+1)(2n+1)(3n^4+6n^3-3n+1)$ 调和级数$n\\to\\infty,\\sum_{i=1}^n\\frac 1 i\\to\\ln n+r,r\\approx0.5772156649015328\\ldots$ 二分求零点、三分求极值点需要$f(x)$在区间$[l,r]$上单调/凹凸性唯一。 1234567891011121314lf bs(lf l, lf r, lf f(lf x)){ if (r - l &lt; EPS) return l; lf m = (l + r) / 2; return sgn(f(l) * f(m)) &lt; 0 ? bs(l, m, f) : ts(m, r, f);}lf ts(lf l, lf r, lf f(lf x)){ if (r - l &lt; EPS) return l; lf d = (r - l) / 3, lm = l + d, rm = r - d; return f(lm) &lt; f(rm) ? ts(l, rm, f) : ts(lm, r, f); //极小值} 自适应辛普森求积分使用示例 这篇论文论证了加一个十五分之一的偏移收敛会比较快… 123456789101112struct Simpson{ lf simpson(lf a, lf b, lf f(lf x)) { return (f(a) + 4 * f((a + b) / 2) + f(b)) * (b - a) / 6; } lf ask(lf a, lf b, lf f(lf x), lf e = EPS) { lf c = (a + b) / 2, L = simpson(a, c, f), R = simpson(c, b, f), delta = (L + R - simpson(a, b, f)) / 15; return fabs(delta) &lt; e ? L + R + delta : ask(a, c, f, e / 2) + ask(c, b, f, e / 2); }}; 插值法拉格朗日插值法：插值多项式和插值基函数的形式对称，容易编程。但是，增加节点时，需要重新计算每一个插值基函数。要在$\\pmod p$意义下进行的话，那么p只能是质数。牛顿插值法：当插值节点增加时，之前已计算的结果仍然能用，每增加一个节点，只要再增加一项即可，从而避免了重复性计算。如果要mod非质数的话，那么就要用牛顿插值法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061typedef complex&lt;lf&gt; Coord;#define X real()#define Y imag()struct Lagrange{ lf ask(const vector&lt;Coord&gt; &amp;p, lf x) //返回p确定的多项式函数在x处的值 { lf ret = 0; for (int i = 0; i &lt; p.size(); ++i) { lf tmp = p[i].Y; for (int j = 0; j &lt; p.size(); ++j) if (i != j) tmp *= (x - p[j].X) / (p[i].X - p[j].X); ret += tmp; } return ret; } vector&lt;lf&gt; ask(vector&lt;Coord&gt; p) //返回p确定的多项式系数向量 { vector&lt;lf&gt; ret(p.size()), sum(p.size()); ret[0] = p[0].Y, sum[0] = 1; for (int i = 1; i &lt; p.size(); ++i) { for (int j = p.size() - 1; j &gt;= i; --j) p[j].Y = (p[j].Y - p[j - 1].Y) / (p[j].X - p[j - i].X); for (int j = i; ~j; --j) sum[j] = (j ? sum[j - 1] : 0) - sum[j] * p[i - 1].X, ret[j] += sum[j] * p[i].Y; } return ret; }};struct Newton{ lf differenceQuotient(const vector&lt;Coord&gt; &amp;p, int k) //计算差商 { lf ret = 0; for (int i = 0; i &lt;= k; ++i) { lf tmp = p[i].Y; for (int j = 0; j &lt;= k; ++j) if (i != j) tmp /= p[i].X - p[j].X; ret += tmp; } return ret; } lf ask(const vector&lt;Coord&gt; &amp;p, lf x) { lf ret = p[0].Y; for (int i = 1; i &lt; p.size(); ++i) { lf tmp = differenceQuotient(p, i); //多次求，可O(n^3)预处理优化 for (int j = 0; j &lt; i; ++j) tmp *= x - p[j].X; ret += tmp; } return ret; }};","link":"/2019/02/03/2019-02-03-数学分析/"},{"title":"数论","text":"辗转相除法123456789ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; } //a、b的最大公约数ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } //a、b的最小公倍数ll gcd(ll a, ll b, ll &amp;x, ll &amp;y) //扩展欧几里得，引用返回a*x+b*y=gcd(a,b)绝对值之和最小的解{ if (!a) return x = 0, y = 1, b; ll d = gcd(b % a, a, y, x); return x -= b / a * y, d;} 裴蜀定理对任何$a,b\\in Z$和它们的最大公约数$d$，关于未知数$x,y$的线性不定方程（称为裴蜀等式）：$ax+by=c$当仅当$d|c$，可知有无穷多解。特别地，$ax+by=d$一定有解。 推论$a,b$互质的充要条件是$ax+by=1$有整数解。 同余系运算求乘法逆元的另外一种方法是用欧拉定理$x^{\\phi(m)}\\equiv1\\pmod m$，x的逆是$x^{\\phi(m)-1}$。特别地，m为素数时$\\phi(m)=m-1$，此时x的逆就是pow(x,m-2,m)。 log函数：m为素数时求解模方程$a^x\\equiv b\\pmod m$。设P为质数，G为P的原根，则$x^y\\equiv b\\pmod P$等价于$y\\ ind\\ x\\equiv b\\pmod{P-1}$，其中$G\\ ind\\ x\\equiv x\\pmod P$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct Mod{ const ll M; Mod(ll M) : M(M) {} ll add(ll a, ll b) const { return ((a + b) % M + M) % M; } ll sub(ll a, ll b) const { return add(a, M - b); } ll mul(ll a, ll b) const { return a * b % M; } /*//根据a*b是否爆ll替换a*b%m ll mul(ll a, ll b) const { ll r = 0; for (a %= M; b; b &gt;&gt;= 1, a = add(a, a)) if (b &amp; 1) r = add(r, a); return r; } */ ll pow(ll a, ll b) const { ll r = 1; for (a %= M; b; b &gt;&gt;= 1, a = mul(a, a)) if (b &amp; 1) r = mul(r, a); return r; } ll inv(ll a) const { return pow(a, M - 2); } //return pow(a, phi(m) - 1, m); /*//模m下a的乘法逆元，不存在返回-1（m为素数时a不为0必有逆元） ll inv(ll a) const { ll x, y, d = gcd(a, m, x, y); return d == 1 ? (x + m) % m : -1; } */ ll div(ll a, ll b) const { return mul(a, inv(b)); } ll log(ll a, ll b) const { ll n = ceil(sqrt(M + 0.5)); map&lt;ll, ll&gt; x; for (ll i = 0, e = 1; i &lt; n; e = mul(e, a), ++i) if (!x.count(e)) x[e] = i; for (ll i = 0, v = inv(pow(a, n)); i &lt; n; ++i, b = mul(b, v)) if (x.count(b)) return i * n + x[b]; return -1; } vector&lt;ll&gt; sol(ll a, ll b) //解同余方程，返回ax=b(mod M)循环节内所有解 { vector&lt;ll&gt; ans; ll x, y, d = gcd(a, M, x, y); if (b % d) return ans; ans.push_back((b / d) % (M / d) * (x = (x % M + M) % M)); for (int i = 1; i &lt; d; ++i) ans.push_back((ans[0] + i * M / d) % M); return ans; }}; 中国剩余定理解同余方程组使用示例 1234567891011ll crt(const vector&lt;pair&lt;ll, ll&gt;&gt; &amp;v) //同余方程组，x%v[i].first==v[i].second，不存在返回-1{ ll m = v[0].first, r = v[0].second, c, d, x, y, z; for (int i = 1; i &lt; v.size(); ++i) { if (c = v[i].second - r, d = gcd(m, v[i].first, x, y), c % d) return -1; gcd(m / d, z = v[i].first / d, x, y), r += c / d * x % z * m, r %= m *= z; } return r &lt; 0 ? r + m : r;} 欧拉筛欧拉函数$\\phi(n)$是小于n的正整数中与n互素的数的数目。特别地，规定$\\phi(1)=1$，易知n&gt;2时都为偶数。 欧拉函数是积性函数，即对任意素数$p,q$满足下列关系：$\\phi(pq)=\\phi(p)\\phi(q)=(p-1)(q-1)$对任何两个互质的正整数$x, m(m\\geq2)$有欧拉定理：$x^{\\phi(m)}\\equiv1\\pmod m$当m为素数p时，此式变为费马小定理：$x^{p-1}\\equiv1\\pmod p$利用欧拉函数和它本身不同质因数的关系，用筛法$O(N)$预处理某个范围内所有数的欧拉函数值，并求出素数表。同时，利用计算欧拉函数过程中求出的最小素因子m，可以实现$O(log N)$的素因数分解。 同时求莫比乌斯函数$\\mu(n)$，存在mu中。 123456789101112131415161718192021222324struct EulerSieve{ vector&lt;int&gt; p, m, phi, mu; //素数序列，最小素因子，欧拉函数，莫比乌斯函数 EulerSieve(int N) : m(N, 0), phi(N, 0), mu(N, 0) { phi[1] = mu[1] = 1; //m[1]=0,m[i]==i可判断i是素数 for (long long i = 2, k; i &lt; N; ++i) //防i*p[j]爆int { if (!m[i]) p.push_back(m[i] = i), phi[i] = i - 1, mu[i] = -1; //i是素数 for (int j = 0; j &lt; p.size() &amp;&amp; (k = i * p[j]) &lt; N; ++j) { phi[k] = phi[i] * p[j]; if ((m[k] = p[j]) == m[i]) { mu[k] = 0; break; } phi[k] -= phi[i]; mu[k] = -mu[i]; } } }}; 常见数论函数变换$\\sum_{d|n}\\mu(d)=[n=1]$ $\\phi(n)=\\sum_{i=1}^n[\\gcd(i,n)=1]=\\sum_{i=1}^n\\sum_{k\\mid i,k\\mid n}\\mu(k)=\\sum_{k\\mid n}\\frac nk\\mu(k)$ 前缀和欧拉函数前缀和$S_\\phi(n)=\\frac{(n+1)n}2-\\sum_{d=1}^nS_\\phi(\\frac{n}{d})$ 莫比乌斯函数前缀和$S_\\mu(n)=1-\\sum_{d=1}^nS_\\mu(\\frac{n}{d})$ 莫比乌斯反演若$f(n)=\\sum_{d|n}g(d)$，则$g(n)=\\sum_{d|n}\\mu(d)f(\\frac{n}{d})$ 若$f(n)=\\sum_{i=1}^nt(i)g(\\frac{n}{i})$，则$g(n)=\\sum_{i=1}^n\\mu(i)t(i)f(\\frac{n}{i})$（此时代$t(i)=[gcd(n,i)&gt;1]$可得上式） 举例（其中$T=kd$）： $\\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)$ $=\\sum_d d\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd (i,j)=d]$ $=\\sum_{d}d\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor}[\\gcd (i,j)=1]$ $=\\sum_{d}d\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor}\\sum_{k\\mid i,k\\mid j}\\mu(k)$ $=\\sum_d d\\sum_k\\mu(k)\\sum_{k\\mid i}^{\\lfloor\\frac nd\\rfloor}\\sum_{k\\mid j}^{\\lfloor\\frac md\\rfloor}$ $=\\sum_{d}d\\sum_k\\mu(k)\\lfloor\\frac n{kd}\\rfloor\\lfloor\\frac m{kd}\\rfloor$ $=\\sum_{T}\\lfloor\\frac nT\\rfloor\\lfloor\\frac mT\\rfloor\\sum_{k\\mid T}\\frac Tk\\mu(k)$ $=\\sum_{T}\\lfloor\\frac nT\\rfloor\\lfloor\\frac mT\\rfloor\\varphi(T)$ $\\varphi(T)$可以使用线性筛预处理处理，我们就可以枚举$T$求上式了，时间复杂度$O(n)$。多组数据$n,m$询问上式，时间复杂度就变成了$O(Tn)$。事实上，$\\lfloor\\frac{n}{T}\\rfloor$是不会轻易变化的，是过了连续的一段后才发生变化的，那么我们就可以计算出这一段的结束位置，对$\\varphi$函数作前缀和，就可以直接分块了，这样的时间复杂度是$O(T\\sqrt{n})$的。 PollardRho大数素因子分解时间复杂度$O(N^{1/4})$，数据多的时候可考虑欧拉筛优化。 12345678910111213141516171819202122232425262728293031323334struct PollardRho{ bool isPrime(ll n, int S = 12) //MillerRabin素数测试，S为测试次数，用前S个素数测一遍，S=12可保证unsigned long long范围内无错；n&lt;2请特判 { ll d, u, t, p[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}; for (d = n - 1; !(d &amp; 1);) d &gt;&gt;= 1; //未对0，1做特判！ for (int i = 0; i &lt; S; ++i) { if (n % p[i] == 0) return n == p[i]; for (u = d, t = pow(p[i], u, n); u != n - 1 &amp;&amp; t != n - 1 &amp;&amp; t != 1; u &lt;&lt;= 1) t = mul(t, t, n); if (t != n - 1 &amp;&amp; !(u &amp; 1)) return 0; } return 1; } void fac(ll n, vector&lt;ll&gt; &amp;factor) { if (isPrime(n)) return factor.push_back(n); for (ll c = 1;; ++c) for (ll i = 0, k = 1, x = rand() % (n - 1) + 1, y, p;;) { if (++i == k) y = x, k &lt;&lt;= 1; if (x = (mul(x, x, n) + c) % n, p = gcd(abs(x - y), n), p == n) break; if (p &gt; 1) return fac(p, factor), fac(n / p, factor); } }}; 快速变换蝴蝶变换（雷德变换）保存FTT和FNTT时交换的对应位置（即保存的是置换）。 123456789struct Rader : vector&lt;int&gt;{ Rader(int n) : vector&lt;int&gt;(1 &lt;&lt; int(ceil(log2(n)))) { for (int i = at(0) = 0; i &lt; size(); ++i) if (at(i) = at(i &gt;&gt; 1) &gt;&gt; 1, i &amp; 1) at(i) += size() &gt;&gt; 1; }}; 快速傅里叶变换使用示例，高精度乘法。 123456789101112131415161718192021222324252627282930313233343536struct FFT : Rader{ vector&lt;complex&lt;lf&gt;&gt; w; FFT(int n) : Rader(n), w(size(), polar(1.0, 2 * PI / size())) { w[0] = 1; for (int i = 1; i &lt; size(); ++i) w[i] *= w[i - 1]; } vector&lt;complex&lt;lf&gt;&gt; fft(const vector&lt;complex&lt;lf&gt;&gt; &amp;a) const { vector&lt;complex&lt;lf&gt;&gt; x(size()); for (int i = 0; i &lt; a.size(); ++i) x[at(i)] = a[i]; for (int i = 1; i &lt; size(); i &lt;&lt;= 1) for (int j = 0; j &lt; i; ++j) for (int k = j; k &lt; size(); k += i &lt;&lt; 1) { complex&lt;lf&gt; &amp;l = x[k], &amp;r = x[k + i], t = w[size() / (i &lt;&lt; 1) * j] * r; r = l - t, l += t; } return x; } vector&lt;ll&gt; ask(const vector&lt;ll&gt; &amp;a, const vector&lt;ll&gt; &amp;b) const { vector&lt;complex&lt;lf&gt;&gt; xa(a.begin(), a.end()), xb(b.begin(), b.end()); xa = fft(xa), xb = fft(xb); for (int i = 0; i &lt; size(); ++i) xa[i] *= xb[i]; vector&lt;ll&gt; ans(size()); xa = fft(xa), ans[0] = xa[0].real() / size() + 0.5; for (int i = 1; i &lt; size(); ++i) ans[i] = xa[size() - i].real() / size() + 0.5; return ans; }}; 快速数论变换原理和FFT相同，解决特殊情况下FFT的浮点误差，并且可以在同余系进行变换。 对于形如$m=2^nc+1$的费马素数，记其原根为g，则旋转因子为$g^{(m-1)/n}$，满足$g^{m-1}=1$且$2^n\\mid m-1$。 常见素数的原根。 使用示例 1234567891011121314151617181920212223242526272829303132333435363738struct FNTT : Rader, Mod{ ll G; vector&lt;ll&gt; w; FNTT(int N, ll M, ll G) : Rader(N), Mod(M), G(G), w(size(), pow(G, (M - 1) / size())) { for (int i = w[0] = 1; i &lt; size(); ++i) w[i] = mul(w[i], w[i - 1]); } vector&lt;ll&gt; fntt(const vector&lt;ll&gt; &amp;a) const { vector&lt;ll&gt; x(size()); for (int i = 0; i &lt; a.size(); ++i) x[at(i)] = a[i]; for (int i = 1; i &lt; size(); i &lt;&lt;= 1) for (int j = 0; j &lt; i; ++j) for (int k = j; k &lt; size(); k += i &lt;&lt; 1) { ll t = mul(w[size() / (i &lt;&lt; 1) * j], x[k + i]); if (x[k + i] = x[k] - t, x[k + i] &lt; 0) x[k + i] += M; if (x[k] += t, x[k] &gt;= M) x[k] -= M; } return x; } vector&lt;ll&gt; ask(vector&lt;ll&gt; a, vector&lt;ll&gt; b) const { a = fntt(a), b = fntt(b); for (int i = 0; i &lt; size(); ++i) a[i] = mul(a[i], b[i]); a = fntt(a), reverse(a.begin() + 1, a.end()); ll u = inv(size()); for (int i = 0; i &lt; size(); ++i) a[i] = mul(a[i], u); return a; }}; 快速沃尔什变换如果要在同余系中进行运算，则下面代码需要修改。 12345678910111213141516void fwt(vector&lt;ll&gt; &amp;x, void f(ll &amp;l, ll &amp;r)){ for (int i = 1; i &lt; x.size(); i &lt;&lt;= 1) for (int j = 0; j &lt; i; ++j) for (int k = j; k &lt; x.size(); k += i &lt;&lt; 1) f(x[k], x[k + i]);}void fwt(ll *b, ll *e, void f(ll &amp;l, ll &amp;r)) //再给一个递归二分的代码便于理解{ if (e - b &lt; 2) return; ll *m = b + (e - b) / 2; fwt(b, m, f), fwt(m, e, f); while (m &lt; e) f(*(b++), *(m++));} AND12void tf(ll &amp;l, ll &amp;r) { l += r; }void utf(ll &amp;l, ll &amp;r) { l -= r; } OR12void tf(ll &amp;l, ll &amp;r) { r += l; }void utf(ll &amp;l, ll &amp;r) { r -= l; } XOR123456void tf(ll &amp;l, ll &amp;r){ ll tl = l + r, tr = l - r; l = tl, r = tr;}void utf(ll &amp;l, ll &amp;r) { tf(l, r), l &gt;&gt;= 1, r &gt;&gt;= 1; } XNOR、NAND、NOR直接用异或运算、与运算、或运算的方法求出来，然后将互反的两位交换即可。 Pell方程形如$x^2-Dy^2=1$（D为任意正整数）的方程称为佩尔方程，必有最小正整数解$(x_0,y_0)$，用$x_n=x_0x_{n-1}+Dy_0y_{n-1},y_n=y_0x_{n-1}+x_0y_{n-1}$可递推方程的第n小整数解（可用矩阵快速幂求），同时还有 $2x_0x_n=x_{n-1}+x_{n+1},2x_0y_n=y_{n-1}+y_{n+1}$ Bertrand猜想$\\forall n&gt;3,\\exist n&lt;p&lt;n\\times 2$其中n为整数，p为质数。 威尔逊定理当且仅当p为素数时：$(p-1)!\\equiv -1\\pmod p$， Jacobi’s Four Square Theorem设$a^2+b^2+c^2+d^2=n$的自然数解个数为$r4(n)$，$d(n)$为$n$的约数和，由Jacobi’s Four Square Theorem可知，若$n$是奇数，则$r4(n)=8d(n)$，否则$r4(n)=24d(k)$，$k$是$n$去除所有$2$后的结果。","link":"/2019/02/03/2019-02-03-数论/"},{"title":"高精度","text":"## 无符号整数 [使用范例](https://vjudge.net/solution/16907599) vector自带大小比较为字典序比较， `!=` 、 `==` 运算，其余需要时一定记得重载！ 减法，当被减数小于减数时减为0。 undefined ## 分数 [使用示范](https://vjudge.net/solution/16733633)。 undefined ## bitset高精度 代替整型进行位运算，更方便并且可以处理超过最大整形范围大小的位集合。 你可以把bitset看作可以位运算的bool数组，换言之，bitset的大小是固定的。因此，用bitset做状态压缩是很方便的，也可以方便的实现集合的交并补操作。 bitset仅重载了相等不等和位运算符，原生不支持四则运算和大小比较，所以很少代替高精度数。 undefined","link":"/2019/02/03/2019-02-03-高精度/"},{"title":"Ubuntu MongoDB数据库的安装和使用","text":"本博文介绍了MongoDB，并详细指引读者在Ubuntu下MongoDB的安装和使用。本教程在Ubuntu14.04下测试通过。 一、MongoDB介绍MongoDB 是一个是一个基于分布式文件存储的数据库，介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 二、安装MongoDBMongoDB安装很简单，无需下载源文件，可以直接用apt-get命令进行安装。打开终端，输入以下命令： 1sudo apt-get install mongodb 1.安装完成后，在终端输入以下命令查看MongoDB版本： 1mongo -version 输出版本信息，表明安装成功，截图如下： 2.启动和关闭mongodb命令如下： 12service mongodb startservice mongodb stop 截图如下： 3.默认设置MongoDB是随Ubuntu启动自动启动的。输入以下命令查看是否启动成功： 1pgrep mongo -l #注意：-l是英文字母l，不是阿拉伯数字1 截图如下：卸载MongoDB 1sudo apt-get --purge remove mongodb mongodb-clients mongodb-server 三、使用MongoDBshell命令模式输入mongo进入shell命令模式，默认连接的数据库是test数据库，在此之前一定要确保你已经启动了MongoDB，否则会出现错误，启动之后运行成功，如下截图：常用操作命令：数据库相关 123456show dbs:显示数据库列表 show collections：显示当前数据库中的集合（类似关系数据库中的表table） show users：显示所有用户 use yourDB：切换当前数据库至yourDB db.help() ：显示数据库操作命令 db.yourCollection.help() ：显示集合操作命令，yourCollection是集合名 MongoDB没有创建数据库的命令，如果你想创建一个“School”的数据库，先运行use School命令，之后做一些操作（如：创建聚集集合db.createCollection(‘teacher’)）,这样就可以创建一个名叫“School”的数据库。截图如下： 下面以一个School数据库为例，在School数据库中创建两个集合teacher和student，并对student集合中的数据进行增删改查基本操作（集合Collection相当于关系型数据库中的表table）。1、切换到School数据库 1use School #切换到School数据库。MongoDB 无需预创建School数据库，在使用时会自动创建 2、创建Collection 1db.createCollection(&apos;teacher&apos;) #创建一个聚集集合。MongoDB 其实在插入数据的时候，也会自动创建对应的集合，无需预定义集合 截图如下：3、插入数据与数据库创建类似，插入数据时也会自动创建集合。插入数据有两种方式：insert和save。 12db.student.insert({_id:1, sname: &apos;zhangsan&apos;, sage: 20}) #_id可选db.student.save({_id:1, sname: &apos;zhangsan&apos;, sage: 22}) #_id可选 这两种方式，其插入的数据中_id字段均可不写，会自动生成一个唯一的_id来标识本条数据。而insert和save不同之处在于：在手动插入_id字段时，如果_id已经存在，insert不做操作，save做更新操作；如果不加_id字段，两者作用相同都是插入数据。截图如下： 添加的数据其结构是松散的，只要是bson格式均可，列属性均不固定，根据添加的数据为准。先定义数据再插入，就可以一次性插入多条数据，截图如下：运行完以上例子，student 已自动创建，这也说明 MongoDB 不需要预先定义 collection ，在第一次插入数据后，collection 会自动的创建。截图如下： 4、查找数据 1db.youCollection.find(criteria, filterDisplay) criteria ：查询条件，可选filterDisplay：筛选显示部分数据，如显示指定列数据，可选（当选择时，第一个参数不可省略，若查询条件为空，可用{}做占位符，如下例第三句） 12345db.student.find() #查询所有记录。相当于：select * from studentdb.student.find({sname: &apos;lisi&apos;}) #查询sname=&apos;lisi&apos;的记录。相当于： select * from student where sname=&apos;lisi&apos;db.student.find({},{sname:1, sage:1}) #查询指定列sname、sage数据。相当于：select sname,sage from student。sname:1表示返回sname列，默认_id字段也是返回的，可以添加_id:0（意为不返回_id）写成{sname: 1, sage: 1,_id:0}，就不会返回默认的_id字段了db.student.find({sname: &apos;zhangsan&apos;, sage: 22}) #and 与条件查询。相当于：select * from student where sname = &apos;zhangsan&apos; and sage = 22db.student.find({$or: [{sage: 22}, {sage: 25}]}) #or 条件查询。相当于：select * from student where sage = 22 or sage = 25 查询操作类似，这里只给出db.student.find({sname: ‘lisi’})查询的截图，如下： 5、修改数据 123456db.youCollection.update(criteria, objNew, upsert, multi ) criteria: update的查询条件，类似sql update查询内where后面的 objNew : update的对象和一些更新的操作符（如$set）等，也可以理解为sql update查询内set后面的。 upsert : 如果不存在update的记录，是否插入objNew，true为插入，默认是false，不插入。 multi: mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。默认false，只修改匹配到的第一条数据。 其中criteria和objNew是必选参数，upsert和multi可选参数 举例如下： 1db.student.update({sname: &apos;lisi&apos;}, {$set: {sage: 30}}, false, true) #相当于：update student set sage =30 where sname = &apos;lisi&apos;; 操作截图如下：6、删除数据 1db.student.remove({sname: &apos;chenliu&apos;}) #相当于：delete from student where sname=&apos;chenliu&apos; 操作截图如下： 7、退出shell命令模式输入exit或者Ctrl+C退出shell命令模式 参考MongoDB官方文档： 1https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/?_ga=2.38644067.1704633038.1522762185-1747967431.1522762185","link":"/2018/08/12/Ubuntu安装MongoDB和使用/"},{"title":"pymysql远程连接被拒绝问题解决方法","text":"pymysql远程连接被拒绝问题解决方法 pymysql.err.OperationalError: (2003, “Can’t connect to MySQL server on ‘172.16.112.136’ ([Errno 61] Connection refused)”) 一、 环境信息 123456服务器系统：Ubuntu16.04服务器MySQL版本：mysql Ver 14.14 Distrib 5.7.26, for Linux (x86_64) using EditLine wrapper本地系统：MAC本地客户端：Pycharm本地开发环境：python(3.7.3)，PyMySQL(0.9.3)假设：登录用户名为:root，密码为:mysql ，MySQL连接端口:3306 二、问题描述 python连接MySQL报错 本地客户端及代码连接均失败： 2003, &quot;Can't connect to MySQL server on ‘172.16.112.136 ’ 12345678910111213141516171819202122/usr/local/bin/python3.7 /Users/jiazhixiang/Desktop/Preparation/03-demo/demo.pyTraceback (most recent call last): File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pymysql/connections.py&quot;, line 583, in connect **kwargs) File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/socket.py&quot;, line 727, in create_connection raise err File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/socket.py&quot;, line 716, in create_connection sock.connect(sa)ConnectionRefusedError: [Errno 61] Connection refusedDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;/Users/jiazhixiang/Desktop/Preparation/03-demo/demo.py&quot;, line 9, in &lt;module&gt; conn = pymysql.connect(host=&apos;172.16.112.136&apos;, port=3306, user=&apos;root&apos;, password=&apos;mysql&apos;,database=&apos;school&apos;, charset=&apos;utf8&apos;) File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pymysql/__init__.py&quot;, line 94, in Connect return Connection(*args, **kwargs) File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pymysql/connections.py&quot;, line 325, in __init__ self.connect() File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pymysql/connections.py&quot;, line 630, in connect raise excpymysql.err.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;172.16.112.136&apos; ([Errno 61] Connection refused)&quot;) 如下图所示 三、官方文档描述 123&quot;The error (2003) Can&apos;t connect to MySQL server on &apos;server&apos; (10061) indicates that the network connection has been refused. You should check that there is a MySQL server running, that it has network connections enabled, and that the network port you specified is the one configured on the server.&quot;谷歌译文：“错误（2003）无法连接到&apos;服务器&apos;上的MySQL服务器（10061）表示网络连接已被拒绝。您应检查是否有MySQL服务器正在运行，是否已启用网络连接，以及您指定的网络端口是服务器上配置的网络端口。“ 四、解决过程 授权法。 需要注意mysql数据库配置文件中的bindaddress 的参数和skip-networking 配置 12bindaddress : 设定哪些ip地址被配置，使得mysql服务器只回应哪些ip地址的请求),最好注释掉该参数或设置成为127.0.0.1以外的值skip-networking : 如果设置了该参数项，将导致所有TCP/IP端口没有被监听,也就是说出了本机，其他客户端都无法用网络连接到本mysql服务器，所以应该注释掉该参数 使用ps aux|grep mysql命令查看，MySQL服务是否已启动: 使用vim my.cnf命令查看my.cnf文件(在MySQL安装目录下，我的位置是/u/etc/mysql/mysql.conf.d),修改其对应的值并重启MySQL。对应内容如下： 修改如下 123[mysqld]bind-address = 0.0.0.0 # 表示允许任何主机登陆MySQLport=3306 # 表示MySQL运行端口为3306(我的是3306，所以不用修改) 用mysql -u root -p命令，回车后输入密码mysql能正常登陆服务器MySQL 1234567mysql&gt; show global variables like &apos;port&apos;; # 查看MySQL运行的实际端口+---------------+-------| Variable_name | Value |+---------------+-------+| port | 3306 |+---------------+-------+1 row in set (0.01 sec) 123456789101112131415 mysql&gt; use mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+------------------+4 rows in set (0.01 sec) 12# 如果上述查询结果，root用户对应的host不为%，则修改用户权限# 此处需注意的是，修改权限时要带上密码(IDENTIFIED BY &apos;mysql&apos;),没加密码之前客户端还是不能远程访问MySQL。 12345678mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;mysql&apos; WITH GRANT OPTION;Query OK, 0 rows affected, 1 warning (0.00 sec) # 表示修改成功# sql语句不区分大小写# grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;mysql&apos; with grant option;mysql&gt; FLUSH PRIVILEGES; # 刷新数据库命令必须执行！！Query OK, 0 rows affected (0.00 sec) 12345678910mysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys |+-----------+------------------+4 rows in set (0.00 sec) 重启mysql服务 123456789101112131415161718python@ubuntu:~$ sudo service mysql stop[sudo] python 的密码： python@ubuntu:~$ sudo service mysql startpython@ubuntu:~$ ps aux | grep mysqlmysql 32273 3.0 6.6 1173600 134308 ? Ssl 13:09 0:00 /usr/sbin/mysqldpython 32316 0.0 0.0 15984 936 pts/1 S+ 13:09 0:00 grep --color=auto mysqlpython@ubuntu:~$ sudo service mysql status● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since 五 2019-05-24 13:09:32 CST; 1min 9s ago Process: 32274 ExecStartPost=/usr/share/mysql/mysql-systemd-start post (code=exited, status=0/SUCCESS) Process: 32266 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exited, status=0/SUCCESS) Main PID: 32273 (mysqld) CGroup: /system.slice/mysql.service └─32273 /usr/sbin/mysqld5月 24 13:09:30 ubuntu systemd[1]: Starting MySQL Community Server...5月 24 13:09:32 ubuntu systemd[1]: Started MySQL Community Server. 启动代码，问题已经解决 另一种方式：改表法 五、改表法。 可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%” 12345678登录数据库：mysql -u root -pmysqlmysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;mysql&gt;select host, user from user;mysql&gt;FLUSH PRIVILEGES; 删除用户 删除数据库中的其他用户 方法一 delete from user where user='root' and host='localhost'; 123456789101112131415161718192021222324252627282930mysql&gt;use mysqlDatabase changedmysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+------------------+5 rows in set (0.00 sec)mysql&gt;delete from user where user=&apos;root&apos; and host=&apos;localhost&apos;;Query OK, 1 row affected (0.01 sec)mysql&gt;select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys |+-----------+------------------+4 rows in set (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.02 sec) 方法二 1drop user root@&apos;localhost&apos;; 删除用户的数据库1drop database school; 修改指定用户密码12345mysql -u root -p # 进入数据库update mysql.user set password=password(&apos;新密码&apos;) where User=&quot;phplamp&quot; and Host=&quot;localhost&quot;;flush privileges;","link":"/2019/07/23/pymysql远程连接被拒绝问题解决方法/"},{"title":"数学分析","text":"数学分析增长趋势$n\\to+\\infty,\\forall p,q&gt;0,a&gt;1,{(\\ln n)}^q\\ll n^p\\ll a^n\\ll n!\\ll n^n$ 积分表反读可得导数表，此处略。$\\int k,\\mathrm{d}x=kx+C$$\\int x^a,dx=\\frac{x^{a+1} }{a+1}+C$$\\int\\frac{1}{x},dx=\\ln|x|+C$$\\int e^x,dx=e^x + C$$\\int a^x,dx=\\frac{a^x}{\\ln a}+C$$\\int\\cos x,dx=\\sin x+C$$\\int\\sin x,dx=-\\cos x+C$$\\int\\frac{1}{cos^2x},dx=\\int\\sec^2 x,dx=\\tan x+C$$\\int\\frac{1}{sin^2x},dx=\\int\\csc^2 x,dx=-\\cot x+C$$\\int\\frac{1}{\\sqrt{1-x^2} },dx=\\arcsin x+C=-\\arccos x + C$$\\int\\frac{1}{1+x^2},dx=\\arctan x+C=-arccot,x+C$$\\int\\sec x\\tan x,dx=\\sec x+C$$\\int\\csc x\\cot x,dx=-\\csc x+C$$\\int\\tan x,dx=-\\ln|\\cos x|+C$$\\int\\cot x,dx=\\ln|\\sin x|+C$$\\int\\sec x,dx=\\ln|\\sec x+\\tan x|+C$$\\int\\csc x,dx=\\ln|\\csc x-\\cot x|+C$$\\int sh,x,dx=ch,x+C$$\\int ch,x,dx=sh,x+C$$\\int\\frac{1}{x^2+a^2},dx=\\frac{1}{a}\\arctan\\frac{x}{a}+C$$\\int\\frac{1}{x^2-a^2},dx=\\frac{1}{2a}\\ln|\\frac{x-a}{x+a}| + C$$\\int\\frac{1}{\\sqrt{a^2-x^2} },dx=\\arcsin\\frac{x}{a}+C$$\\int\\frac{1}{\\sqrt{x^2-a^2} },dx=\\ln|x+\\sqrt{x^2-a^2}|+C$$\\int\\frac{1}{\\sqrt{x^2+a^2} },dx=\\ln|x+\\sqrt{x^2+a^2}|+C$ 积分求几何量面积若简单闭曲线$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$端点处连续（$x(\\alpha)=x(\\beta),y(\\alpha)=y(\\beta)$）且其他地方不自交，$x(t),y(t)$都逐段有连续微商，则此闭合曲线围起来的有界区域面积$S=-\\int_\\alpha^\\beta x’(t)y(t),dt=-\\int_\\alpha^\\beta y(t),dx(t)=-\\oint_\\Gamma y,dx=\\oint_\\Gamma x,dy$等式右边称为曲线$\\Gamma$上的积分，其计算方法是带入参数方程到定积分计算式中，积分上下限为始点与终点对应的参数值。下限并不总是小于上限，参数从下限到上限变化时对应曲线的正向（沿正向观察时，曲线所围的区域永远在左侧）。极坐标下，连续非负曲线$r=r(\\theta)$与向径$\\theta=\\alpha,\\theta=\\beta$，其中$0\\leq\\beta-\\alpha\\leq2\\pi$所围成的平面图形面积$S=\\frac{1}{2}\\int_\\alpha^\\beta r^2(\\theta),d\\theta$ 体积记立体过x点且垂直于x轴的截面面积为$S(x)$，则其体积$V=\\int_a^bS(x),dx$连续曲线$y=f(x)\\ge 0,x\\in[a,b]$绕x轴旋转一周产生的旋转体体积$V=\\pi\\int_a^by^2,dx$ 弧长若简单闭曲线$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$端点处重合（$x(\\alpha)=x(\\beta),y(\\alpha)=y(\\beta)$）且其他地方不自交，$x(t),y(t)$连续且满足$[x’(t)]^2+[y’(t)]^2\\ne0,\\forall t\\in[\\alpha,\\beta]$此时称曲线光滑，其长度$s=\\int_\\alpha^\\beta\\sqrt{[x’(t)]^2+[y’(t)]^2},dt$此式可对称推广到高维空间曲线。极坐标下，$r=r(\\theta),\\theta\\in[\\alpha,\\beta]$的长度为$s=\\int_\\alpha^\\beta\\sqrt{[r(\\theta)]^2+[r’(\\theta)]^2},d\\theta$ 曲率若曲线由参数方程$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$给出且有二阶微商，则其在一点的曲率$K=\\frac{|y’’x’-y’x’’|}{[x’^2+y’^2]^{\\frac{3}{2} } }$若$y=f(x)$，则$K=\\frac{|y’’|}{(1+y’^2)^\\frac{3}{2} }$同时记$\\frac{1}{K}$为曲率半径。 旋转体侧面积若曲线由参数方程$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$给出，则其绕x轴旋转体的侧面积$s=2\\pi\\int_\\alpha^\\beta y(t)\\sqrt{[x’(t)]^2+[y’(t)]^2},dt$ 空间曲线的切线与法平面若已知曲线上一点$P(x_0,y_0,z_0)$处的切向量为$\\tau(x_0,y_0,z_0)=(A,B,C)$则曲线在该点的切线方程为$\\frac{x-x_0}A=\\frac{y-y_0}B=\\frac{z-z_0}C$法平面方程为$A(x-x_0)+B(y-y_0)+C(z-z_0)=0$当曲线由参数方程$\\begin{cases}x=x(t),\\y=y(t),\\z=z(t),\\end{cases}t\\in[\\alpha,\\beta]$给出时，曲线在P点的切向量为$\\tau=\\pm(x’(t_0),y’(t_0),z’(t_0))$更一般地，若曲线用两曲面的交线给出$\\begin{cases}F(x,y,z)=0,\\G(x,y,z)=0,\\end{cases}$且在P点的某邻域能确定函数组$y=y(x),z=z(x)$满足$y_0=y(x_0),z_0=z(x_0)$，且$y’(x),z’(x)$存在，则曲线在P点的切向量$\\tau=\\pm(\\frac{\\partial(F,G)}{\\partial(y,z)},\\frac{\\partial(F,G)}{\\partial(z,x)},\\frac{\\partial(F,G)}{\\partial(x,y)})$ 空间曲面的切平面与法线若已知曲面上一点$P(x_0,y_0,z_0)$处的切平面的法向量为$\\vec n=(A’,B’,C’)$则曲线在该点的法线方程为$\\frac{x-x_0}{A’}=\\frac{y-y_0}{B’}=\\frac{z-z_0}{C’}$切平面方程为$A’(x-x_0)+B’(y-y_0)+C’(z-z_0)=0$当曲面方程为$\\pi:F(x,y,z)=0$在曲面上任取一条过P的曲线，设其方程为$\\begin{cases}x=x(t),\\y=y(t),\\z=z(t),\\end{cases}t\\in[\\alpha,\\beta]$此时有$F(x(t),y(t),z(t))=0$令$t=t_0$两边对t求导，并写成向量的内积式，得$(F_x,F_y,F_z)_P\\cdot(x’(t_0),y’(t_0),z’(t_0))=0$则曲线在P点的法向量为$\\vec{n}=\\pm(F_x,F_y,F_z)_P$若曲线由参数方程给出$\\begin{cases}x=x(u,v),\\y=y(u,v),\\z=z(u,v),\\end{cases}$则曲线在P点的法向量$\\vec{n}=\\pm(\\frac{\\partial(y,z)}{\\partial(u,v)},\\frac{\\partial(z,x)}{\\partial(u,v)},\\frac{\\partial(x,y)}{\\partial(u,v)})$ 方向导数设三元函数$u=f(x,y,z)$在点$P_0(x_0,y_0,z_0)$的某邻域内有定义，任意给定始于点$P_0$的射线$l$，$P(x,y,z)$为l上且含于定义域内的点。若极限$\\lim_{r(p,p_0)\\to0^+}\\frac{f(P)-f(P_0)}{r(P,P_0)}=\\lim_{r(p,p_0)\\to0^+}\\frac{\\Delta_lf(P_0)}{r(P,P_0)}$存在，则称该极限值为函数$f$在点$P_0$沿方向$l$的方向导数，记为$\\frac{\\partial f}{\\partial l}|{P_0}$或$\\frac{\\partial f(P_0)}{\\partial l}$，$\\frac{\\Delta_lf(P_0)}{r(P,P_0)}$称为函数在$P_0$点沿$l$方向的增量。特别地，$\\frac{\\partial f(P_0)}{\\partial x}$就是函数在$P_0$点沿$x$轴正向的方向导数，$y,z$轴上的方向导数同理。若函数在$P_0$点可微，则其在$P_0$沿任何方向$l$的方向导数都存在，则有以下公式$\\frac{\\partial f(P_0)}{\\partial l}=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z})|{P_0}\\cdot\\vec{l_0}$其中$\\vec{l_0}=(\\cos\\alpha,\\cos\\beta,cos\\gamma)=\\frac{1}{\\rho}(\\Delta x,\\Delta y,\\Delta z)$为$l$的方向余弦。 泰勒公式用$f^{(n)}(x)$表示f(x)的n阶导数。只要让余项&lt;EPS即可计算指定函数到任意精确度。特别取a=0时称为麦克劳林公式。$f(x)=f(a)+f^{(1)}(a)(x-a)+\\frac{f^{(2)}(a)}{2!}(x-a)^2+\\ldots+\\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)$$R_n(x)=o((x-a)^n)$，佩亚诺余项$R_n(x)=\\frac{1}{n!}\\int_a^x(x-t)^nf^{(n+1)}(t),dt$，积分余项$R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-a)^{n+1},a&lt;\\xi&lt;x$，拉格朗日余项$R_n(x)=\\frac{(x-a)^{n+1} }{n!}(1-\\theta)^nf^{(n+1)}(a+\\theta(x-a)),0&lt;\\theta&lt;1$，柯西余项 指数函数$(e^x)^{(n)}=e^x$$e^x=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\ldots+\\frac{x^n}{n!}+R_n(x)$$R_n(x)=\\frac{e^{\\theta x} }{(n+1)!}x^{n+1},\\xi=\\theta x,0&lt;\\theta&lt;1$ 三角函数$(\\sin x)^{(n)}=\\sin(x+\\frac{n\\pi}{2})$$\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\ldots+(-1)^{k-1}\\frac{x^{2k-1} }{(2k-1)!}+R_{2k}(x)$$R_{2k}(x)=(-1)^k\\frac{\\cos\\theta x}{(2k+1)!}x^{2k+1}$$(\\cos x)^{(n)}=\\cos(x+\\frac{n\\pi}{2})$$\\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\ldots+(-1)^{k-1}\\frac{x^{2k-2} }{(2k-2)!}+R_{2k-1}(x)$$R_{2k-1}(x)=(-1)^k\\frac{\\cos\\theta x}{(2k)!}x^{2k}$ 对数函数$[\\ln(1+x)]^{(n)}=(-1)^{n-1}(n-1)!(1+x)^{-n}$$\\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+\\ldots+(-1)^{n-1}\\frac{x^n}{n}+R_n(x)$ 幂函数$[(1+x)^a]^{(n)}=a(a-1)\\ldots(a-n+1)(1+x)^{a-n}$$(1+x)^a=1+ax+\\frac{a(a-1)}{2!}x^2+\\dots+\\frac{a(a-1)\\ldots(a-n+1)}{n!}x^n+R_n(x)$ 二元函数设$f(x,y)$在$P_0(x_0,y_0)$的某邻域$O(P_0)$内有直到$n+1$阶连续偏导数，则对$O(P_0)$内$\\forall(x_0+\\Delta x,y_0+\\Delta y),\\exists\\theta\\in(0,1)$，使得$f(x_0+\\Delta x,y_0+\\Delta y)=\\sum_{k=0}^n\\frac{1}{k!}(\\frac{\\partial}{\\partial x}\\Delta x+\\frac{\\partial}{\\partial y}\\Delta y)^kf(x_0,y_0)+R_n$其中$R_n=\\frac{1}{(n+1)!}(\\frac{\\partial}{\\partial x}\\Delta x+\\frac{\\partial}{\\partial y}\\Delta y)^{n+1}f(x_0+\\theta\\Delta x,y_0+\\theta\\Delta y)$ 级数部分和调和级数$n\\to\\infty,\\sum_{i=1}^n\\frac 1 i\\to\\ln n+r,r\\approx0.5772156649015328\\ldots$ 幂级数快速计算幂级数的部分和$\\sum_{i=1}^ni^k\\mod M$可借助伯努利数，详见模板·组合数学。$\\sum_{i=1}^ni^1=\\frac 1 2n(n+1)$$\\sum_{i=1}^ni^2=\\frac 1 6n(n+1)(2n+1)$$\\sum_{i=1}^ni^3=\\frac 1 4[n(n+1)]^2$$\\sum_{i=1}^ni^4=\\frac 1{30}n(n+1)(2n+1)(3n^2+3n-1)$$\\sum_{i=1}^ni^5=\\frac 1{12}[n(n+1)]^2(2n^2+2n-1)$$\\sum_{i=1}^ni^6=\\frac 1{42}n(n+1)(2n+1)(3n^4+6n^3-3n+1)$ 二分求零点、三分求极值点需要$f(x)$在区间$[l,r]$上单调/凹凸性唯一。 123456789101112double bs(double l,double r,double f(double x)){ if(r-l&lt;EPS)return l; double m=(l+r)/2; return sgn(f(l)*f(m))&lt;0?bs(l,m,f):ts(m,r,f);}double ts(double l,double r,double f(double x)){ if(r-l&lt;EPS)return l; double d=(r-l)/3,lm=l+d,rm=r-d; return f(lm)&lt;f(rm)?ts(l,rm,f):ts(lm,r,f);//极小值} 自适应辛普森求函数积分123456789101112struct Simpson{ lf simpson(lf a,lf b,lf f(lf x)) { return (f(a)+4*f((a+b)/2)+f(b))*(b-a)/6; } lf ask(lf a,lf b,lf f(lf x),lf e=EPS) { lf c=(a+b)/2,L=simpson(a,c,f),R=simpson(c,b,f),A=simpson(a,b,f); return fabs(L+R-A)&lt;EPS*15?L+R+(L+R-A)/15:ask(a,c,f,e/2)+ask(c,b,f,e/2); }}; 插值法拉格朗日插值法：插值多项式和插值基函数的形式对称，容易编程。但是，增加节点时，需要重新计算每一个插值基函数。要在$\\pmod p$意义下进行的话，那么p只能是质数。牛顿插值法：当插值节点增加时，之前已计算的结果仍然能用，每增加一个节点，只要再增加一项即可，从而避免了重复性计算。如果要mod非质数的话，那么就要用牛顿插值法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152typedef complex&lt;double&gt; Coord;#define X real()#define Y imag()double lagrange(const vector&lt;Coord&gt; &amp;p,double x)//返回p确定的多项式函数在x处的值{ double ret=0; for(int i=0; i&lt;p.size(); ++i) { double tmp=p[i].Y; for(int j=0; j&lt;p.size(); ++j) if(i!=j)tmp*=(x-p[j].X)/(p[i].X-p[j].X); ret+=tmp; } return ret;}vector&lt;double&gt; lagrange(vector&lt;Coord&gt; p)//返回p确定的多项式系数向量{ vector&lt;double&gt; ret(p.size()),sum(p.size()); ret[0]=p[0].Y,sum[0]=1; for(int i=1; i&lt;p.size(); ++i) { for(int j=p.size()-1; j&gt;=i; --j) p[j].Y=(p[j].Y-p[j-1].Y)/(p[j].X-p[j-i].X); for(int j=i; ~j; --j) sum[j]=(j?sum[j-1]:0)-sum[j]*p[i-1].X, ret[j]+=sum[j]*p[i].Y; } return ret;}double differenceQuotient(const vector&lt;Coord&gt; &amp;p,int k)//计算差商{ double ret=0; for(int i=0; i&lt;=k; ++i) { double tmp=p[i].Y; for(int j=0; j&lt;=k; ++j) if(i!=j)tmp/=p[i].X-p[j].X; ret+=tmp; } return ret;}double newton(const vector&lt;Coord&gt; &amp;p,double x){ double ret=p[0].Y; for(int i=1; i&lt;p.size(); ++i) { double tmp=differenceQuotient(p,i);//多次求，可O(n^3)预处理优化 for(int j=0; j&lt;i; ++j)tmp*=x-p[j].X; ret+=tmp; } return ret;} 转载 以下转载自斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 导数定义导数和微分的概念 $f’({ {x}{0} })=\\underset{\\Delta x\\to 0}{\\mathop{\\lim } },\\frac{f({ {x}{0} }+\\Delta x)-f({ {x}_{0} })}{\\Delta x}$ （1） 或者： $f’({ {x}{0} })=\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{f(x)-f({ {x}{0} })}{x-{ {x}{0} } }$ （2） 左右导数导数的几何意义和物理意义函数$f(x)$在$x_0$处的左、右导数分别定义为： 左导数：${ { {f}’}{-} }({ {x}{0} })=\\underset{\\Delta x\\to { {0}^{-} } }{\\mathop{\\lim } },\\frac{f({ {x}{0} }+\\Delta x)-f({ {x}{0} })}{\\Delta x}=\\underset{x\\to x_{0}^{-} }{\\mathop{\\lim } },\\frac{f(x)-f({ {x}{0} })}{x-{ {x}{0} } },(x={ {x}_{0} }+\\Delta x)$ 右导数：${ { {f}’}{+} }({ {x}{0} })=\\underset{\\Delta x\\to { {0}^{+} } }{\\mathop{\\lim } },\\frac{f({ {x}{0} }+\\Delta x)-f({ {x}{0} })}{\\Delta x}=\\underset{x\\to x_{0}^{+} }{\\mathop{\\lim } },\\frac{f(x)-f({ {x}{0} })}{x-{ {x}{0} } }$ 函数的可导性与连续性之间的关系Th1函数$f(x)$在$x_0$处可微$\\Leftrightarrow f(x)$在$x_0$处可导 Th2若函数在点$x_0$处可导，则$y=f(x)$在点$x_0$处连续，反之则不成立。即函数连续不一定可导。 Th3${f}’({ {x}{0} })$存在$\\Leftrightarrow { { {f}’}{-} }({ {x}{0} })={ { {f}’}{+} }({ {x}_{0} })$ 平面曲线的切线和法线切线方程 : $y-{ {y}{0} }=f’({ {x}{0} })(x-{ {x}{0} })$法线方程：$y-{ {y}{0} }=-\\frac{1}{f’({ {x}{0} })}(x-{ {x}{0} }),f’({ {x}_{0} })\\ne 0$ 四则运算法则设函数$u=u(x)，v=v(x)$]在点$x$可导则(1) $(u\\pm v{)}’={u}’\\pm {v}’$ $d(u\\pm v)=du\\pm dv$(2)$(uv{)}’=u{v}’+v{u}’$ $d(uv)=udv+vdu$(3) $(\\frac{u}{v}{)}’=\\frac{v{u}’-u{v}’}{ { {v}^{2} } }(v\\ne 0)$ $d(\\frac{u}{v})=\\frac{vdu-udv}{ { {v}^{2} } }$ 基本导数与微分表(1) $y=c$（常数） ${y}’=0$ $dy=0$(2) $y={ {x}^{\\alpha } }$($\\alpha $为实数) ${y}’=\\alpha { {x}^{\\alpha -1} }$ $dy=\\alpha { {x}^{\\alpha -1} }dx$(3) $y={ {a}^{x} }$ ${y}’={ {a}^{x} }\\ln a$ $dy={ {a}^{x} }\\ln adx$ 特例: $({ { {e} }^{x} }{)}’={ { {e} }^{x} }$ $d({ { {e} }^{x} })={ { {e} }^{x} }dx$ (4) ${y}’=\\frac{1}{x\\ln a}$ $dy=\\frac{1}{x\\ln a}dx$ 特例:$y=\\ln x$ $(\\ln x{)}’=\\frac{1}{x}$ $d(\\ln x)=\\frac{1}{x}dx$ (5) $y=\\sin x$ ${y}’=\\cos x$ $d(\\sin x)=\\cos xdx$ (6) $y=\\cos x$ ${y}’=-\\sin x$ $d(\\cos x)=-\\sin xdx$ (7) $y=\\tan x$ ${y}’=\\frac{1}{ { {\\cos }^{2} }x}={ {\\sec }^{2} }x$ $d(\\tan x)={ {\\sec }^{2} }xdx$(8) $y=\\cot x$ ${y}’=-\\frac{1}{ { {\\sin }^{2} }x}=-{ {\\csc }^{2} }x$ $d(\\cot x)=-{ {\\csc }^{2} }xdx$(9) $y=\\sec x$ ${y}’=\\sec x\\tan x$ $d(\\sec x)=\\sec x\\tan xdx$(10) $y=\\csc x$ ${y}’=-\\csc x\\cot x$ $d(\\csc x)=-\\csc x\\cot xdx$(11) $y=\\arcsin x$ ${y}’=\\frac{1}{\\sqrt{1-{ {x}^{2} } } }$ $d(\\arcsin x)=\\frac{1}{\\sqrt{1-{ {x}^{2} } } }dx$(12) $y=\\arccos x$ ${y}’=-\\frac{1}{\\sqrt{1-{ {x}^{2} } } }$ $d(\\arccos x)=-\\frac{1}{\\sqrt{1-{ {x}^{2} } } }dx$ (13) $y=\\arctan x$ ${y}’=\\frac{1}{1+{ {x}^{2} } }$ $d(\\arctan x)=\\frac{1}{1+{ {x}^{2} } }dx$ (14) $y=\\operatorname{arc}\\cot x$ ${y}’=-\\frac{1}{1+{ {x}^{2} } }$ $d(\\operatorname{arc}\\cot x)=-\\frac{1}{1+{ {x}^{2} } }dx$(15) $y=shx$ ${y}’=chx$ $d(shx)=chxdx$ (16) $y=chx$ ${y}’=shx$ $d(chx)=shxdx$ 复合函数，反函数，隐函数以及参数方程所确定的函数的微分法(1) 反函数的运算法则: 设$y=f(x)$在点$x$的某邻域内单调连续，在点$x$处可导且${f}’(x)\\ne 0$，则其反函数在点$x$所对应的$y$处可导，并且有$\\frac{dy}{dx}=\\frac{1}{\\frac{dx}{dy} }$(2) 复合函数的运算法则:若$\\mu =\\varphi (x)$在点$x$可导,而$y=f(\\mu )$在对应点$\\mu $($\\mu =\\varphi (x)$)可导,则复合函数$y=f(\\varphi (x))$在点$x$可导,且${y}’={f}’(\\mu )\\cdot {\\varphi }’(x)$(3) 隐函数导数$\\frac{dy}{dx}$的求法一般有三种方法：1)方程两边对$x$求导，要记住$y$是$x$的函数，则$y$的函数是$x$的复合函数.例如$\\frac{1}{y}$，${ {y}^{2} }$，$ln y$，${ { {e} }^{y} }$等均是$x$的复合函数.对$x$求导应按复合函数连锁法则做.2)公式法.由$F(x,y)=0$知 $\\frac{dy}{dx}=-\\frac{ { { { {F}’} }{x} }(x,y)}{ { { { {F}’} }{y} }(x,y)}$,其中，${ { {F}’}{x} }(x,y)$，${ { {F}’}{y} }(x,y)$分别表示$F(x,y)$对$x$和$y$的偏导数3)利用微分形式不变性 常用高阶导数公式（1）$({ {a}^{x} }){ {,}^{(n)} }={ {a}^{x} }{ {\\ln }^{n} }a\\quad (a&gt;{0})\\quad \\quad ({ { {e} }^{x} }){ {,}^{(n)} }={e}{ {,}^{x} }$（2）$(\\sin kx{)}{ {,}^{(n)} }={ {k}^{n} }\\sin (kx+n\\cdot \\frac{\\pi }{ {2} })$（3）$(\\cos kx{)}{ {,}^{(n)} }={ {k}^{n} }\\cos (kx+n\\cdot \\frac{\\pi }{ {2} })$（4）$({ {x}^{m} }){ {,}^{(n)} }=m(m-1)\\cdots (m-n+1){ {x}^{m-n} }$（5）$(\\ln x){ {,}^{(n)} }={ {(-{1})}^{(n-{1})} }\\frac{(n-{1})!}{ { {x}^{n} } }$（6）莱布尼兹公式：若$u(x),,v(x)$均$n$阶可导，则 ${ {(uv)}^{(n)} }=\\sum\\limits_{i={0} }^{n}{c_{n}^{i}{ {u}^{(i)} }{ {v}^{(n-i)} } }$，其中${ {u}^{({0})} }=u$，${ {v}^{({0})} }=v$ 微分中值定理，泰勒公式Th1(费马定理)若函数$f(x)$满足条件：(1)函数$f(x)$在${ {x}{0} }$的某邻域内有定义，并且在此邻域内恒有$f(x)\\le f({ {x}{0} })$或$f(x)\\ge f({ {x}_{0} })$, (2) $f(x)$在${ {x}{0} }$处可导,则有 ${f}’({ {x}{0} })=0$ Th2(罗尔定理)设函数$f(x)$满足条件：(1)在闭区间$[a,b]$上连续； (2)在$(a,b)$内可导； (3)$f(a)=f(b)$； 则在$(a,b)$内一存在个$\\xi $，使 ${f}’(\\xi )=0$ Th3(拉格朗日中值定理)设函数$f(x)$满足条件：(1)在$[a,b]$上连续； (2)在$(a,b)$内可导； 则在$(a,b)$内一存在个$\\xi $，使 $\\frac{f(b)-f(a)}{b-a}={f}’(\\xi )$ Th4(柯西中值定理) 设函数$f(x)$，$g(x)$满足条件：(1) 在$[a,b]$上连续； (2) 在$(a,b)$内可导且${f}’(x)$，${g}’(x)$均存在，且${g}’(x)\\ne 0$ 则在$(a,b)$内存在一个$\\xi $，使 $\\frac{f(b)-f(a)}{g(b)-g(a)}=\\frac{ {f}’(\\xi )}{ {g}’(\\xi )}$ 洛必达法则法则Ⅰ ($\\frac{0}{0}$型)设函数$f\\left( x \\right),g\\left( x \\right)$满足条件： $\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },f\\left( x \\right)=0,\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },g\\left( x \\right)=0$; $f\\left( x \\right),g\\left( x \\right)$在${ {x}{0} }$的邻域内可导，(在${ {x}{0} }$处可除外)且${g}’\\left( x \\right)\\ne 0$; $\\underset{x\\to { {x}_{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$存在(或$\\infty $)。 则:$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$。法则${ {I}’}$ ($\\frac{0}{0}$型)设函数$f\\left( x \\right),g\\left( x \\right)$满足条件：$\\underset{x\\to \\infty }{\\mathop{\\lim } },f\\left( x \\right)=0,\\underset{x\\to \\infty }{\\mathop{\\lim } },g\\left( x \\right)=0$; 存在一个$X&gt;0$,当$\\left| x \\right|&gt;X$时,$f\\left( x \\right),g\\left( x \\right)$可导,且${g}’\\left( x \\right)\\ne 0$;$\\underset{x\\to { {x}_{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$存在(或$\\infty $)。 则:$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$法则Ⅱ($\\frac{\\infty }{\\infty }$型) 设函数$f\\left( x \\right),g\\left( x \\right)$满足条件：$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },f\\left( x \\right)=\\infty ,\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },g\\left( x \\right)=\\infty $; $f\\left( x \\right),g\\left( x \\right)$在${ {x}{0} }$ 的邻域内可导(在${ {x}{0} }$处可除外)且${g}’\\left( x \\right)\\ne 0$;$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$存在(或$\\infty $)。则$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to { {x}_{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}.$同理法则${I{I}’}$($\\frac{\\infty }{\\infty }$型)仿法则${ {I}’}$可写出。 泰勒公式设函数$f(x)$在点${ {x}{0} }$处的某邻域内具有$n+1$阶导数，则对该邻域内异于${ {x}{0} }$的任意点$x$，在${ {x}{0} }$与$x$之间至少存在一个$\\xi $，使得：$f(x)=f({ {x}{0} })+{f}’({ {x}{0} })(x-{ {x}{0} })+\\frac{1}{2!}{f}’’({ {x}{0} }){ {(x-{ {x}{0} })}^{2} }+\\cdots $$+\\frac{ { {f}^{(n)} }({ {x}{0} })}{n!}{ {(x-{ {x}{0} })}^{n} }+{ {R}{n} }(x)$ 其中 ${ {R}{n} }(x)=\\frac{ { {f}^{(n+1)} }(\\xi )}{(n+1)!}{ {(x-{ {x}{0} })}^{n+1} }$称为$f(x)$在点${ {x}{0} }$处的$n$阶泰勒余项。 令${ {x}{0} }=0$，则$n$阶泰勒公式$f(x)=f(0)+{f}’(0)x+\\frac{1}{2!}{f}’’(0){ {x}^{2} }+\\cdots +\\frac{ { {f}^{(n)} }(0)}{n!}{ {x}^{n} }+{ {R}{n} }(x)$……(1)其中 ${ {R}_{n} }(x)=\\frac{ { {f}^{(n+1)} }(\\xi )}{(n+1)!}{ {x}^{n+1} }$，$\\xi $在0与$x$之间.(1)式称为麦克劳林公式 常用五种函数在${ {x}_{0} }=0$处的泰勒公式(1) ${ { {e} }^{x} }=1+x+\\frac{1}{2!}{ {x}^{2} }+\\cdots +\\frac{1}{n!}{ {x}^{n} }+\\frac{ { {x}^{n+1} } }{(n+1)!}{ {e}^{\\xi } }$ 或 $=1+x+\\frac{1}{2!}{ {x}^{2} }+\\cdots +\\frac{1}{n!}{ {x}^{n} }+o({ {x}^{n} })$ (2) $\\sin x=x-\\frac{1}{3!}{ {x}^{3} }+\\cdots +\\frac{ { {x}^{n} } }{n!}\\sin \\frac{n\\pi }{2}+\\frac{ { {x}^{n+1} } }{(n+1)!}\\sin (\\xi +\\frac{n+1}{2}\\pi )$ 或 $=x-\\frac{1}{3!}{ {x}^{3} }+\\cdots +\\frac{ { {x}^{n} } }{n!}\\sin \\frac{n\\pi }{2}+o({ {x}^{n} })$ (3) $\\cos x=1-\\frac{1}{2!}{ {x}^{2} }+\\cdots +\\frac{ { {x}^{n} } }{n!}\\cos \\frac{n\\pi }{2}+\\frac{ { {x}^{n+1} } }{(n+1)!}\\cos (\\xi +\\frac{n+1}{2}\\pi )$ 或 $=1-\\frac{1}{2!}{ {x}^{2} }+\\cdots +\\frac{ { {x}^{n} } }{n!}\\cos \\frac{n\\pi }{2}+o({ {x}^{n} })$ (4) $\\ln (1+x)=x-\\frac{1}{2}{ {x}^{2} }+\\frac{1}{3}{ {x}^{3} }-\\cdots +{ {(-1)}^{n-1} }\\frac{ { {x}^{n} } }{n}+\\frac{ { {(-1)}^{n} }{ {x}^{n+1} } }{(n+1){ {(1+\\xi )}^{n+1} } }$ 或 $=x-\\frac{1}{2}{ {x}^{2} }+\\frac{1}{3}{ {x}^{3} }-\\cdots +{ {(-1)}^{n-1} }\\frac{ { {x}^{n} } }{n}+o({ {x}^{n} })$ (5) ${ {(1+x)}^{m} }=1+mx+\\frac{m(m-1)}{2!}{ {x}^{2} }+\\cdots +\\frac{m(m-1)\\cdots (m-n+1)}{n!}{ {x}^{n} }$$+\\frac{m(m-1)\\cdots (m-n+1)}{(n+1)!}{ {x}^{n+1} }{ {(1+\\xi )}^{m-n-1} }$ 或 ${ {(1+x)}^{m} }=1+mx+\\frac{m(m-1)}{2!}{ {x}^{2} }+\\cdots $ $+\\frac{m(m-1)\\cdots (m-n+1)}{n!}{ {x}^{n} }+o({ {x}^{n} })$ 函数单调性的判断Th1: 设函数$f(x)$在$(a,b)$区间内可导，如果对$\\forall x\\in (a,b)$，都有$f,‘(x)&gt;0$（或$f,‘(x)&lt;0$），则函数$f(x)$在$(a,b)$内是单调增加的（或单调减少） Th2: （取极值的必要条件）设函数$f(x)$在${ {x}{0} }$处可导，且在${ {x}{0} }$处取极值，则$f,‘({ {x}_{0} })=0$。 Th3: （取极值的第一充分条件）设函数$f(x)$在${ {x}{0} }$的某一邻域内可微，且$f,‘({ {x}{0} })=0$（或$f(x)$在${ {x}{0} }$处连续，但$f,‘({ {x}{0} })$不存在。）(1)若当$x$经过${ {x}{0} }$时，$f,‘(x)$由“+”变“-”，则$f({ {x}{0} })$为极大值；(2)若当$x​$经过${ {x}{0} }​$时，$f,‘(x)$由“-”变“+”，则$f({ {x}{0} })$为极小值；(3)若$f,‘(x)$经过$x={ {x}{0} }$的两侧不变号，则$f({ {x}{0} })$不是极值。 Th4: (取极值的第二充分条件)设$f(x)$在点${ {x}{0} }$处有$f’’(x)\\ne 0$，且$f,‘({ {x}{0} })=0$，则 当$f’,‘({ {x}{0} })&lt;0$时，$f({ {x}{0} })$为极大值；当$f’,‘({ {x}{0} })&gt;0$时，$f({ {x}{0} })$为极小值。注：如果$f’,‘({ {x}_{0} })&lt;0$，此方法失效。 渐近线的求法(1)水平渐近线 若$\\underset{x\\to +\\infty }{\\mathop{\\lim } },f(x)=b$，或$\\underset{x\\to -\\infty }{\\mathop{\\lim } },f(x)=b$，则 $y=b$称为函数$y=f(x)$的水平渐近线。 (2)铅直渐近线 若$\\underset{x\\to x_{0}^{-} }{\\mathop{\\lim } },f(x)=\\infty $，或$\\underset{x\\to x_{0}^{+} }{\\mathop{\\lim } },f(x)=\\infty $，则 $x={ {x}_{0} }$称为$y=f(x)$的铅直渐近线。 (3)斜渐近线 若$a=\\underset{x\\to \\infty }{\\mathop{\\lim } },\\frac{f(x)}{x},\\quad b=\\underset{x\\to \\infty }{\\mathop{\\lim } },[f(x)-ax]$，则$y=ax+b$称为$y=f(x)$的斜渐近线。 函数凹凸性的判断Th1: (凹凸性的判别定理）若在I上$f’’(x)&lt;0$（或$f’’(x)&gt;0$），则$f(x)$在I上是凸的（或凹的）。 Th2: (拐点的判别定理1)若在${ {x}{0} }$处$f’’(x)=0$，（或$f’’(x)$不存在），当$x$变动经过${ {x}{0} }$时，$f’’(x)$变号，则$({ {x}{0} },f({ {x}{0} }))$为拐点。 Th3: (拐点的判别定理2)设$f(x)$在${ {x}{0} }$点的某邻域内有三阶导数，且$f’’(x)=0$，$f’’’(x)\\ne 0$，则$({ {x}{0} },f({ {x}_{0} }))$为拐点。 弧微分$dS=\\sqrt{1+y{ {‘}^{2} } }dx$ 曲率若曲线由参数方程$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$给出且有二阶微商，则其在一点的曲率$K=\\frac{|y’’x’-y’x’’|}{[x’^2+y’^2]^{\\frac{3}{2} } }$若$y=f(x)$，则$K=\\frac{|y’’|}{(1+y’^2)^\\frac{3}{2} }$同时记$\\frac{1}{K}$为曲率半径。 曲率半径曲线在点$M$处的曲率$k(k\\ne 0)$与曲线在点$M$处的曲率半径$\\rho $有如下关系：$\\rho =\\frac{1}{k}$。","link":"/2018/11/30/2018-11-30-数学分析/"},{"title":"函数程序设计实验十：车牌竞价信息处理","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354{-文件bids_201711.txt 是广州市某月车牌竞价信息，包含若干行，每行形如“1234198004118085 29570”，表示一位竞价人的身份证号和出价。假设本月有10个车牌竞拍。你的任务是统计相关信息，包括最高成交价、最低成交价、平均成交价、按照出价从高到低列车前十位出价人身份证号和出价，并存入另一个文件bidResults.txt中。例如，统计结果可能如文件bidResults1.txt 所示。要求：1. 提交你的代码文件；2. 提交统计结果文件，或者将结果粘贴在提交窗口。提示：需要排序函数，请hoogle :: [a] -&gt; [a]，或者自定义排序。-}--代码写的太丑了，以后重写吧……import Data.Charimport System.IOimport Text.Printfmain::IO()main= do txt&lt;-readFile \"bids_201711.txt\" let dat=lines txt let mi=getmin dat let ma=getmax dat let sum=getsum dat let len=length dat let aftersort=getsort dat writeFile \"bidResults.txt\" (printf \"最高成交价：%d\\n最低成交价：%d\\n平均成交价：%d\\n总共有%d参与竞价成交名单：\\n%s\" ma mi (div sum len) len (unlines (take 10 aftersort)))digit::String-&gt;Int-&gt;Intdigit s n=(ord (s!!n))-(ord '0')getval::String-&gt;Intgetval s=(digit s 23)*10000+(digit s 24)*1000+(digit s 25)*100+(digit s 26)*10+(digit s 27)getmin::[String]-&gt;Intgetmin [a]=getval agetmin (x:xs)=if a&lt;b then a else b where a=getmin [x] b=getmin xsgetmax::[String]-&gt;Intgetmax [a]=getval agetmax (x:xs)=if a&gt;b then a else b where a=getmax [x] b=getmax xsgetsum::[String]-&gt;Intgetsum [a]=getval agetsum (x:xs)=(getmax [x])+(getmax xs)getsort::[String]-&gt;[String]getsort []=[]getsort (x:xs)=(getsort [y|y&lt;-xs,(getval y)&gt;(getval x)])++[x]++(getsort [y|y&lt;-xs,(getval y)&lt;(getval x)]) 下面是bidResults.txt的内容。 1234567891011121314最高成交价：29995最低成交价：10008平均成交价：111总共有491参与竞价成交名单：1234198610248103 299951535198004062143 299481334197907229015 299221435198110019109 299161535198412072052 298221533198811246245 298201633197706227256 298151234198205229019 297991533198710186071 297771536198405206083 29727 下面是bids_201711.txt的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904911230197812061080 245961230197210049047 112931331197708184092 263871331198509014173 219911331198702174176 137781333197808181338 296861333197812025146 279551333198709276233 124951334197907229015 299221334197205049158 104161430198708181002 251861430197102201027 240901430197912121030 193671431198402182064 116821431197303143010 206601431197711224092 131961431197512184190 120691432197703132181 284241433197902071057 119851433198810041098 187541433198111221148 259941433197311121198 250651433197711041206 211151433197412131354 131461434199006226012 173991434198808016016 254301434198112246017 260061434197106257001 121931434199012017087 226981434198612107099 277051434197910097116 209441434198205257149 234451434197105058037 145071434197511068057 239531434197410198061 159661434199001168083 214561434197712158085 254481434198912018117 204201434198807048125 254691435198609050022 124471435198409016106 231011435198110019109 299161436198306186113 108061436197501287048 139041530198810111127 160781530199002261200 159931530198304086034 266301530198411268038 141591530197408019037 217501530199002079054 100571531198401270053 247361531198101252040 265141531198110182065 124181531197704223007 131751531198708234191 252751532198206021061 123521532197309044084 211311532198206094108 200761533198402091046 163921533197405231092 255071533197510141097 134821533199006061403 223901533197905261404 220591533198303111443 259061533198508036001 180091533197512086002 276271533197906156007 258811533197504206011 138981533198007276012 270951533198004256027 277611533197606026083 187851533197702066114 186181533197910176205 126491533198811246245 298201534198403103001 257021534198403183043 180331534197007193054 282381534199004133073 220041534198701103076 268111534198606093104 121591534199008033108 192851534197412013119 213021534198610178012 112101534198406018015 222461534198507278026 195471534198702279031 226791534198002219036 295971534198605189050 117961534198007209121 196541535198702061054 253421535198212101059 228191535197503131117 193771535198803255119 229371535197608028311 157101535197501128369 245911536197405270013 155261536198402134004 183261536197312034015 217551536197901275016 291581536198405206083 297271234199004029001 146201234198002169002 128311234198611199003 132831234198012199004 124021234198706219005 248861234197812129006 232301234197701239007 196111234197906209008 138971234197304129009 102311234197003259010 246071234198701079011 295181234198405169012 214161234198610119013 247901234198907069014 131581234198405109015 222601234198106179016 248181234198107099017 249401234197708199018 169611234198708199019 159291234198201239020 184821234198207069021 134671234197312119022 220461234198912069023 293571234198311129024 138161234198811099025 224641234197104079026 103511234197512268070 269061234197504178071 185041234197301168073 256731234198605098074 165611234198509118075 239561234197511198076 158311234198302028077 265721234198708238078 236111234197312088079 280831234197406148080 142681234197703048081 117231234198001208082 205411234198510168083 205431234197608078084 225971234199001118085 256431234198203158086 168791234197110178087 258501234199003188088 276791234197405268089 109671234197311178090 106461234198204058091 240141234198603198092 138001234199012078093 268131234197006098094 111381234197108058095 242781234198505268096 232811234197809078097 179681234198012038098 222951234198508078099 167721234197907098100 200251234197707098101 113141234198808118102 276581234198610248103 299951234197409128104 272861234197303158105 206181234198311088106 271551234198701048107 286561234198304078108 134941234198401198109 109781234197611088110 217601234198602148111 115631234198311048112 225741234197701268113 127251234198802128114 260761234197303028115 264011234197509058116 283881234198410288117 275581234199007158118 166831234197510248119 155521234197208068120 132561234197201068121 209771234197712098122 134041234197912258123 213811234197307058124 271651234197811128125 252321234197003078126 234241234197907048127 218591234197807218128 268431234197303148130 165501234198609288131 180641234198501128132 232141234197005068133 145211234197508028134 128301234198402278135 119771234197504218136 289621234197709228137 133771234198107108138 262201230197405203218 266981233197007050058 249421233198104060178 210901233198811040364 274341233197412030414 113191236198803025088 126971234197906138139 286171234198102238140 201041234198709218141 142661234198503118142 254581234198207178143 128791234197612018144 250471234197702038145 124431234197107148146 265261234198710258147 278441234198103128148 219731234197207278149 296731234197310038150 257351234197512218151 224711234197211258152 117521234199004238153 286431234198009078154 271581234198911248155 103111234198611138156 166541234197808048157 244941234197510278158 215391234197506208159 137431234197309158160 128021234198505258161 121261234198302098162 106941234197710248163 129441234198610148164 120651234197005198165 100081234197404238166 106341234198007278167 214251234197001168168 228611234197303168169 274181234197307178170 223621234197905168171 199471234197903208172 116901234198106068173 112651234198904278174 103891234198903268175 265151234197304078176 171381234197402198177 188441234197207068178 206391234198205098179 163271234198902268180 275631234198102138181 101791131198902092008 279361131197304108030 284461233198109040089 174611233198508200203 100121235197601273174 127511235198209173224 232751235198609203285 220811236197907235026 168041234198801289001 277861234199006189002 190191234197205039003 286721234198810089004 154171234197703039005 243181234197409279006 199741234199002139007 279191234197506069008 117591234197205049009 167361234198002269010 178381234198402049011 130501234199006149012 285971234198503069013 223841234199004229014 106731234198903089015 112291234198711169016 235581234197910059017 165951234198402219018 178321234198205229019 297991234197411019020 259891234198410169021 186881234197905169022 180171234198507059023 115641234198002149024 187231234198303269025 145151234199005239026 145591330198201289011 207171331198702114240 231121332198107013008 112281431198511154103 248901432198409062084 220221432197202204037 132561433198009085060 236351433198709255216 143481434197611098044 123961434197504148184 215701435197411122073 119901435198202033142 110091435198406073430 273991530197111248009 104331530199005108029 248671530197411288030 261991530198312158054 241541531198209102002 141231531197802104121 187701531197002204204 234001533198607241042 139041533197706121311 139041533198407216057 291641533197507106058 205371533198710186071 297771533198307256264 271221533199004286269 195161534197908203047 151041534199009228014 193711534198602109107 122431534197608149108 104781535198607190037 129041535198704112045 252961535197511282065 226321535197707192081 125371535197602022083 110641535198407222087 158851535198002172088 281721535198802082089 240581535198909192091 121711535199012282144 227351535199008232161 254741535198603242229 244081535198503042296 261621535197811082354 267631535198609192434 176751535198808143011 282011536198105154006 276901630197409082111 240521630198811038030 257831630198205108032 272121630198603098044 264891630199008068110 281121630197410128114 190991630198607238144 221381630199006139005 146121631198907150001 195961631197601170011 182181631198401250022 159891631199003230055 178741631198711140072 247811631198203040077 287171631197809172009 162021631198708074019 118211631197202127017 141731631199008057090 202101631198001288124 190471631197802238243 120791631198709038263 209991631198508158280 269141632198506218013 241261632198707018035 109311633198412267019 263851633198611277075 191481633198101057101 258441633197504057210 127731633197307177216 112461633197202067229 175801633197706227256 298151633198908247269 193641633197607047270 279941633197310259025 179671633198004039028 168541633198805169035 166061633198707129053 166451634197601010006 178061634197906140030 276741634198202280069 189671634197202120078 180591634197606150098 195781634197501180121 239821634197501210147 287221634198406230150 161011634197304190152 152671634198707190170 128561634197409120218 151951635197407271010 278691636198202023012 292851636198112105041 150661636198811265174 191741535198109102012 154111535199008052069 259311535197407192001 165981535198509162002 160511535198009242004 109391535199003172005 115521535197510072006 142081535197405222007 169811535198412282008 234461535197511042009 143071535198404182010 118771535197812232011 148991535198403162013 260551535197012092014 158001535197612022015 160391535197104142016 196421535198905182017 132931535197610112018 254281535197502022019 271111535198904032020 252131535198111102021 289991535198310102022 139161535198112272023 172171535197208162047 116131535198406272048 134501535197312272049 217791535197902132050 106351535197106262051 181081535198412072052 298221535197408102053 236181535198402212054 186871535199012262055 288321535197408082056 115691535198206132057 254211535198604132058 226431535198904032059 292291535198101022060 263791535197002222061 143901535197902082062 222431535198903102063 227341535198808062064 188471535197203162065 162161535198507172066 171101535197509042067 180211535198612162068 247461535198203182093 182661535198010192094 161641535197607212095 150461535198404092096 255561535198108172097 184031535198308012098 129401535197510222099 295601535197512162100 176831535198805042101 121121535198807282102 233891535198310102103 116221535198407272104 110651535197507192105 156751535198503152106 157691535198307062107 206251535198106262108 296491535197903262109 286891535198204132110 136391535198808202111 276141535197603152112 181661535198612242113 123611535197010172114 170721535198802232115 153971535198301082139 132141535198202242140 187281535199002222141 160271535197208212142 287021535198004062143 299481535197005102144 164071535197301202145 185381535198407192146 115671535198012082147 237551535198007192148 194941535197812202149 142651535198803082150 222511535197904252151 205121535197709052152 216231535197106102153 148121535198906052154 208071535198702182155 127711535198606092156 226961535198905172157 255931535197807262158 277201535197911262159 240901535197204142160 133281535198004112161 142771535197106272186 279981535197306042188 124921535198512242189 152351535198308152190 206901535198106072191 191631535198903072192 168721535198811022193 157601535198301262194 155361535198801212195 125841535198908052197 135971535198901142198 294181535199004132199 166501535197411172200 293931535198309082201 231861535197508192202 100211535198911232203 157741535197808032204 176271535197812152205 286731535197204162206 279911535198808112207 181161535197411142208 290561535197409232003 146561535197012152187 117781535198107162196 17291","link":"/2018/11/26/2018-11-26-车牌竞价信息处理/"},{"title":"线性代数","text":"转载自斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 线性代数行列式1.行列式按行（列）展开定理 (1) 设$A = ( a_{ {ij} } ){n \\times n}$，则：$a{i1}A_{j1} +a_{i2}A_{j2} + \\cdots + a_{ {in} }A_{ {jn} } = \\begin{cases}|A|,i=j\\ 0,i \\neq j\\end{cases}$ 或$a_{1i}A_{1j} + a_{2i}A_{2j} + \\cdots + a_{ {ni} }A_{ {nj} } = \\begin{cases}|A|,i=j\\ 0,i \\neq j\\end{cases}$即 $AA^{} = A^{}A = \\left| A \\right|E,$其中：$A^{*} = \\begin{pmatrix} A_{11} &amp; A_{12} &amp; \\ldots &amp; A_{1n} \\ A_{21} &amp; A_{22} &amp; \\ldots &amp; A_{2n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ A_{n1} &amp; A_{n2} &amp; \\ldots &amp; A_{ {nn} } \\ \\end{pmatrix} = (A_{ {ji} }) = {(A_{ {ij} })}^{T}$ $D_{n} = \\begin{vmatrix} 1 &amp; 1 &amp; \\ldots &amp; 1 \\ x_{1} &amp; x_{2} &amp; \\ldots &amp; x_{n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ x_{1}^{n - 1} &amp; x_{2}^{n - 1} &amp; \\ldots &amp; x_{n}^{n - 1} \\ \\end{vmatrix} = \\prod_{1 \\leq j &lt; i \\leq n}^{},(x_{i} - x_{j})$ (2) 设$A,B$为$n$阶方阵，则$\\left| {AB} \\right| = \\left| A \\right|\\left| B \\right| = \\left| B \\right|\\left| A \\right| = \\left| {BA} \\right|$，但$\\left| A \\pm B \\right| = \\left| A \\right| \\pm \\left| B \\right|$不一定成立。 (3) $\\left| {kA} \\right| = k^{n}\\left| A \\right|$,$A$为$n$阶方阵。 (4) 设$A$为$n$阶方阵，$|A^{T}| = |A|;|A^{- 1}| = |A|^{- 1}$（若$A$可逆），$|A^{*}| = |A|^{n - 1}$ $n \\geq 2$ (5) $\\left| \\begin{matrix} &amp; {A\\quad O} \\ &amp; {O\\quad B} \\ \\end{matrix} \\right| = \\left| \\begin{matrix} &amp; {A\\quad C} \\ &amp; {O\\quad B} \\ \\end{matrix} \\right| = \\left| \\begin{matrix} &amp; {A\\quad O} \\ &amp; {C\\quad B} \\ \\end{matrix} \\right| =| A||B|$，$A,B$为方阵，但$\\left| \\begin{matrix} {O} &amp; A_{m \\times m} \\ B_{n \\times n} &amp; { O} \\ \\end{matrix} \\right| = ({- 1)}^{ {mn} }|A||B|$ 。 (6) 范德蒙行列式$D_{n} = \\begin{vmatrix} 1 &amp; 1 &amp; \\ldots &amp; 1 \\ x_{1} &amp; x_{2} &amp; \\ldots &amp; x_{n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ x_{1}^{n - 1} &amp; x_{2}^{n 1} &amp; \\ldots &amp; x_{n}^{n - 1} \\ \\end{vmatrix} = \\prod_{1 \\leq j &lt; i \\leq n}^{},(x_{i} - x_{j})$ 设$A$是$n$阶方阵，$\\lambda_{i}(i = 1,2\\cdots,n)$是$A$的$n$个特征值，则$|A| = \\prod_{i = 1}^{n}\\lambda_{i}​$ 矩阵矩阵：$m \\times n$个数$a_{ {ij} }$排成$m$行$n$列的表格$\\begin{bmatrix} a_{11}\\quad a_{12}\\quad\\cdots\\quad a_{1n} \\ a_{21}\\quad a_{22}\\quad\\cdots\\quad a_{2n} \\ \\quad\\cdots\\cdots\\cdots\\cdots\\cdots \\ a_{m1}\\quad a_{m2}\\quad\\cdots\\quad a_{ {mn} } \\ \\end{bmatrix}$ 称为矩阵，简记为$A$，或者$\\left( a_{ {ij} } \\right)_{m \\times n}$ 。若$m = n$，则称$A$是$n$阶矩阵或$n$阶方阵。 矩阵的线性运算 1.矩阵的加法 设$A = (a_{ {ij} }),B = (b_{ {ij} })$是两个$m \\times n$矩阵，则$m \\times n$ 矩阵$C = c_{ {ij} }) = a_{ {ij} } + b_{ {ij} }$称为矩阵$A$与$B$的和，记为$A + B = C$ 。 2.矩阵的数乘 设$A = (a_{ {ij} })$是$m \\times n$矩阵，$k$是一个常数，则$m \\times n$矩阵$(ka_{ {ij} })$称为数$k$与矩阵$A$的数乘，记为${kA}$。 3.矩阵的乘法 设$A = (a_{ {ij} })$是$m \\times n$矩阵，$B = (b_{ {ij} })$是$n \\times s$矩阵，那么$m \\times s$矩阵$C = (c_{ {ij} })$，其中$c_{ {ij} } = a_{i1}b_{1j} + a_{i2}b_{2j} + \\cdots + a_{ {in} }b_{ {nj} } = \\sum_{k =1}^{n}{a_{ {ik} }b_{ {kj} } }$称为${AB}$的乘积，记为$C = AB$ 。 4. $\\mathbf{A}^{\\mathbf{T} }$、$\\mathbf{A}^{\\mathbf{-1} }$、$\\mathbf{A}^{\\mathbf{} }$*三者之间的关系** (1) ${(A^{T})}^{T} = A,{(AB)}^{T} = B^{T}A^{T},{(kA)}^{T} = kA^{T},{(A \\pm B)}^{T} = A^{T} \\pm B^{T}$ (2) $\\left( A^{- 1} \\right)^{- 1} = A,\\left( {AB} \\right)^{- 1} = B^{- 1}A^{- 1},\\left( {kA} \\right)^{- 1} = \\frac{1}{k}A^{- 1},$ 但 ${(A \\pm B)}^{- 1} = A^{- 1} \\pm B^{- 1}$不一定成立。 (3) $\\left( A^{} \\right)^{} = |A|^{n - 2}\\ A\\ \\ (n \\geq 3)$，$\\left({AB} \\right)^{} = B^{}A^{},$ $\\left( {kA} \\right)^{} = k^{n -1}A^{*}{\\ \\ }\\left( n \\geq 2 \\right)$ 但$\\left( A \\pm B \\right)^{} = A^{} \\pm B^{*}$不一定成立。 (4) ${(A^{- 1})}^{T} = {(A^{T})}^{- 1},\\ \\left( A^{- 1} \\right)^{} ={(AA^{})}^{- 1},{(A^{})}^{T} = \\left( A^{T} \\right)^{}$ 5.有关$\\mathbf{A}^{\\mathbf{} }$*的结论** (1) $AA^{} = A^{}A = |A|E$ (2) $|A^{}| = |A|^{n - 1}\\ (n \\geq 2),\\ \\ \\ \\ {(kA)}^{} = k^{n -1}A^{},{ {\\ \\ }\\left( A^{} \\right)}^{*} = |A|^{n - 2}A(n \\geq 3)$ (3) 若$A$可逆，则$A^{} = |A|A^{- 1},{(A^{})}^{*} = \\frac{1}{|A|}A$ (4) 若$A​$为$n​$阶方阵，则： $r(A^*)=\\begin{cases}n,\\quad r(A)=n\\ 1,\\quad r(A)=n-1\\ 0,\\quad r(A)&lt;n-1\\end{cases}$ 6.有关$\\mathbf{A}^{\\mathbf{- 1} }$的结论 $A$可逆$\\Leftrightarrow AB = E; \\Leftrightarrow |A| \\neq 0; \\Leftrightarrow r(A) = n;$ $\\Leftrightarrow A$可以表示为初等矩阵的乘积；$\\Leftrightarrow A;\\Leftrightarrow Ax = 0$。 7.有关矩阵秩的结论 (1) 秩$r(A)$=行秩=列秩； (2) $r(A_{m \\times n}) \\leq \\min(m,n);$ (3) $A \\neq 0 \\Rightarrow r(A) \\geq 1$； (4) $r(A \\pm B) \\leq r(A) + r(B);$ (5) 初等变换不改变矩阵的秩 (6) $r(A) + r(B) - n \\leq r(AB) \\leq \\min(r(A),r(B)),$特别若$AB = O$则：$r(A) + r(B) \\leq n$ (7) 若$A^{- 1}$存在$\\Rightarrow r(AB) = r(B);$ 若$B^{- 1}$存在$\\Rightarrow r(AB) = r(A);$ 若$r(A_{m \\times n}) = n \\Rightarrow r(AB) = r(B);$ 若$r(A_{m \\times s}) = n\\Rightarrow r(AB) = r\\left( A \\right)$。 (8) $r(A_{m \\times s}) = n \\Leftrightarrow Ax = 0$只有零解 8.分块求逆公式 $\\begin{pmatrix} A &amp; O \\ O &amp; B \\ \\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{-1} &amp; O \\ O &amp; B^{- 1} \\ \\end{pmatrix}$； $\\begin{pmatrix} A &amp; C \\ O &amp; B \\\\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{- 1}&amp; - A^{- 1}CB^{- 1} \\ O &amp; B^{- 1} \\ \\end{pmatrix}$； $\\begin{pmatrix} A &amp; O \\ C &amp; B \\ \\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{- 1}&amp;{O} \\ - B^{- 1}CA^{- 1} &amp; B^{- 1} \\\\end{pmatrix}$； $\\begin{pmatrix} O &amp; A \\ B &amp; O \\ \\end{pmatrix}^{- 1} =\\begin{pmatrix} O &amp; B^{- 1} \\ A^{- 1} &amp; O \\ \\end{pmatrix}$ 这里$A$，$B$均为可逆方阵。 向量1.有关向量组的线性表示 (1)$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性相关$\\Leftrightarrow$至少有一个向量可以用其余向量线性表示。 (2)$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$，$\\beta$线性相关$\\Leftrightarrow \\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$唯一线性表示。 (3) $\\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性表示$\\Leftrightarrow r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}) =r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s},\\beta)$ 。 2.有关向量组的线性相关性 (1)部分相关，整体相关；整体无关，部分无关. (2) ① $n$个$n$维向量$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{n}$线性无关$\\Leftrightarrow \\left|\\left\\lbrack \\alpha_{1}\\alpha_{2}\\cdots\\alpha_{n} \\right\\rbrack \\right| \\neq0$， $n$个$n$维向量$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{n}$线性相关$\\Leftrightarrow |\\lbrack\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}\\rbrack| = 0$。 ② $n + 1$个$n$维向量线性相关。 ③ 若$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{S}$线性无关，则添加分量后仍线性无关；或一组向量线性相关，去掉某些分量后仍线性相关。 3.有关向量组的线性表示 (1) $\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性相关$\\Leftrightarrow$至少有一个向量可以用其余向量线性表示。 (2) $\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$，$\\beta$线性相关$\\Leftrightarrow\\beta$ 可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$唯一线性表示。 (3) $\\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性表示$\\Leftrightarrow r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}) =r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s},\\beta)$ 4.向量组的秩与矩阵的秩之间的关系 设$r(A_{m \\times n}) =r$，则$A$的秩$r(A)$与$A$的行列向量组的线性相关性关系为： (1) 若$r(A_{m \\times n}) = r = m$，则$A$的行向量组线性无关。 (2) 若$r(A_{m \\times n}) = r &lt; m$，则$A$的行向量组线性相关。 (3) 若$r(A_{m \\times n}) = r = n$，则$A$的列向量组线性无关。 (4) 若$r(A_{m \\times n}) = r &lt; n$，则$A$的列向量组线性相关。 5.$\\mathbf{n}$维向量空间的基变换公式及过渡矩阵 若$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$与$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$是向量空间$V$的两组基，则基变换公式为： $(\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}) = (\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n})\\begin{bmatrix} c_{11}&amp; c_{12}&amp; \\cdots &amp; c_{1n} \\ c_{21}&amp; c_{22}&amp;\\cdots &amp; c_{2n} \\ \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\ c_{n1}&amp; c_{n2} &amp; \\cdots &amp; c_{ {nn} } \\\\end{bmatrix} = (\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n})C$ 其中$C$是可逆矩阵，称为由基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$到基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的过渡矩阵。 6.坐标变换公式 若向量$\\gamma$在基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$与基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的坐标分别是$X = {(x_{1},x_{2},\\cdots,x_{n})}^{T}$， $Y = \\left( y_{1},y_{2},\\cdots,y_{n} \\right)^{T}$ 即： $\\gamma =x_{1}\\alpha_{1} + x_{2}\\alpha_{2} + \\cdots + x_{n}\\alpha_{n} = y_{1}\\beta_{1} +y_{2}\\beta_{2} + \\cdots + y_{n}\\beta_{n}$，则向量坐标变换公式为$X = CY$ 或$Y = C^{- 1}X$，其中$C$是从基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$到基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的过渡矩阵。 7.向量的内积 $(\\alpha,\\beta) = a_{1}b_{1} + a_{2}b_{2} + \\cdots + a_{n}b_{n} = \\alpha^{T}\\beta = \\beta^{T}\\alpha$ 8.Schmidt正交化 若$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，则可构造$\\beta_{1},\\beta_{2},\\cdots,\\beta_{s}$使其两两正交，且$\\beta_{i}$仅是$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{i}$的线性组合$(i= 1,2,\\cdots,n)$，再把$\\beta_{i}$单位化，记$\\gamma_{i} =\\frac{\\beta_{i} }{\\left| \\beta_{i}\\right|}$，则$\\gamma_{1},\\gamma_{2},\\cdots,\\gamma_{i}$是规范正交向量组。其中$\\beta_{1} = \\alpha_{1}$， $\\beta_{2} = \\alpha_{2} -\\frac{(\\alpha_{2},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1}$ ， $\\beta_{3} =\\alpha_{3} - \\frac{(\\alpha_{3},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1} -\\frac{(\\alpha_{3},\\beta_{2})}{(\\beta_{2},\\beta_{2})}\\beta_{2}$ ， ………… $\\beta_{s} = \\alpha_{s} - \\frac{(\\alpha_{s},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1} - \\frac{(\\alpha_{s},\\beta_{2})}{(\\beta_{2},\\beta_{2})}\\beta_{2} - \\cdots - \\frac{(\\alpha_{s},\\beta_{s - 1})}{(\\beta_{s - 1},\\beta_{s - 1})}\\beta_{s - 1}$ 9.正交基及规范正交基 向量空间一组基中的向量如果两两正交，就称为正交基；若正交基中每个向量都是单位向量，就称其为规范正交基。 线性方程组1．克莱姆法则 线性方程组$\\begin{cases} a_{11}x_{1} + a_{12}x_{2} + \\cdots +a_{1n}x_{n} = b_{1} \\ a_{21}x_{1} + a_{22}x_{2} + \\cdots + a_{2n}x_{n} =b_{2} \\ \\quad\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots \\ a_{n1}x_{1} + a_{n2}x_{2} + \\cdots + a_{ {nn} }x_{n} = b_{n} \\ \\end{cases}$，如果系数行列式$D = \\left| A \\right| \\neq 0$，则方程组有唯一解，$x_{1} = \\frac{D_{1} }{D},x_{2} = \\frac{D_{2} }{D},\\cdots,x_{n} =\\frac{D_{n} }{D}$，其中$D_{j}$是把$D$中第$j$列元素换成方程组右端的常数列所得的行列式。 2. $n$阶矩阵$A$可逆$\\Leftrightarrow Ax = 0$只有零解。$\\Leftrightarrow\\forall b,Ax = b$总有唯一解，一般地，$r(A_{m \\times n}) = n \\Leftrightarrow Ax= 0$只有零解。 3.非奇次线性方程组有解的充分必要条件，线性方程组解的性质和解的结构 (1) 设$A$为$m \\times n$矩阵，若$r(A_{m \\times n}) = m$，则对$Ax =b$而言必有$r(A) = r(A \\vdots b) = m$，从而$Ax = b$有解。 (2) 设$x_{1},x_{2},\\cdots x_{s}$为$Ax = b$的解，则$k_{1}x_{1} + k_{2}x_{2}\\cdots + k_{s}x_{s}$当$k_{1} + k_{2} + \\cdots + k_{s} = 1$时仍为$Ax =b$的解；但当$k_{1} + k_{2} + \\cdots + k_{s} = 0$时，则为$Ax =0$的解。特别$\\frac{x_{1} + x_{2} }{2}$为$Ax = b$的解；$2x_{3} - (x_{1} +x_{2})$为$Ax = 0$的解。 (3) 非齐次线性方程组${Ax} = b$无解$\\Leftrightarrow r(A) + 1 =r(\\overline{A}) \\Leftrightarrow b$不能由$A$的列向量$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$线性表示。 4.奇次线性方程组的基础解系和通解，解空间，非奇次线性方程组的通解 (1) 齐次方程组${Ax} = 0$恒有解(必有零解)。当有非零解时，由于解向量的任意线性组合仍是该齐次方程组的解向量，因此${Ax}= 0$的全体解向量构成一个向量空间，称为该方程组的解空间，解空间的维数是$n - r(A)$，解空间的一组基称为齐次方程组的基础解系。 (2) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$是${Ax} = 0$的基础解系，即： 1) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$是${Ax} = 0$的解； 2) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$线性无关； 3) ${Ax} = 0$的任一解都可以由$\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$线性表出.$k_{1}\\eta_{1} + k_{2}\\eta_{2} + \\cdots + k_{t}\\eta_{t}$是${Ax} = 0$的通解，其中$k_{1},k_{2},\\cdots,k_{t}$是任意常数。 矩阵的特征值和特征向量1.矩阵的特征值和特征向量的概念及性质 (1) 设$\\lambda$是$A$的一个特征值，则 ${kA},{aA} + {bE},A^{2},A^{m},f(A),A^{T},A^{- 1},A^{*}$有一个特征值分别为${kλ},{aλ} + b,\\lambda^{2},\\lambda^{m},f(\\lambda),\\lambda,\\lambda^{- 1},\\frac{|A|}{\\lambda},$且对应特征向量相同（$A^{T}$ 例外）。 (2)若$\\lambda_{1},\\lambda_{2},\\cdots,\\lambda_{n}$为$A$的$n$个特征值，则$\\sum_{i= 1}^{n}\\lambda_{i} = \\sum_{i = 1}^{n}a_{ {ii} },\\prod_{i = 1}^{n}\\lambda_{i}= |A|$ ,从而$|A| \\neq 0 \\Leftrightarrow A$没有特征值。 (3)设$\\lambda_{1},\\lambda_{2},\\cdots,\\lambda_{s}$为$A$的$s$个特征值，对应特征向量为$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$， 若: $\\alpha = k_{1}\\alpha_{1} + k_{2}\\alpha_{2} + \\cdots + k_{s}\\alpha_{s}$ , 则: $A^{n}\\alpha = k_{1}A^{n}\\alpha_{1} + k_{2}A^{n}\\alpha_{2} + \\cdots +k_{s}A^{n}\\alpha_{s} = k_{1}\\lambda_{1}^{n}\\alpha_{1} +k_{2}\\lambda_{2}^{n}\\alpha_{2} + \\cdots k_{s}\\lambda_{s}^{n}\\alpha_{s}$ 。 2.相似变换、相似矩阵的概念及性质 (1) 若$A \\sim B$，则 1) $A^{T} \\sim B^{T},A^{- 1} \\sim B^{- 1},,A^{} \\sim B^{}$ 2) $|A| = |B|,\\sum_{i = 1}^{n}A_{ {ii} } = \\sum_{i =1}^{n}b_{ {ii} },r(A) = r(B)$ 3) $|\\lambda E - A| = |\\lambda E - B|$，对$\\forall\\lambda$成立 3.矩阵可相似对角化的充分必要条件 (1)设$A$为$n$阶方阵，则$A$可对角化$\\Leftrightarrow$对每个$k_{i}$重根特征值$\\lambda_{i}$，有$n-r(\\lambda_{i}E - A) = k_{i}$ (2) 设$A$可对角化，则由$P^{- 1}{AP} = \\Lambda,$有$A = {PΛ}P^{-1}$，从而$A^{n} = P\\Lambda^{n}P^{- 1}$ (3) 重要结论 1) 若$A \\sim B,C \\sim D​$，则$\\begin{bmatrix} A &amp; O \\ O &amp; C \\\\end{bmatrix} \\sim \\begin{bmatrix} B &amp; O \\ O &amp; D \\\\end{bmatrix}​$. 2) 若$A \\sim B$，则$f(A) \\sim f(B),\\left| f(A) \\right| \\sim \\left| f(B)\\right|$，其中$f(A)$为关于$n$阶方阵$A$的多项式。 3) 若$A$为可对角化矩阵，则其非零特征值的个数(重根重复计算)＝秩($A$) 4.实对称矩阵的特征值、特征向量及相似对角阵 (1)相似矩阵：设$A,B$为两个$n$阶方阵，如果存在一个可逆矩阵$P$，使得$B =P^{- 1}{AP}$成立，则称矩阵$A$与$B$相似，记为$A \\sim B$。 (2)相似矩阵的性质：如果$A \\sim B$则有： 1) $A^{T} \\sim B^{T}$ 2) $A^{- 1} \\sim B^{- 1}$ （若$A$，$B$均可逆） 3) $A^{k} \\sim B^{k}$ （$k$为正整数） 4) $\\left| {λE} - A \\right| = \\left| {λE} - B \\right|$，从而$A,B$有相同的特征值 5) $\\left| A \\right| = \\left| B \\right|$，从而$A,B$同时可逆或者不可逆 6) 秩$\\left( A \\right) =$秩$\\left( B \\right),\\left| {λE} - A \\right| =\\left| {λE} - B \\right|$，$A,B$不一定相似 二次型1.$\\mathbf{n}$个变量$\\mathbf{x}{\\mathbf{1} }\\mathbf{,}\\mathbf{x}{\\mathbf{2} }\\mathbf{,\\cdots,}\\mathbf{x}_{\\mathbf{n} }$的二次齐次函数 $f(x_{1},x_{2},\\cdots,x_{n}) = \\sum_{i = 1}^{n}{\\sum_{j =1}^{n}{a_{ {ij} }x_{i}y_{j} } }$，其中$a_{ {ij} } = a_{ {ji} }(i,j =1,2,\\cdots,n)$，称为$n$元二次型，简称二次型. 若令$x = \\ \\begin{bmatrix}x_{1} \\ x_{1} \\ \\vdots \\ x_{n} \\ \\end{bmatrix},A = \\begin{bmatrix} a_{11}&amp; a_{12}&amp; \\cdots &amp; a_{1n} \\ a_{21}&amp; a_{22}&amp; \\cdots &amp; a_{2n} \\ \\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\ a_{n1}&amp; a_{n2} &amp; \\cdots &amp; a_{ {nn} } \\\\end{bmatrix}$,这二次型$f$可改写成矩阵向量形式$f =x^{T}{Ax}$。其中$A$称为二次型矩阵，因为$a_{ {ij} } =a_{ {ji} }(i,j =1,2,\\cdots,n)$，所以二次型矩阵均为对称矩阵，且二次型与对称矩阵一一对应，并把矩阵$A$的秩称为二次型的秩。 2.惯性定理，二次型的标准形和规范形 (1) 惯性定理 对于任一二次型，不论选取怎样的合同变换使它化为仅含平方项的标准型，其正负惯性指数与所选变换无关，这就是所谓的惯性定理。 (2) 标准形 二次型$f = \\left( x_{1},x_{2},\\cdots,x_{n} \\right) =x^{T}{Ax}$经过合同变换$x = {Cy}$化为$f = x^{T}{Ax} =y^{T}C^{T}{AC}$ $y = \\sum_{i = 1}^{r}{d_{i}y_{i}^{2} }$称为 $f(r \\leq n)$的标准形。在一般的数域内，二次型的标准形不是唯一的，与所作的合同变换有关，但系数不为零的平方项的个数由$r(A)$唯一确定。 (3) 规范形 任一实二次型$f$都可经过合同变换化为规范形$f = z_{1}^{2} + z_{2}^{2} + \\cdots z_{p}^{2} - z_{p + 1}^{2} - \\cdots -z_{r}^{2}$，其中$r$为$A$的秩，$p$为正惯性指数，$r -p$为负惯性指数，且规范型唯一。 3.用正交变换和配方法化二次型为标准形，二次型及其矩阵的正定性 设$A$正定$\\Rightarrow {kA}(k &gt; 0),A^{T},A^{- 1},A^{*}$正定；$|A| &gt;0$,$A$可逆；$a_{ {ii} } &gt; 0$，且$|A_{ {ii} }| &gt; 0$ $A$，$B$正定$\\Rightarrow A +B$正定，但${AB}$，${BA}$不一定正定 $A$正定$\\Leftrightarrow f(x) = x^{T}{Ax} &gt; 0,\\forall x \\neq 0$ $\\Leftrightarrow A$的各阶顺序主子式全大于零 $\\Leftrightarrow A$的所有特征值大于零 $\\Leftrightarrow A$的正惯性指数为$n$ $\\Leftrightarrow$存在可逆阵$P$使$A = P^{T}P$ $\\Leftrightarrow$存在正交矩阵$Q$，使$Q^{T}{AQ} = Q^{- 1}{AQ} =\\begin{pmatrix} \\lambda_{1} &amp; &amp; \\ \\begin{matrix} &amp; \\ &amp; \\ \\end{matrix} &amp;\\ddots &amp; \\ &amp; &amp; \\lambda_{n} \\ \\end{pmatrix},$ 其中$\\lambda_{i} &gt; 0,i = 1,2,\\cdots,n.$正定$\\Rightarrow {kA}(k &gt;0),A^{T},A^{- 1},A^{*}$正定； $|A| &gt; 0,A$可逆；$a_{ {ii} } &gt;0$，且$|A_{ {ii} }| &gt; 0$ 。","link":"/2018/12/03/2018-12-03-线性代数基础/"},{"title":"数据结构","text":"以下数据结构均采用ll作为值类型，应用时根据需求调整。 123typedef long long ll;const ll INF = 1e9; //表示（值）正无穷，且两个正无穷相加不会溢出const int NPOS = -1; //表示（下标）不存在 离散化在vector基础上的离散化，使用push_back()向其中插值，init()排序并离散化，ask查询离散化之后的值，at/[]运算符查离散前的值。 12345struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }}; 并查集1234567891011121314struct UnionfindSet : vector&lt;int&gt;{ UnionfindSet(int n) : vector&lt;int&gt;(n) { for (int i = 0; i &lt; n; ++i) at(i) = i; } void merge(int u, int w) { if (w = ask(w), u = ask(u), w != u) at(w) = u; } int ask(int u) { return at(u) != u ? at(u) = ask(at(u)) : u; }}; 单调队列和单调栈使用示例 1234567891011typedef pair&lt;int, ll&gt; pil;struct Monotone : deque&lt;pil&gt;{ void push(const pil &amp;p, int k) { while (!empty() &amp;&amp; back().second &gt;= p.second) pop_back(); for (push_back(p); p.first - front().first &gt;= k;) pop_front(); }}; ST表使用示例 $O(n\\log n)$预处理，$O(1)$求静态区间最小值。 123456789101112131415161718192021222324252627/*//可选优化#define log2(n) LOG2[n]struct Log : vector&lt;ll&gt;{ Log(int N, ll E) : vector&lt;ll&gt;(N, -1) { for (int i = 1; i &lt; N; ++i) at(i) = at(i / E) + 1; }} LOG2(N, 2);*/struct SparseTable{ vector&lt;vector&lt;ll&gt;&gt; f; SparseTable(const vector&lt;ll&gt; &amp;a) : f(log2(a.size()) + 1, a) { for (int k = 0; k + 1 &lt; f.size(); ++k) for (int i = 0; i + (1 &lt;&lt; k) &lt; a.size(); ++i) f[k + 1][i] = min(f[k][i], f[k][i + (1 &lt;&lt; k)]); } ll ask(int l, int r) { int k = log2(r - l + 1); return min(f[k][l], f[k][r + 1 - (1 &lt;&lt; k)]); }}; 树状数组模板中Base是对应的基础版本，支持单点修改区间查询。 一维1234567891011121314151617181920212223242526struct Fenwick{ struct BaseFenwick { vector&lt;ll&gt; v; BaseFenwick(int n) : v(n, 0) {} void add(int x, ll w) { for (; x &lt; v.size(); x += x &amp; -x) v[x] += w; } ll ask(int x) { ll ans = 0; for (; x; x -= x &amp; -x) ans += v[x]; return ans; } }; pair&lt;BaseFenwick, BaseFenwick&gt; p; Fenwick(int n) : p(n, n) {} void add(int x, ll w) { p.first.add(x, w), p.second.add(x, x * w); } void add(int l, int r, ll w) { add(l, w), add(r + 1, -w); } ll ask(int x) { return (x + 1) * p.first.ask(x) - p.second.ask(x); } ll ask(int l, int r) { return ask(r) - ask(l - 1); }}; 二维高维的数据结构只要每一维维护低一维的数据（树套树）即可。其余数据结构亦同理。 1234567891011121314151617181920212223242526struct Fenwick2{ struct BaseFenwick2 { vector&lt;Fenwick&gt; v; BaseFenwick2(int r, int c) : v(r, c) {} void add(int x, int b, int t, ll w) { for (; x &lt; v.size(); x += x &amp; -x) v[x].add(b, t, w); } ll ask(int x, int b, int t) { ll ans = 0; for (; x; x -= x &amp; -x) ans += v[x].ask(b, t); return ans; } }; pair&lt;BaseFenwick2, BaseFenwick2&gt; p; Fenwick2(int r, int c) : p(BaseFenwick2(r, c), BaseFenwick2(r, c)) {} void add(int x, int b, int t, ll w) { p.first.add(x, b, t, w), p.second.add(x, b, t, x * w); } void add(int l, int b, int r, int t, ll w) { add(l, b, t, w), add(r + 1, b, t, -w); } //(l,b)~(r,t) ll ask(int x, int b, int t) { return (x + 1) * p.first.ask(x, b, t) - p.second.ask(x, b, t); } ll ask(int l, int b, int r, int t) { return ask(r, b, t) - ask(l - 1, b, t); }}; 动态开点线段树使用示例，支持区间线性变换、区间查询（最大值最小值区间和）。 这样写改主席树也很方便，只要改down函数为每次都新建节点即可，示例。 undefined 无旋Treap按子树大小分裂使用示例 undefined 按值大小分裂使用示例，即排序树。 undefined 莫队使用示例 123456789101112131415161718192021222324252627282930313233struct Mo{ struct Query { int l, r, id; bool operator&lt;(const Query &amp;n) const { return l / BS != n.l / BS ? l &lt; n.l : r &lt; n.r; } }; vector&lt;Query&gt; q; int L, R; void query(int l, int r) { q.push_back(Query{l, r, q.size()}); } void rev(int x) {} void cal(int id) {} void ask() { L = 0, R = -1; sort(q.begin(), q.end()); for (int i = 0; i &lt; q.size(); ++i) { while (L &lt; q[i].l) rev(L++); while (L &gt; q[i].l) rev(--L); while (R &lt; q[i].r) rev(++R); while (R &gt; q[i].r) rev(R--); cal(q[i].id); } }}; 带修莫队使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct Mo{ struct Update { int pos, NEW, OLD; }; struct Query { int t, l, r, id; bool operator&lt;(const Query &amp;n) const { return l / BS != n.l / BS ? l &lt; n.l : r / BS != n.r / BS ? r &lt; n.r : t &lt; n.t; } }; vector&lt;Update&gt; cq; vector&lt;Query&gt; q; int T, L, R; Mo() : cq(1) {} void query(int x, int y) { q.push_back(Query{cq.size() - 1, x, y, q.size()}); } void update(int x, int y) { cq.push_back(Update{x, y, t[x]}), t[x] = y; } void set(int x, int d) { if (vis[x]) return rev(x), a[x] = d, rev(x); a[x] = d; } void rev(int x) {} void cal(int id) {} void ask() { T = L = 0, R = -1; sort(q.begin(), q.end()); for (int i = 0; i &lt; q.size(); ++i) { while (T &lt; q[i].t) ++T, set(cq[T].pos, cq[T].NEW); while (T &gt; q[i].t) set(cq[T].pos, cq[T].OLD), --T; while (L &lt; q[i].l) rev(L++); while (L &gt; q[i].l) rev(--L); while (R &lt; q[i].r) rev(++R); while (R &gt; q[i].r) rev(R--); cal(q[i].id); } }}; 树上莫队使用示例 按照欧拉序分块，使用Tarjan在生成欧拉序的同时预处理所有询问的lca，预处理时间复杂度$O(n+q)$。h为查询图，即如果有一个询问(u,v)，即在h上连$u\\to v,v\\to u$。多个询问边有序插入h。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061struct TreeMo : Graph{ struct Query { int l, r, lca, id; bool operator&lt;(const Query &amp;b) const { return l / BS != b.l / BS ? l &lt; b.l : r &lt; b.r; } }; vector&lt;Query&gt; q; vector&lt;int&gt; dfp, dfi, dfo; UnionFindSet ufs; Graph h; int L, R; TreeMo(int n) : Graph(n), h(n), dfp(n * 2 + 1), dfi(n), dfo(n), ufs(n) {} void query(int x, int y) { h.add(Edge{x, y}), h.add(Edge{y, x}); q.push_back(Query{0, 0, 0, q.size()}); } void rev(int x) {} void cal(int id) {} void dfs(int u, int &amp;cnt) { dfp[dfi[u] = ++cnt] = u; for (int i = 0, k, to; i &lt; v[u].a.size(); ++i) if (k = v[u].a[i], to = e[k].second, !dfi[to]) dfs(to, cnt), ufs.merge(u, to); dfp[dfo[u] = ++cnt] = u; for (int i = 0, k, to, id; i &lt; h.v[u].a.size(); ++i) if (k = h.v[u].a[i], id = k / 2, to = h.e[k].second, dfo[to]) { q[id].lca = ufs.fa(to); q[id].l = q[id].lca != u ? dfo[u] : dfi[u]; q[id].r = dfi[to]; } } void ask(int root = 1) { dfs(root, BS = 0), BS = sqrt(BS); sort(q.begin(), q.end()); L = 0, R = -1; for (int i = 0; i &lt; q.size(); ++i) { while (L &lt; q[i].l) rev(dfp[L++]); while (L &gt; q[i].l) rev(dfp[--L]); while (R &lt; q[i].r) rev(dfp[++R]); while (R &gt; q[i].r) rev(dfp[R--]); if (q[i].lca != dfp[L]) rev(q[i].lca); cal(q[i].id); if (q[i].lca != dfp[L]) rev(q[i].lca); } }}; 树上带修莫队使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980struct CapitalTreeMo : Graph{ struct Update { int pos, NEW, OLD; }; struct Query { int t, l, r, lca, id; bool operator&lt;(const Query &amp;b) const { return l / BS != b.l / BS ? l &lt; b.l : r / BS != b.r / BS ? r &lt; b.r : t &lt; b.t; //在BZOJ4129上去掉r/BS还快100ms? } }; vector&lt;Update&gt; cq; vector&lt;Query&gt; q; vector&lt;int&gt; dfp, dfi, dfo; UnionFindSet ufs; Graph h; int T, L, R; CapitalTreeMo(int n) : cq(1), Graph(n), h(n), dfp(n * 2 + 1), dfi(n), dfo(n), ufs(n) {} void query(int x, int y) { h.add(Edge{x, y}), h.add(Edge{y, x}); q.push_back(Query{cq.size() - 1, 0, 0, 0, q.size()}); } void update(int x, int y) { cq.push_back(Update{x, y, t[x]}), t[x] = y; } void dfs(int u, int &amp;cnt) { dfp[dfi[u] = ++cnt] = u; for (int i = 0, k, to; i &lt; v[u].a.size(); ++i) if (k = v[u].a[i], to = e[k].second, !dfi[to]) dfs(to, cnt), ufs.merge(u, to); dfp[dfo[u] = ++cnt] = u; for (int i = 0, k, to, id; i &lt; h.v[u].a.size(); ++i) if (k = h.v[u].a[i], id = k / 2, to = h.e[k].second, dfo[to]) { q[id].lca = ufs.fa(to); q[id].l = q[id].lca != u ? dfo[u] : dfi[u]; q[id].r = dfi[to]; } } void set(int u, int d) { if (vis[u]) return rev(u), a[u] = d, rev(u); a[u] = d; } void rev(int u) {} void cal(int id) {} void ask(int root = 1) { dfs(root, BS = 0), BS = sqrt(BS); sort(q.begin(), q.end()); T = L = 0, R = -1; for (int i = 0; i &lt; q.size(); ++i) { while (T &lt; q[i].t) ++T, set(cq[T].pos, cq[T].NEW); while (T &gt; q[i].t) set(cq[T].pos, cq[T].OLD), --T; while (L &lt; q[i].l) rev(dfp[L++]); while (L &gt; q[i].l) rev(dfp[--L]); while (R &lt; q[i].r) rev(dfp[++R]); while (R &gt; q[i].r) rev(dfp[R--]); if (q[i].lca != dfp[L]) rev(q[i].lca); cal(q[i].id); if (q[i].lca != dfp[L]) rev(q[i].lca); } }}; 字符串/模式匹配HashString使用示例，如果要修改模数或者直接使用unsigned long long的自然溢出的话直接修改Mod即可。 使用unsigned long long的自然溢出快了5倍，但是容易被卡。 12345678910111213struct HashString : Mod{ vector&lt;ll&gt; f, p; HashString(const string &amp;s, ll M = 1e9 + 7, ll P = 131) : Mod(M), f(s.size() + 1), p(s.size() + 1, 1) { for (int i = 0; i &lt; s.size(); ++i) { f[i + 1] = add(mul(f[i], P), s[i]); p[i + 1] = mul(p[i], P); } } ll ask(int pos, int len) { return add(f[pos + len], -mul(f[pos], p[len])); } //从pos位置开始的长度为len的子串的hash值}; KMP123456789101112131415161718192021222324252627struct KMP{ const string s; vector&lt;int&gt; next; KMP(const string &amp;s) : s(s), next(s.size() + 1, 0) { for (int i = 1, j; i &lt; s.size(); ++i) { for (j = next[i]; j &amp;&amp; s[i] != s[j];) j = next[j]; next[i + 1] = s[i] == s[j] ? j + 1 : 0; } } bool find_in(const string &amp;t) { for (int i = 0, j = 0; i &lt; t.size(); ++i) { while (j &amp;&amp; s[j] != t[i]) j = next[j]; if (s[j] == t[i]) ++j; if (j == s.size()) return 1; //不return可得到t中s的所有匹配地址i+1-s.size() } return 0; }}; AC自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct AhoCorasick{ struct Node { int ch[26], val, f, last; int &amp;to(char c) { return ch[c - 'a']; } //如果不确定c的范围，使用map }; vector&lt;Node&gt; v; AhoCorasick() : v(1) {} void getFail() { for (deque&lt;int&gt; q(1, v[0].last = v[0].f = 0); !q.empty(); q.pop_front()) for (char c = 'a'; c &lt;= 'z'; ++c) { int r = q.front(), u = v[r].to(c), w = v[r].f; if (!r &amp;&amp; u) { q.push_back(u); v[u].f = v[u].last = 0; continue; } if (!u) { v[r].to(c) = v[w].to(c); continue; } q.push_back(u); while (w &amp;&amp; !v[w].to(c)) w = v[w].f; v[u].f = v[w].to(c); v[u].last = v[v[u].f].val ? v[u].f : v[v[u].f].last; } } void add(const string &amp;s, int val, int u = 0) { for (int i = 0; i &lt; s.size(); u = v[u].to(s[i++])) if (!v[u].to(s[i])) { v[u].to(s[i]) = v.size(); v.push_back(Node()); } v[u].val = val; } bool find_in(const string &amp;s, int u = 0) //调用需要调用`getFail()`生成失配函数。 { for (int i = 0; i &lt; s.size(); ++i) if (u = v[u].to(s[i]), v[u].val || v[u].last) return 1; return 0; }}; 暴力回文使用示例 时间复杂度$O(n^2)$，常数低，但会被ababababa这样的数据卡。 1234567891011121314int palindrome(const char *s){ int ans = 0; for (int i = 0, b, e; s[i]; ++i) { for (b = i; s[i] == s[i + 1];) ++i; for (e = i + 1; b &amp;&amp; s[b - 1] == s[e];) --b, ++e; if (ans &lt; e - b) ans = e - b; //此时[b,e)为最大回文区间 } return ans;} 线性回文使用示例 对于一个位置i，[i−f[i]+1,i+f[i]−1]是最长的以i为中心的奇回文串，g[i]−i是最长的以i为开头的回文串长度。 1234567891011121314151617181920212223242526272829303132struct Manacher{ vector&lt;int&gt; t, f, g; Manacher(const string &amp;s) : t(s.size() + 1 &lt;&lt; 1, 0), f(t), g(t) //t初始值为s中没有出现过的值，g开始为0 { for (int i = 0; i &lt; s.size(); ++i) t[i + 1 &lt;&lt; 1] = s[i]; for (int i = 1, p = 0, m = 0; i &lt; t.size(); ++i) { for (f[i] = i &lt; m ? min(f[2 * p - i], m - i) : 1; 0 &lt; i - f[i] &amp;&amp; i + f[i] &lt; t.size() &amp;&amp; t[i - f[i]] == t[i + f[i]];) ++f[i]; if (m &lt; i + f[i]) m = i + f[p = i]; } for (int i = 2; i &lt; t.size(); ++i) if (g[i - f[i] + 1] &lt; i + 1) g[i - f[i] + 1] = i + 1; for (int i = 1; i &lt; t.size(); ++i) if (g[i] &lt; g[i - 1]) g[i] = g[i - 1]; } int ask(int l, int r) //多次询问可做一个ST表 { int ans = 0; for (int i = l + 1 &lt;&lt; 1, e = r + 1 &lt;&lt; 1; i &lt;= e; i += 2) if (ans &lt; g[i] - i) ans = g[i] - i; return ans; }}; 后缀自动机使用示例 m：字符集大小。 s：字符串，其中最后一位为加入的0。 sa[i]：字典序第i小的是哪个后缀。 rk[i]：后缀i的排名。 h[i]：lcp(sa[i],sa[i−1])。 12345678910111213141516171819202122232425262728293031323334struct SufArr{ vector&lt;int&gt; sa, rk, h; SufArr(const vector&lt;int&gt; &amp;s, int m) : sa(s.size(), 0), rk(s), h(s.size(), 0) { vector&lt;int&gt; cnt(s.size() + m, 0); for (int i = 0; i &lt; s.size(); ++i) ++cnt[rk[i]]; for (int i = 1; i &lt; m; ++i) cnt[i] += cnt[i - 1]; for (int i = 0; i &lt; s.size(); ++i) sa[--cnt[rk[i]]] = i; for (int k = 1, j = 0; k &lt;= s.size() &amp;&amp; j &lt; s.size() - 1; k &lt;&lt;= 1) { for (int i = 0; i &lt; s.size(); ++i) { if (j = sa[i] - k, j &lt; 0) j += s.size(); h[cnt[rk[j]]++] = j; } cnt[0] = sa[h[0]] = j = 0; for (int i = 1; i &lt; s.size(); ++i) { if (rk[h[i]] != rk[h[i - 1]] || rk[h[i] + k] != rk[h[i - 1] + k]) cnt[++j] = i; sa[h[i]] = j; } swap(rk, sa), swap(sa, h); } for (int i = 0, k = 0, j = rk[0]; i &lt; s.size() - 1; ++i, ++k) for (; ~k &amp;&amp; s[i] != s[sa[j - 1] + k]; j = rk[sa[j] + 1], --k) h[j] = k; }};","link":"/2019/02/03/2019-02-03-数据结构/"},{"title":"计算几何","text":"二维点和向量化为坐标Coord进行运算，使用stl中的complex实现。 复数相乘的几何意义为长度相乘，极角相加。 用直线上的一点p和方向向量v表示一条经过p的直线，直线上的所有点q满足q=p+t*v，其中t是参数；当限制t≥0时，该参数方程表示射线；限制0≤t≤1时，该参数方程表示线段。 此外，如果已知线段端点a1和a2，可以通过Line(a1,a2-a1)来得到对应的参数形式。 Morley定理：三角形每个内角的三等分线相交成等边三角形。 欧拉定理：平面图的点数V、边数E和面数F满足V+F-E=2。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370typedef double lf;typedef complex&lt;lf&gt; Coord;const lf EPS = 1e-9, PI = acos(-1);#define X real()#define Y imag()struct Line{ Coord p, v; Line(Coord p = Coord(), Coord v = Coord()) : p(p), v(v) {} Coord point(lf t) const { return p + v * t; }};struct Circle{ Coord c; lf r; Circle(Coord c = Coord(), lf r = 0) : c(c), r(r) {} Coord point(lf t) const { return c + polar(r, t); } //t为参数，幅角};/*Coord(lf x=0,lf y=0);//构造函数lf real(Coord a);//a的实部（复平面的横坐标）,也可写作a.real()lf imag(Coord a);//a的虚部（复平面的纵坐标）,也可写作a.imag()lf abs(Coord a);//向量a的模长，或是点a到原点的距离lf norm(Coord a);//abs的平方，比abs快，但是要注意浮点数精度溢出lf arg(Coord a);//a的幅角，与atan2(a.real(),a.imag())等价Coord polar(lf r,lf t);//极坐标生成方式，r为幅值，t为幅角//运算符重载+、-、*、/（以及对应的赋值运算，但是赋值运算不能写在表达式中，详见参考地址）、&lt;&lt;、&gt;&gt;（输出括号形式的坐标）*/int sgn(lf d) { return (d &gt; EPS) - (d &lt; -EPS); }bool operator!=(const Coord &amp;A, const Coord &amp;B) { return sgn(A.X - B.X) || sgn(A.Y - B.Y); } //不等运算符，涉及到浮点数比较要重写bool operator==(const Coord &amp;A, const Coord &amp;B) { return !(A != B); }bool cmpCoord(const Coord &amp;A, const Coord &amp;B) { return sgn(A.X - B.X) ? sgn(A.X - B.X) &lt; 0 : sgn(A.Y - B.Y) &lt; 0; } //复数没有小于运算，只能这样定义一个比较函数bool cmpLine(const Line &amp;A, const Line &amp;B) { return sgn(arg(A.v) - arg(B.v)) &lt; 0; } //按极角排序，求凸包中使用lf Dot(const Coord &amp;A, const Coord &amp;B) { return A.X * B.X + A.Y * B.Y; }lf Cross(const Coord &amp;A, const Coord &amp;B) { return A.X * B.Y - B.X * A.Y; }lf Angle(const Coord &amp;A, const Coord &amp;B) { return acos(Dot(A, B) / abs(A) / abs(B)); }lf Area2(const Coord &amp;A, const Coord &amp;B, const Coord &amp;C) { return Cross(B - A, C - A); } //三角形ABC有向面积的两倍Coord Rotate(const Coord &amp;A, lf rad) { return A * polar(1.0, rad);} //向量A逆时针旋转rad弧度Coord Normal(const Coord &amp;A) //A的法向量，把A逆时针旋转九十度并长度化为1{ lf L = abs(A); return Coord(-A.Y / L, A.X / L);}bool onLeft(const Coord &amp;P, const Line &amp;L) { return sgn(Cross(L.v, P - L.p)) &gt; 0; } //p是否在有向直线L左侧，不含线上lf DistanceToLine(const Coord &amp;P, const Line &amp;L) { return Cross(L.v, P - L.p) / abs(L.v); } //点到直线距离（有向）lf DistanceToLine(const Coord &amp;P, const Coord &amp;A, const Coord &amp;B) { return DistanceToLine(P, Line(A, B - A)); }lf DistanceToSegment(const Coord &amp;P, const Coord &amp;A, const Coord &amp;B) //点到线段的距离（无向）{ if (A == B) return abs(P - A); Coord v1 = B - A, v2 = P - A, v3 = P - B; if (sgn(Dot(v1, v2)) &lt; 0) return abs(v2); if (sgn(Dot(v1, v3)) &gt; 0) return abs(v3); return fabs(DistanceToLine(P, Line(A, B - A)));}Coord getLineProjection(const Coord &amp;P, const Line &amp;L) { return L.point(Dot(L.v, P - L.p) / norm(L.v)); } //点在直线上的投影Coord getLineProjection(const Coord &amp;P, const Coord &amp;A, const Coord &amp;B) { return getLineProjection(P, Line(A, B - A)); }Coord getSymmetry(const Coord &amp;P, const Coord &amp;O) { return O + O - P; } //P关于O的对称点Coord getSymmetry(const Coord &amp;P, const Line &amp;L) { return getSymmetry(P, getLineProjection(P, L)); } //P关于L的对称点Coord getLineIntersection(const Line &amp;L1, const Line &amp;L2) { return L1.point(Cross(L2.v, L1.p - L2.p) / Cross(L1.v, L2.v)); } //直线交点,须确保两直线相交Coord getLineIntersection(const Coord &amp;A1, const Coord &amp;A2, const Coord &amp;B1, const Coord &amp;B2) { return getLineIntersection(Line(A1, A2 - A1), Line(B1, B2 - B1)); }bool SegmentProperIntersection(const Coord &amp;A1, const Coord &amp;A2, const Coord &amp;B1, const Coord &amp;B2) //线段相交判定，交点不在一条线段的端点{ lf C1 = Cross(A2 - A1, B1 - A1), C2 = Cross(A2 - A1, B2 - A1), C3 = Cross(B2 - B1, A1 - B1), C4 = Cross(B2 - B1, A2 - B1); return sgn(C1) * sgn(C2) &lt; 0 &amp;&amp; sgn(C3) * sgn(C4) &lt; 0;}bool onSegment(const Coord &amp;P, const Coord &amp;A1, const Coord &amp;A2) { return sgn(Dot(A1 - P, A2 - P)) &lt; 0 &amp;&amp; !sgn(Cross(A1 - P, A2 - P)); } //判断点是否在线段上，不包含端点lf PolygonArea(const vector&lt;Coord&gt; &amp;p) //计算多边形的有向面积，凸多边形即为面积{ lf s = 0; for (int i = 2; i &lt; p.size(); ++i) s += Area2(p[0], p[i - 1], p[i]); return s / 2;}int inPolygon(const Coord &amp;p, const vector&lt;Coord&gt; &amp;poly) //点在多边形内的判定，转角法，正值为内部，0为外部，-1在边界上{ int ans = 0; for (int i = 0, k, d1, d2, n = poly.size(); i != n; ++i) { if (onSegment(p, poly[i], poly[(i + 1) % n])) return -1; //在边界上 k = sgn(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); d1 = sgn(poly[i].Y - p.Y); d2 = sgn(poly[(i + 1) % n].Y - p.Y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) ++ans; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) --ans; } return ans;}vector&lt;Coord&gt; ConvexHull(vector&lt;Coord&gt; p, int collineation = 1) //获得凸包，不希望凸包的边上有输入点第二个参数传0{ vector&lt;Coord&gt; ans; sort(p.begin(), p.end(), cmpCoord); //先比横坐标再比纵坐标 for (int i = 0; i &lt; p.size(); ++i) //求出下凸包 { while (ans.size() &gt; 1 &amp;&amp; sgn(Area2(ans[ans.size() - 2], ans[ans.size() - 1], p[i])) &lt; collineation) ans.pop_back(); ans.push_back(p[i]); } for (int i = p.size() - 2, k = ans.size(); i &gt;= 0; --i) //求出上凸包 { while (ans.size() &gt; k &amp;&amp; -sgn(Area2(ans[ans.size() - 1], ans[ans.size() - 2], p[i])) &lt; collineation) ans.pop_back(); ans.push_back(p[i]); } if (p.size() &gt; 1) ans.pop_back(); return ans;}vector&lt;Coord&gt; cutPolygon(const vector&lt;Coord&gt; &amp;poly, const Coord &amp;A, const Coord &amp;B) //用有向直线A-&gt;B切割多边形poly， 返回“左侧”。 如果退化，可能会返回一个单点或者线段，复杂度O(n^2){ vector&lt;Coord&gt; newpoly; for (int i = 0, n = poly.size(); i != n; ++i) { Coord C = poly[i], D = poly[(i + 1) % n]; if (sgn(Cross(B - A, C - A)) &gt;= 0) newpoly.push_back(C); if (!sgn(Cross(B - A, C - D))) { Coord ip = getLineIntersection(Line(A, B - A), Line(C, D - C)); if (onSegment(ip, C, D)) newpoly.push_back(ip); } } return newpoly;}vector&lt;Coord&gt; getHalfPlaneIntersection(vector&lt;Line&gt; L) //半平面交{ sort(L.begin(), L.end(), cmpLine); //按极角排序 vector&lt;Coord&gt; p(L.size(), Coord()); //p[i]为q[i]和q[i+1]的交点 int first = 0, last = 0; //双端队列的第一个元素和最后一个元素 vector&lt;Line&gt; q(L.size(), Line()); //双端队列 q[0] = L[0]; //队列初始化为只有一个半平面L[0] for (int i = 0, n = L.size(); i != n; ++i) { while (first &lt; last &amp;&amp; !onLeft(p[last - 1], L[i])) --last; while (first &lt; last &amp;&amp; !onLeft(p[first], L[i])) ++first; q[++last] = L[i]; if (!sgn(Cross(q[last].v, q[last - 1].v))) { --last; if (onLeft(L[i].p, q[last])) q[last] = L[i]; } if (first &lt; last) p[last - 1] = getLineIntersection(q[last - 1], q[last]); } while (first &lt; last &amp;&amp; !onLeft(p[last - 1], q[first])) --last; //删除无用平面 if (last - first &lt;= 1) return vector&lt;Coord&gt;(); //空集 p[last] = getLineIntersection(q[last], q[first]); return vector&lt;Coord&gt;(p.begin() + first, p.begin() + last + 1); //从deque复制到输出中}int getLineCircleIntersection(const Line &amp;L, const Circle &amp;C, vector&lt;Coord&gt; &amp;sol){ lf a = L.v.X, b = L.p.X - C.c.X, c = L.v.Y, d = L.p.Y - C.c.Y, e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r, delta = f * f - 4 * e * g; if (sgn(delta) &lt; 0) return 0; if (!sgn(delta)) return sol.push_back(L.point(-f / (2 * e))), 1; sol.push_back(L.point((-f - sqrt(delta)) / (2 * e))); sol.push_back(L.point((-f + sqrt(delta)) / (2 * e))); return 2;}int getCircleIntersection(const Circle &amp;C1, const Circle &amp;C2, vector&lt;Coord&gt; &amp;sol){ lf d = abs(C1.c - C2.c); if (!sgn(d)) return sgn(C1.r - C2.r) ? 0 : -1; //重合返回-1 if (sgn(C1.r + C2.r - d) &lt; 0 || sgn(fabs(C1.r - C2.r) - d) &gt; 0) //外离或内含 return 0; lf a = arg(C2.c - C1.c), da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d)); Coord p1 = C1.point(a - da), p2 = C1.point(a + da); sol.push_back(p1); if (p1 == p2) return 1; //相切 return sol.push_back(p2), 2;}Line getTangent(const Coord &amp;C, const Coord &amp;P) { return Line(P, Normal(C - P)); } //圆心C，圆上一点P处切线int getTangents(const Coord &amp;p, const Circle &amp;C, vector&lt;Coord&gt; &amp;sol) //点到圆的切点，返回个数{ Coord u = p - C.c; lf d = abs(u); if (d &lt; C.r) return 0; //点在圆内 if (!sgn(d - C.r)) //点在圆上 return sol.push_back(p), 1; lf base = arg(u), ang = acos(C.r / d); sol.push_back(C.point(base + ang)); sol.push_back(C.point(base - ang)); return 2;}int getTangents(Circle A, Circle &amp;B, vector&lt;Coord&gt; &amp;a, vector&lt;Coord&gt; &amp;b) //公共切线的切点{ int cnt = 0; if (A.r &lt; B.r) swap(A, B), swap(a, b); //有时需标记交换 lf d = abs(A.c - B.c), rdiff = A.r - B.r, rsum = A.r + B.r; if (sgn(d - rdiff) &lt; 0) return 0; //内含 lf base = arg(B.c - A.c); if (!sgn(d) &amp;&amp; !sgn(rdiff)) return -1; //重合，无穷多条切线 if (!sgn(d - rdiff)) //内切，外公切线 { a.push_back(A.point(base)); b.push_back(B.point(base)); return 1; } //有外公切线的情形 lf ang = acos(rdiff / d); a.push_back(A.point(base + ang)); b.push_back(B.point(base + ang)); a.push_back(A.point(base - ang)); b.push_back(B.point(base - ang)); cnt += 2; if (!sgn(d - rsum)) { a.push_back(A.point(base)); b.push_back(B.point(base + PI)); ++cnt; } else if (sgn(d - rsum) &gt; 0) { lf ang_in = acos(rsum / d); a.push_back(A.point(base + ang_in)); b.push_back(B.point(base + ang_in + PI)); a.push_back(A.point(base - ang_in)); b.push_back(B.point(base - ang_in + PI)); cnt += 2; } return cnt;}lf AreaCircleWithTriangle(const Circle &amp;C, Coord A, Coord B) //C和三角形OAB的相交面积，如果三角形顶点不在O上则把圆和三角形同时平移，直到有一个顶点在O上{ int sg = sgn(Cross(A, B)); if (!sg || A == C.c || B == C.c) return 0; lf OA = abs(A - C.c), OB = abs(B - C.c), angle = Angle(A, B), d = DistanceToLine(Coord(), A, B); if (sgn(OA - C.r) &lt;= 0 &amp;&amp; sgn(OB - C.r) &lt;= 0) return Cross(A, B) / 2; if (sgn(OA - C.r) &gt;= 0 &amp;&amp; sgn(OB - C.r) &gt;= 0 &amp;&amp; sgn(d - C.r) &gt;= 0) return sg * C.r * C.r * angle / 2; if (sgn(OA - C.r) &gt;= 0 &amp;&amp; sgn(OB - C.r) &gt;= 0 &amp;&amp; sgn(d - C.r) &lt; 0) { Coord prj = getLineProjection(Coord(), A, B); if (!onSegment(prj, A, B)) return sg * C.r * C.r * angle / 2; vector&lt;Coord&gt; p; Line L = Line(A, B - A); getLineCircleIntersection(L, C, p); lf s1 = C.r * C.r * angle / 2, s2 = C.r * C.r * Angle(p[0], p[1]) / 2; s2 -= fabs(Cross(p[0], p[1]) / 2); s1 = s1 - s2; return sg * s1; } if (sgn(OB - C.r) &lt; 0) swap(A, B); Line L = Line(A, B - A); vector&lt;Coord&gt; inter; getLineCircleIntersection(L, C, inter); Coord inter_point = inter[!onSegment(inter[0], A, B)]; lf s = fabs(Cross(inter_point, A) / 2); s += C.r * C.r * Angle(inter_point, B) / 2; return s * sg;}lf AreaCircleWithPolygon(const Circle &amp;C, const vector&lt;Coord&gt; &amp;p){ lf ans = 0; for (int i = 0; i &lt; p.size(); ++i) ans += AreaCircleWithTriangle(C, p[i], p[(i + 1) % p.size()]); return fabs(ans);}Coord getGravityCenter(const vector&lt;Coord&gt; &amp;p) //多边形重心{ Coord a(0, 0); lf am = 0, mj; for (int i = 0; i &lt; p.size(); ++i) { mj = Cross(p[i], p[(i + 1) % p.size()]); a += mj * (p[i] + p[(i + 1) % p.size()]); am += mj; } return a / am / 3.0;} 三维123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177typedef double lf;const lf EPS = 1e-9, INF = 1e9, PI = acos(-1);int sgn(lf d) { return (d &gt; EPS) - (d &lt; -EPS); }struct Coord3{ lf X, Y, Z; friend bool operator!=(const Coord3 &amp;a, const Coord3 &amp;b) { return sgn(a.X - b.X) || sgn(a.Y - b.Y) || sgn(a.Z - b.Z); } friend bool operator==(const Coord3 &amp;a, const Coord3 &amp;b) { return !(a != b); } Coord3 &amp;operator+=(const Coord3 &amp;b) { return X += b.X, Y += b.Y, Z += b.Z, *this; } friend Coord3 operator+(Coord3 a, const Coord3 &amp;b) { return a += b; } Coord3 &amp;operator-=(const Coord3 &amp;b) { return X -= b.X, Y -= b.Y, Z -= b.Z, *this; } friend Coord3 operator-(Coord3 a, const Coord3 &amp;b) { return a -= b; } Coord3 &amp;operator*=(lf d) { return X *= d, Y *= d, Z *= d, *this; } friend Coord3 operator*(Coord3 a, lf d) { return a *= d; } friend Coord3 operator*(lf d, Coord3 a) { return a *= d; } Coord3 &amp;operator/=(lf d) { return X /= d, Y /= d, Z /= d, *this; } friend Coord3 operator/(Coord3 a, lf d) { return a /= d; } friend lf Dot(const Coord3 &amp;A, const Coord3 &amp;B) { return A.X * B.X + A.Y * B.Y + A.Z * B.Z; } friend Coord3 Cross(const Coord3 &amp;A, const Coord3 &amp;B) { return {A.Y * B.Z - A.Z * B.Y, A.Z * B.X - A.X * B.Z, A.X * B.Y - A.Y * B.X}; } friend lf norm(const Coord3 &amp;A) { return Dot(A, A); } friend lf abs(const Coord3 &amp;A) { return sqrt(norm(A)); } friend lf Angle(const Coord3 &amp;A, const Coord3 &amp;B) { return acos(Dot(A, B) / abs(A) / abs(B)); } friend lf Area2(Coord3 A, Coord3 B, Coord3 C) { return abs(Cross(B - A, C - A)); } friend lf Volume6(Coord3 A, Coord3 B, Coord3 C, Coord3 D) { return Dot(D - A, Cross(B - A, C - A)); } //四面体体积 friend Coord3 Centroid(Coord3 A, Coord3 B, Coord3 C, Coord3 D) { return (A + B + C + D) / 4.0; } //四面体的重心 friend lf DistanceToPlane(Coord3 p, Coord3 p0, const Coord3 &amp;n) { return Dot(p - p0, n) / abs(n); } //点p到平面p0-n的有向距离 friend Coord3 getPlaneProjection(Coord3 p, Coord3 p0, const Coord3 &amp;n) { return p - n * Dot(p - p0, n); } //点p在平面p0-n上的投影。n必须为单位向量 friend Coord3 LinePlaneIntersection(Coord3 p1, Coord3 p2, Coord3 p0, Coord3 n) //直线p1-p2 与平面p0-n的交点，假设交点唯一存在 { Coord3 v = p2 - p1; lf t = Dot(n, p0 - p1) / Dot(n, p2 - p1); //分母为0，直线与平面平行或在平面上 return p1 + v * t; //如果是线段 判断t是否在0~1之间 } friend lf DistanceToLine(Coord3 P, Coord3 A, Coord3 B) //点P到直线AB的距离 { Coord3 v1 = B - A, v2 = P - A; return abs(Cross(v1, v2)) / abs(v1); } friend lf DistanceToSeg(Coord3 P, Coord3 A, Coord3 B) //点到线段的距离 { if (A == B) return abs(P - A); Coord3 v1 = B - A, v2 = P - A, v3 = P - B; if (sgn(Dot(v1, v2)) &lt; 0) return abs(v2); if (sgn(Dot(v1, v3)) &gt; 0) return abs(v3); return fabs(DistanceToLine(P, A, B)); } friend bool LineDistance3D(Coord3 p1, Coord3 u, Coord3 p2, Coord3 v, lf &amp;s) //求异面直线 p1+s*u与p2+t*v的公垂线对应的s，如果平行|重合，返回0 { lf b = Dot(u, u) * Dot(v, v) - Dot(u, v) * Dot(u, v); if (!sgn(b)) return 0; lf a = Dot(u, v) * Dot(v, p1 - p2) - Dot(v, v) * Dot(u, p1 - p2); return s = a / b, 1; } friend bool SameSide(Coord3 p1, Coord3 p2, Coord3 a, Coord3 b) { return sgn(Dot(Cross(b - a, p1 - a), Cross(b - a, p2 - a))) &gt;= 0; } //p1和p2是否在线段a-b的同侧 friend bool PointInTri(Coord3 PP, Coord3 P[3]) //点P在三角形P0,P1,p中 { return SameSide(PP, P[0], P[1], P[2]) &amp;&amp; SameSide(PP, P[1], P[0], P[2]) &amp;&amp; SameSide(PP, P[2], P[0], P[1]); } friend bool TriSegIntersection(Coord3 P[3], Coord3 A, Coord3 B, Coord3 &amp;PP) //三角形P0P1p是否和线段AB相交，如有则为PP { Coord3 n = Cross(P[1] - P[0], P[2] - P[0]); if (sgn(Dot(n, B - A)) == 0) return false; //线段A-B和平面P0P1p平行或共面 lf t = Dot(n, P[0] - A) / Dot(n, B - A); //平面A和直线P1-p有惟一交点 if (sgn(t) &lt; 0 || sgn(t - 1) &gt; 0) return false; //不在线段AB上 return PointInTri(PP = A + (B - A) * t, P); } friend bool TriTriIntersection(Coord3 T1[3], Coord3 T2[3]) //空间两三角形是否相交 { Coord3 P; for (int i = 0; i &lt; 3; ++i) if (TriSegIntersection(T1, T2[i], T2[(i + 1) % 3], P) || TriSegIntersection(T2, T1[i], T1[(i + 1) % 3], P)) return 1; return 0; } friend lf SegSegDistance(Coord3 a1, Coord3 b1, Coord3 a2, Coord3 b2, Coord3 &amp;ans1, Coord3 &amp;ans2) //空间两直线上最近点对 返回最近距离 点对保存在ans1 ans2中 { Coord3 v1 = (a1 - b1), v2 = (a2 - b2); Coord3 N = Cross(v1, v2); Coord3 ab = (a1 - a2); lf ans = Dot(N, ab) / abs(N); Coord3 d1 = b1 - a1, d2 = b2 - a2, cd = Cross(d1, d2); lf nd = norm(cd), t1 = Dot(Cross(a2 - a1, d2), cd) / nd, t2 = Dot(Cross(a2 - a1, d1), cd) / nd; return ans1 = a1 + (b1 - a1) * t1, ans2 = a2 + (b2 - a2) * t2, fabs(ans); } friend bool InsideWithMinDistance(Coord3 PP, Coord3 *P, lf dist) //判断PP是否在三角形P中，并且到三条边的距离都至少为dist。保证P,A,B,C共面 { return PointInTri(PP, P) &amp;&amp; DistanceToLine(PP, P[0], P[1]) &gt;= dist || DistanceToLine(PP, P[1], P[2]) &gt;= dist || DistanceToLine(PP, P[2], P[0]) &gt;= dist; }};struct Sphere{ Coord3 o; lf r; Coord3 point(lf lat, lf lng) const //经纬度确定球面上一点 { lat *= PI / 180; lng *= PI / 180; return o + r * Coord3{cos(lat) * cos(lng), cos(lat) * sin(lng), sin(lat)}; }};struct ConvexPolyhedron //空间多边形和凸包问题{ struct Face { int v[3]; Face(int a, int b, int c) { v[0] = a, v[1] = b, v[2] = c; } Coord3 Normal(const vector&lt;Coord3&gt; &amp;P) const { return Cross(P[v[1]] - P[v[0]], P[v[2]] - P[v[0]]); } bool CanSee(const vector&lt;Coord3&gt; &amp;P, int i) const { return Dot(P[i] - P[v[0]], Normal(P)) &gt; 0; } //f是否能看见P[i] }; vector&lt;Face&gt; faces; vector&lt;Coord3&gt; p; ConvexPolyhedron(vector&lt;Coord3&gt; P) : p(P) { for (int i = 0; i &lt; p.size(); ++i) P[i] += Coord3{randEPS(), randEPS(), randEPS()}; vector&lt;vector&lt;int&gt;&gt; vis(P.size(), vector&lt;int&gt;(P.size())); faces.push_back(Face(0, 1, 2)); //由于已经进行扰动，前三个点不共线 faces.push_back(Face(2, 1, 0)); for (int i = 3; i &lt; P.size(); ++i) { vector&lt;Face&gt; next; for (int j = 0; j &lt; faces.size(); ++j) //计算每条边的“左面”的可见性 { Face &amp;f = faces[j]; int res = f.CanSee(P, i); if (!res) next.push_back(f); for (int k = 0; k &lt; 3; ++k) vis[f.v[k]][f.v[(k + 1) % 3]] = res; } for (int j = 0; j &lt; faces.size(); ++j) for (int k = 0; k &lt; 3; ++k) { int a = faces[j].v[k], b = faces[j].v[(k + 1) % 3]; if (vis[a][b] != vis[b][a] &amp;&amp; vis[a][b]) //(a,b)是分界线，左边对P[i]可见 next.push_back(Face(a, b, i)); } swap(faces, next); } } lf randEPS() { return (rand() / lf(RAND_MAX) - 0.5) * EPS; } Coord3 centroid() //三维凸包重心 { Coord3 C = p[0], tot{0, 0, 0}; lf totv = 0; for (int i = 0; i &lt; faces.size(); ++i) { Coord3 p1 = p[faces[i].v[0]], p2 = p[faces[i].v[1]], p3 = p[faces[i].v[2]]; lf v = -Volume6(p1, p2, p3, C); totv += v; tot += v * Centroid(p1, p2, p3, C); } return tot / totv; } lf dist(Coord3 C) //凸包内一点到表面最近距离 { lf ans = INF; for (int i = 0; i &lt; faces.size(); ++i) { Coord3 p1 = p[faces[i].v[0]], p2 = p[faces[i].v[1]], p3 = p[faces[i].v[2]]; ans = min(ans, fabs(-Volume6(p1, p2, p3, C) / Area2(p1, p2, p3))); } return ans; }};","link":"/2019/02/03/2019-02-03-计算几何/"},{"title":"概率论与数理统计","text":"参考斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 概率论的基本概念随机试验在概率论中，将具有以下三个特点的事件称为随机试验： 可以在相同的条件下重复进行 每次试验的可能结果不止一个，并且事先能够明确事件的所有可能结果 进行一次试验前不能确定哪个结果会出现 样本空间、随机事件样本空间随机事件$E$的所有基本结果组成的集合为$E$的样本空间，记为$S$。样本空间的元素，即$E$的每个结果，称为样本点或基本事件，有时记为$\\omega$。 随机事件称试验$E$的样本空间$S$的子集为$E$的随机事件，简称事件。在每次试验中，当且仅当这一子集中的一个样本点出现时，称这一事件发生。特别地，由一个样本点组成的单点集，称为基本事件；样本空间$S$包含所有的基本点，每次试验中总是发生，称为必然事件，记为$\\Omega$；空集$\\varnothing$每次都不可能发生，称为不可能事件。 事件间的关系与事件的运算子事件$A \\subset B$，若$A$发生，则$B$发生。 相等事件$A = B$，即$A \\subset B$，且$B \\subset A$ 。 和事件$A\\bigcup B$（或$A + B$），$A$与$B$中至少有一个发生。 差事件$A - B={x|x\\in A,x\\not\\in B}$，$A$发生但$B$不发生。 积事件$A\\bigcap B$（或${AB}$），$A$与$B$同时发生。 互斥事件（互不相容）$A\\bigcap B$=$\\varnothing$。基本事件是两两互斥的。 互逆事件（对立事件）$A\\bigcap B=\\varnothing ,A\\bigcup B=\\Omega ,A=\\overline{B},B=\\overline{A}$ 完全事件组${ {A}{1} }{ {A}{2} }\\cdots { {A}{n} }$两两互斥，且和事件为必然事件，即$A_i\\bigcap A_j=\\varnothing,i\\ne j,\\bigcap{i=1}^n=\\Omega$ 交换律$A\\bigcup B=B\\bigcup A,A\\bigcap B=B\\bigcap A$ 结合律$(A\\bigcup B)\\bigcup C=A\\bigcup (B\\bigcup C)$ 分配律$(A\\bigcap B)\\bigcap C=A\\bigcap (B\\bigcap C)$ 德·摩根律$\\overline{A\\bigcup B}=\\overline{A}\\bigcap \\overline{B}$$\\overline{A\\bigcap B}=\\overline{A}\\bigcup \\overline{B}$ 频率与概率频率定义相同条件下进行了n次试验，在这n次试验当中，事件A发生的频率$n_A$称为事件A的频数，比值$f_n(A)=\\frac{n_A}{n}$称为事件A发生的频率。 性质 $0\\leq f_n(A)\\leq 1$ $f_n(S)=1$ 有限可加性：若$A_1,A_2,\\ldots,a_k$是两两互不相容的事件，则$f_n(A_1\\bigcup A_2\\bigcup\\ldots\\bigcup A_k)=f_n(A_1)+f_n(A_2)+\\ldots+f_n(A_k)$ 概率定义设E是随机试验，S是它的样本空间，对于E的每一事件A赋予一个实数$P(A)$，称为事件A的概率，如果集合函数$P(\\cdot)$满足下列条件： 非负性对于每一事件A，有$P(A)\\ge 0$ 规范性对于必然事件S，有$P(S)=1$ 可列可加性设$A_1,A_2,\\ldots$是两两互不相容的事件，则$P(A_1\\bigcup A_2\\bigcup\\ldots)=P(A_1)+P(A_2)+\\ldots$ 性质 $P(\\varnothing)=0$ 有限可加性：$P(A_1\\bigcup A_2\\bigcup\\ldots\\bigcup A_n)=P(A_1)+P(A_2)+\\ldots+P(A_n)$，可由上一条性质和可列可加性推出。 若$A\\subset B$，则$P(B-A)=P(B)-P(A)\\ge 0$ $P(A)\\le 1$ 逆事件的概率：$P(\\overline{A})=1-P(A)$ 加法公式：$P(A\\bigcup B)=P(A)+P(B)-P(AB)$，推广到三元：$P(A\\bigcup B\\bigcup C)=P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)$ $P(A-B)=P(A)-P(AB)$ $P(A\\overline{B})=P(A)-P(AB)$ $P(A)=P(AB)+P(A\\overline{B})$ $P(A\\bigcup B)=P(A)+P(\\overline{A}B)=P(AB)+P(A\\overline{B})+P(\\overline{A}B)$ 等可能概型（古典概型）具备以下两个特点的试验被称作等可能概型（古典概型）： 试验的样本空间只包含有限个元素 试验中每个基本事件发生的可能性相同 古典概型计算公式$P(A)=\\frac{A包含的基本事件数}{S包含的事件数}$ 实际推断原理概率很小的事件在一次试验中实际上几乎是不发生的。 条件概率条件概率$P(B|A)=\\frac{P(AB)}{P(A)}$,表示$A$发生的条件下，$B$发生的概率。条件概率$P(\\centerdot |B)$满足概率的所有性质，例如： $P({ {\\overline{A} }{1} }|B)=1-P({ {A}{1} }|B)$ $P({ {A}{1} }\\bigcup { {A}{2} }|B)=P({ {A}{1} }|B)+P({ {A}{2} }|B)-P({ {A}{1} }{ {A}{2} }|B)$ $P({ {A}{1} }{ {A}{2} }|B)=P({ {A}{1} }|B)P({ {A}{2} }|{ {A}_{1} }B)$ 非负性对于每一事件$B$，有$P(B|A)\\ge 0$ 规范性对于必然事件$S$，有$P(S|A)=1$ 可列可加性$P(\\underset{i=1}{\\overset{\\infty}{\\mathop{\\bigcup } } },{ {B}{i} }|A)=\\sum{i=1}^\\infty P(B_i|A)$ 乘法定理$P({ {A}{1} }{ {A}{2} })=P({ {A}{1} })P({ {A}{2} }|{ {A}{1} })=P({ {A}{2} })P({ {A}{1} }|{ {A}{2} })$$P({ {A}{1} }{ {A}{2} }\\cdots { {A}{n} })=P({ {A}{1} })P({ {A}{2} }|{ {A}{1} })P({ {A}{3} }|{ {A}{1} }{ {A}{2} })\\cdots P({ {A}{n} }|{ {A}{1} }{ {A}{2} }\\cdots { {A}_{n-1} })$ 全概率公式和贝叶斯公式全概率公式$P(A)=\\sum\\limits_{i=1}^{n}{P(A|{ {B}{i} })P({ {B}{i} }),{ {B}{i} }{ {B}{j} } }=\\varnothing ,i\\ne j,\\underset{i=1}{\\overset{n}{\\mathop{\\bigcup } } },{ {B}_{i} }=\\Omega$ Bayes（贝叶斯）公式$P({ {B}{j} }|A)=\\frac{P(A|{ {B}{j} })P({ {B}{j} })}{\\sum\\limits{i=1}^{n}{P(A|{ {B}{i} })P({ {B}{i} })} },j=1,2,\\cdots ,n$上述公式中事件${ {B}_{i} }$的个数可为可列个。 独立性若干个事件，如果对于其中任意个事件，它们的积事件的概率都等于各事件概率的积，则称这几个事件相互独立。 $A$与$B$相互独立$\\Leftrightarrow P(AB)=P(A)P(B)$ $A$，$B$，$C$两两独立$\\Leftrightarrow P(AB)=P(A)P(B)$;$P(BC)=P(B)P(C)$;$P(AC)=P(A)P(C)$; $A$，$B$，$C$相互独立$\\Leftrightarrow P(AB)=P(A)P(B)$;$P(BC)=P(B)P(C)$;$P(AC)=P(A)P(C)$;$P(ABC)=P(A)P(B)P(C)$ 独立重复试验将某试验独立重复$n$次，若每次试验中事件A发生的概率为$p$，则$n$次试验中$A$发生$k$次的概率为：$P{X=k}=C_{n}^{k}{ {p}^{k} }{ {(1-p)}^{n-k} }$ 性质 若${ {A}{1} },{ {A}{2} },\\cdots ,{ {A}{n} }$相互独立，则$P(\\bigcap\\limits{i=1}^{n}{ { {A}{i} } })=\\prod\\limits{i=1}^{n}{P({ {A}{i} })},$$P(\\bigcup\\limits{i=1}^{n}{ { {A}{i} } })=\\prod\\limits{i=1}^{n}{(1-P({ {A}_{i} }))}$ 若${ {A}{1} },{ {A}{2} },\\cdots ,{ {A}{m} },{ {B}{1} },{ {B}{2} },\\cdots ,{ {B}{n} }$相互独立，则$f({ {A}{1} },{ {A}{2} },\\cdots ,{ {A}{m} })$与$g({ {B}{1} },{ {B}{2} },\\cdots ,{ {B}{n} })$也相互独立，其中$f(\\centerdot ),g(\\centerdot )$分别表示对相应事件做任意事件运算后所得的事件，另外，概率为1（或0）的事件与任何事件相互独立。 互斥、互逆与独立性之间的关系$A$与$B$互逆$\\Rightarrow$ $A$与$B$互斥，但反之不成立，$A$与$B$互斥（或互逆）且均非零概率事件$\\Rightarrow$ $A$与$B$不独立。 随机变量及其分布随机变量设随机试验的样本空间为$S={e}$，称定义在样本空间$S$上的实值单值函数$X=X(e)$为随机变量。 离散型随机变量及其分布律取值有限或可列无限的随机变量称为离散型随机变量。设X的所有取值为$x_k(k=1,2,\\ldots)$，称X取各个事件的概率$P{X=x_k}=p_k,k=1,2,\\ldots$为离散型随机变量X的分布律，也可以写成表格形式： $X$ $x_1$ $x_2$ $\\ldots$ $x_n$ $\\ldots$ $p_k$ $p_1$ $p_2$ $\\ldots$ $p_n$ $\\ldots$ 其中，$p_k$满足： $p_k\\ge 0,k=1,2,\\ldots$ $\\sum_{k=1}^\\infty p_k=1$ 0-1分布（两点分布）$P{X=k} = p^{k}{(1 - p)}^{1 - k},k = 0,1$，则称X服从以p为参数的0-1分布（两点分布） 伯努利试验、二项分布Binomial Distribution（二项分布）背景：n重Bernoulli 试验中，每次试验感兴趣的事件A 在 n 次试验中发生的次数 —— X是一离散型随机变量。若$P(A)=p$,则$P_n(k)=P{X=k}=C_n^kp^k(1-p)^{n-k},k=0,1\\ldots n$称X服从参数为$n, p$的二项分布，记作$X\\sim B(n,p)$特别地，$0 – 1$分布是$n=1$的二项分布. Poisson （泊松）分布背景：已知某事发生速率为每单位时间b次，观察时间为T时间单位，X为该观察时间内发生该事的总次数$\\lambda=bT$设随机变量X的所有可能值是全体非负整数，若$P{X=k}=e^{-\\lambda}\\frac{\\lambda^k}{k!},k=0,1,\\ldots$其中$\\lambda&gt;0$是常数，则称 X 服从参数为$\\lambda$的Poisson 分布，记作$\\pi(\\lambda)$或$P(\\lambda)$ 泊松定理可用于泊松分布逼近二项分布。设随机变量X服从二项分布，其分布律为$P{X=K}=C_n^kp^k(1-p)^{n-k}$,又设$np=\\lambda$是常数，则有$\\lim_{n\\to\\infty}P{X=K}=e^{-\\lambda}\\frac{\\lambda^k}{k!}$在实际计算中,当$n\\ge 20,p\\leq 0.05$时，可用上述公式近似计算；而当$n\\ge 100,np\\leq 10$时，精度更好。 几何分布在n次伯努利试验中，试验k次才得到第一次成功的机率。$G(p):P{X=k} = {(1 - p)}^{k - 1}p,0 &lt; p &lt; 1,k = 1,2,\\cdots,P{X = m + k|X &gt; m} = P{X=k}$ 超几何分布设有产品N件，其中次品D件，其余为正品，从中随机地抽取n件。记X为抽到的的次品件数，求X的分布律.此时抽到k件次品的概率为$H(N,M,n):P{X=k} = \\frac{C_{M}^{k}C_{N - M}^{n -k} }{C_{N}^{n} },k =0,1,\\cdots,min(n,M)$，称X服从超几何分布. 可以证明超几何分布的极限分布就是二项分布. 负二项分布(Pascal分布)离散均匀分布随机变量的分布函数定义$F(x) = P(X \\leq x), - \\infty &lt; x &lt; + \\infty$ 性质 $0 \\leq F(x) \\leq 1$ $F(x)$单调不减 右连续$F(x) = F(x+0)$ $F( - \\infty) = 0,F( + \\infty) = 1$ 连续型随机变量及其概率密度概率密度$f(x)$非负可积，且: $f(x) \\geq 0$ $\\int_{- \\infty}^{+\\infty}{f(x){dx} = 1}$ $x$为$f(x)$的连续点，则:$f(x) = F’(x)$分布函数$F(x) = \\int_{- \\infty}^{x}{f(t){dt} }$ 均匀分布设连续型随机变量X具有概率密度$p(x)=\\begin{cases}\\frac{1}{b-a},a\\leq x\\leq b,\\0,其它\\end{cases}$则称X在$(a,b)$上服从均匀分布，记作$X\\sim U(a,b)$分布函数$F(x)=\\begin{cases}0,x&lt;a\\ \\frac{x-a}{b-a},a\\leq x&lt; b\\1,x\\ge b\\end{cases}$ 指数分布设连续型随机变量X具有概率密度$p(X)=\\begin{cases}\\lambda e^{-\\lambda x},x\\ge 0,\\0,x&lt;0\\end{cases}$，其中$\\lambda &gt;0$为常数，则称X在$(a,b)$上服从指数分布。分布函数$F(x)=\\begin{cases}1-e^{-\\frac{x}{\\theta}},x&gt;0\\0,x\\le 0\\end{cases}$无记忆性：$\\forall s,t&gt;0$，$P{x&gt;s+t|x&gt;s}=p{x&gt;t}$，即，如果T是某一元件的寿命，已知元件使用了s小时，它总共使用至少s+t小时的条件概率，与从开始使用时算起它使用至少t小时的概率相等。 正态分布（高斯分布，Gauss）设连续型随机变量X具有概率密度$p(X)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2} }$则称X服从参数为$\\mu,\\sigma$的正态分布或高斯分布，记作$X\\sim N(\\mu,\\sigma^2)$$\\mu$是位置参数，即固定$\\sigma$，对于不同的$\\mu$，对应的f(x)的形状不变化，只是位置不同。$\\sigma$是形状参数，即固定$\\mu$，对于不同的$\\sigma$，对应f(x)位置不变化，只是$\\sigma$越小，靠近$\\mu$附近取值的概率越大，相应拐点越接近于ox轴。$\\sigma$大小与曲线陡峭程度成反比（几何意义），与数据分散程度成正比（数据意义）。 标准正态分布N(0,1)密度函数$\\varphi(x)=\\frac{1}{\\sqrt{2\\pi} }e^{-\\frac{x^2}{2} }$是偶函数，其分布函数为$\\Phi(x)=\\frac{1}{\\sqrt{2\\pi} }\\int_{-\\infty}^xe^{-\\frac{t^2}{2} },dt$，其值可查表。$\\varphi(0) = \\frac{1}{\\sqrt{2\\pi} },\\Phi(0) =\\frac{1}{2},$ $\\Phi( - a) = P(X \\leq - a) = 1 - \\Phi(a)$$X\\sim N\\left( \\mu,\\sigma^{2} \\right) \\Rightarrow \\frac{X -\\mu}{\\sigma}\\sim N\\left( 0,1 \\right),P(X \\leq a) = \\Phi(\\frac{a -\\mu}{\\sigma})$ 随机变量的函数的分布 离散型：$P(X = x_{1}) = p_{i},Y = g(X)$，则: $P(Y = y_{j}) = \\sum_{g(x_{i}) = y_{i} }^{}{P(X = x_{i})}$ 连续型：$X\\sim f_{X}(x),Y = g(x)$，则:$F_{y}(y) = P(Y \\leq y) = P(g(X) \\leq y) = \\int_{g(x) \\leq y}^{}{f_{x}(x)dx}$， $f_{Y}(y) = F’_{Y}(y)$ 离散型随机变量的分布函数为阶梯间断函数；连续型随机变量的分布函数为连续函数，但不一定为处处可导函数。 存在既非离散也非连续型随机变量。 多维随机变量及其分布二维随机变量由两个随机变量构成的随机向量$(X,Y)$， 联合分布为$F(x,y) = P{X \\le x,Y \\le y}$$P{ X = x_{i},Y = y_{j}} = p_{ {ij} };i,j =1,2,\\cdots$$f(x,y) \\geq 0$$\\int_{- \\infty}^{+ \\infty}{\\int_{- \\infty}^{+ \\infty}{f(x,y)dxdy} } = 1$$F(x,y) = \\int_{- \\infty}^{x}{\\int_{- \\infty}^{y}{f(u,v)dudv} }$ 边缘分布$p_{i \\cdot} = \\sum_{j = 1}^{\\infty}p_{ {ij} },i =1,2,\\cdots$ $p_{\\cdot j} = \\sum_{i}^{\\infty}p_{ {ij} },j = 1,2,\\cdots$$f_{X}\\left( x \\right) = \\int_{- \\infty}^{+ \\infty}{f\\left( x,y \\right){dy} }$ $f_{Y}(y) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dx}$ 条件分布$P{ X = x_{i}|Y = y_{j}} = \\frac{p_{ {ij} } }{p_{\\cdot j} }$$P{ Y = y_{j}|X = x_{i}} = \\frac{p_{ {ij} } }{p_{i \\cdot} }$$f_{X|Y}\\left( x \\middle| y \\right) = \\frac{f\\left( x,y \\right)}{f_{Y}\\left( y \\right)}$$f_{Y|X}(y|x) = \\frac{f(x,y)}{f_{X}(x)}$ 相互独立的随机变量若$P{X\\le x,Y\\le y}=P{X\\le x}P{Y\\le y}$，即$F(x,y)=F_X(x)F_Y(y)$，则称随机变量$X,Y$是相互独立的。对于连续型随机变量，即$f(x,y)=f_X(x)f_Y(y)$在平面上几乎（除去面积为0的集合外）处处成立。对于离散型随机变量，即$P{X=x_i,Y=y_i}=P{X=x_i}P{Y=y_i}$。对于二维正态随机变量$(X,Y)$，$X,Y$相互独立的充要条件是参数$\\rho=0$。 两个随机变量的函数的分布二维均匀分布$(x,y) \\sim U(D)$ ,$f(x,y) = \\begin{cases} \\frac{1}{S(D)},(x,y) \\in D \\ 0,其他 \\end{cases}$ 二维正态分布$(X,Y)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$,$(X,Y)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$$f(x,y) = \\frac{1}{2\\pi\\sigma_{1}\\sigma_{2}\\sqrt{1 - \\rho^{2} } }.\\exp\\left{ \\frac{- 1}{2(1 - \\rho^{2})}\\lbrack\\frac{ {(x - \\mu_{1})}^{2} }{\\sigma_{1}^{2} } - 2\\rho\\frac{(x - \\mu_{1})(y - \\mu_{2})}{\\sigma_{1}\\sigma_{2} } + \\frac{ {(y - \\mu_{2})}^{2} }{\\sigma_{2}^{2} }\\rbrack \\right}$ 随机变量的独立性和相关性$X$和$Y$的相互独立:$\\Leftrightarrow F\\left( x,y \\right) = F_{X}\\left( x \\right)F_{Y}\\left( y \\right)$:$\\Leftrightarrow p_{ {ij} } = p_{i \\cdot} \\cdot p_{\\cdot j}$（离散型）$\\Leftrightarrow f\\left( x,y \\right) = f_{X}\\left( x \\right)f_{Y}\\left( y \\right)$（连续型）$X$和$Y$的相关性： 相关系数$\\rho_{ {XY} } = 0$时，称$X$和$Y$不相关，否则称$X$和$Y$相关 两个随机变量的函数的分布$Z=X+Y$的分布$f_{X+Y}(z)=\\int_{-\\infty}^\\infty f(x,z-x)dx$ $Z=\\frac{Y}{X}$的分布、$Z=XY$的分布$f_{Y/X}(z)=\\int_{-\\infty}^\\infty |x|f(x,xz)dx$$f_{XY}(z)=\\int_{-\\infty}^\\infty \\frac{1}{|x|}f(x,\\frac{z}{x})dx$ $M=\\max{X,Y}$的分布、$N=\\min{X,Y}$的分布$F_{max}(z)=\\Pi F_{x_i}(z)$$F_{min}(z)=1-\\Pi (1-F_{x_i}(z))$ 离散型$P\\left( X = x_{i},Y = y_{i} \\right) = p_{ {ij} },Z = g\\left( X,Y \\right)$ 则：$P(Z = z_{k}) = P\\left{ g\\left( X,Y \\right) = z_{k} \\right} = \\sum_{g\\left( x_{i},y_{i} \\right) = z_{k} }^{}{P\\left( X = x_{i},Y = y_{j} \\right)}$ 连续型$\\left( X,Y \\right) \\sim f\\left( x,y \\right),Z = g\\left( X,Y \\right)$则：$F_{z}\\left( z \\right) = P\\left{ g\\left( X,Y \\right) \\leq z \\right} = \\iint_{g(x,y) \\leq z}^{}{f(x,y)dxdy}$，$f_{z}(z) = F’_{z}(z)$ 重要公式与结论$f_{X}(x) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dy,}$$f_{Y}(y) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dx}$$P\\left{ \\left( X,Y \\right) \\in D \\right} = \\iint_{D}^{}{f\\left( x,y \\right){dxdy} }$若$(X,Y)$服从二维正态分布$N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$则有： $X\\sim N\\left( \\mu_{1},\\sigma_{1}^{2} \\right),Y\\sim N(\\mu_{2},\\sigma_{2}^{2}).$ $X$与$Y$相互独立$\\Leftrightarrow \\rho = 0$，即$X$与$Y$不相关。 $C_{1}X + C_{2}Y\\sim N(C_{1}\\mu_{1} + C_{2}\\mu_{2},C_{1}^{2}\\sigma_{1}^{2} + C_{2}^{2}\\sigma_{2}^{2} + 2C_{1}C_{2}\\sigma_{1}\\sigma_{2}\\rho)$ ${\\ X}$关于$Y=y$的条件分布为： $N(\\mu_{1} + \\rho\\frac{\\sigma_{1} }{\\sigma_{2} }(y - \\mu_{2}),\\sigma_{1}^{2}(1 - \\rho^{2}))$ $Y$关于$X = x$的条件分布为： $N(\\mu_{2} + \\rho\\frac{\\sigma_{2} }{\\sigma_{1} }(x - \\mu_{1}),\\sigma_{2}^{2}(1 - \\rho^{2}))$ 若$X$与$Y$独立，且分别服从$N(\\mu_{1},\\sigma_{1}^{2}),N(\\mu_{1},\\sigma_{2}^{2}),$则：$\\left( X,Y \\right)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},0),$ $C_{1}X + C_{2}Y\\sim{\\ }N(C_{1}\\mu_{1} + C_{2}\\mu_{2},C_{1}^{2}\\sigma_{1}^{2} C_{2}^{2}\\sigma_{2}^{2}).$ 若$X$与$Y$相互独立，$f\\left( x \\right)$和$g\\left( x \\right)$为连续函数， 则$f\\left( X \\right)$和$g(Y)$也相互独立。 随机变量的数字特征数学期望数学期望简称期望，又称均值。数学期望完全由概率分布决定。 离散型若离散型随机变量$X$的分布律为$P\\left{ X = x_{i} \\right} = p_{i}$ ，且级数$E(X) = \\sum_{i}^{}{x_{i}p_{i} }$绝对收敛，则称$E(x)$为随机变量$X$的数学期望。 连续型$X\\sim f(x),E(X) = \\int_{- \\infty}^{+ \\infty}{xf(x)dx}$ 性质 $E(C) = C,E\\lbrack E(X)\\rbrack = E(X)$ $E(C_{1}X + C_{2}Y) = C_{1}E(X) + C_{2}E(Y)$ 若$X$和$Y$独立，则$E(XY) = E(X)E(Y)$ $\\left\\lbrack E(XY) \\right\\rbrack^{2} \\leq E(X^{2})E(Y^{2})$ 随机变量函数的数学期望对于函数$Y = g(x)$ $X$为离散型$P{ X = x_{i}} = p_{i},E(Y) = \\sum_{i}^{}{g(x_{i})p_{i} }$； $X$为连续型$X\\sim f(x),E(Y) = \\int_{- \\infty}^{+ \\infty}{g(x)f(x)dx}$扩展到多维函数：$Z = g(X,Y)$;$\\left( X,Y \\right)\\sim P{ X = x_{i},Y = y_{j}} = p_{ {ij} }$;$E(Z) = \\sum_{i}^{}{\\sum_{j}^{}{g(x_{i},y_{j})p_{ {ij} } } }$ $\\left( X,Y \\right)\\sim f(x,y)$;$E(Z) = \\int_{- \\infty}^{+ \\infty}{\\int_{- \\infty}^{+ \\infty}{g(x,y)f(x,y)dxdy} }$ 方差$D(X) = E\\left\\lbrack X - E(X) \\right\\rbrack^{2} = E(X^{2}) - \\left\\lbrack E(X) \\right\\rbrack^{2}$，有时也记作$Var(X)$。同时引入标准差（均方差）$\\sigma (x)=\\sqrt{D(X)}$。 离散型$D(X) = \\sum_{i}^{}{\\left\\lbrack x_{i} - E(X) \\right\\rbrack^{2}p_{i} }$ 连续型$D(X) = {\\int_{- \\infty}^{+ \\infty}\\left\\lbrack x - E(X) \\right\\rbrack}^{2}f(x)dx$ 性质 $\\ D(X) = E(X^{2}) - E^{2}(X)$ $\\ D(C) = 0,D\\lbrack E(X)\\rbrack = 0,D\\lbrack D(X)\\rbrack = 0$ $\\ D\\left( C_{1}X + C_{2} \\right) = C_{1}^{2}D\\left( X \\right)$ $X$与$Y$相互独立，则$D(X \\pm Y) = D(X) + D(Y)$ $\\ D(X) = 0 \\Leftrightarrow P\\left{ X = C \\right} = 1$ $\\ D\\left( X \\right) &lt; E\\left( X - C \\right)^{2},C \\neq E\\left( X \\right)$ Chebyshev（切比雪夫）不等式若随机变量$X$满足$E(X)=\\mu$，方差$D(x)=\\sigma^2$，则对于任意正数$\\varepsilon$，有切比雪夫不等式$P{|X-\\mu|\\ge\\varepsilon}\\leq\\frac{\\sigma^2}{\\varepsilon^2}$成立。 协方差及相关系数$Cov(X,Y) = E\\left\\lbrack (X - E(X)(Y - E(Y)) \\right\\rbrack$称为随机变量$X,Y$的协方差，$\\rho_{ {XY} } = \\frac{Cov(X,Y)}{\\sqrt{D(X)}\\sqrt{D(Y)} }$称为他们的相关系数。 性质 $\\ Cov(X,Y) = Cov(Y,X)$ $\\ Cov(aX,bY) = abCov(Y,X)$ $\\ Cov(X_{1} + X_{2},Y) = Cov(X_{1},Y) + Cov(X_{2},Y)$ $\\ \\left| \\rho\\left( X,Y \\right) \\right| \\leq 1$ $\\ \\rho\\left( X,Y \\right) = 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$ ，其中$a &gt; 0$ $\\rho\\left( X,Y \\right) = - 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &lt; 0$ 一般有 $D(X \\pm Y) = D(X) + D(Y) \\pm 2Cov(X,Y) = D(X) + D(Y) \\pm 2\\rho\\sqrt{D(X)}\\sqrt{D(Y)}$ 重要公式与结论 $\\ Cov(X,Y) = E(XY) - E(X)E(Y)$ $\\left| \\rho\\left( X,Y \\right) \\right| \\leq 1,$且 $\\rho\\left( X,Y \\right) = 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &gt; 0$ $\\rho\\left( X,Y \\right) = - 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &lt; 0$ 下面5个条件互为充要条件：$\\rho(X,Y) = 0$ $\\Leftrightarrow Cov(X,Y) = 0$ $\\Leftrightarrow E(X,Y) = E(X)E(Y)$ $\\Leftrightarrow D(X + Y) = D(X) + D(Y)$ $\\Leftrightarrow D(X - Y) = D(X) + D(Y)$。注：$X$与$Y$独立为上述5个条件中任何一个成立的充分条件，但非必要条件。 矩、协方差矩阵（待补充）$E(X^{k})$称为$X$的$k$阶原点矩，简称$k$阶矩。$E\\left{ {\\lbrack X - E(X)\\rbrack}^{k} \\right},k=2,3,\\ldots$称为$X$的$k$阶中心矩。$E(X^{k}Y^{l})$称为$X,Y$的$k+l$阶混合矩。$E\\left{ {\\lbrack X - E(X)\\rbrack}^{k} {\\lbrack Y - E(Y)\\rbrack}^{l}\\right},k,l=2,3,\\ldots$称为$X,Y$的$k+l$阶混合中心矩。显然，$E(X)$是$X的一阶原点矩，$D(X)$是$X的二阶中心矩，$Cov(X,Y)$是$X,Y$的二阶混合中心矩。 大数定律及中心极限定理大数定律辛钦大数定理（弱大数定理）设随机变量$X_1,X_2,\\ldots,X_n,\\ldots$相互独立，服从同一分布且具有数学期望$E(X_k)=\\mu,(k=1,2,\\ldots)$，则序列$\\overline{X}=\\frac{1}{n}\\sum_{k=1}^nX_k$依概率收敛于$\\mu$。 伯努利大数定理伯努利大数定理是辛钦大数定理的一个重要推论，它表明：试验次数很大时，可用事件的频率代替事件的概率。设$f_A$是n次独立重复试验中事件A发生的次数，$p$是事件A在每次试验中发生的概率，则对于任意的正数$\\varepsilon$，有$\\lim_{n\\to\\infty}P{|\\frac{f_A}{n}-p|&lt;\\varepsilon}=1$，$\\lim_{n\\to\\infty}P{|\\frac{f_A}{n}-p|\\ge\\varepsilon}=0$。 中心极限定理独立同分布的中心极限定理设随机变量$X_1,X_2,\\ldots,X_n,\\ldots$相互独立，服从同一分布且具有数学期望和方差$E(X_k)=\\mu,D(X_k)=\\sigma^2&gt;0,(k=1,2,\\ldots)$，则随机变量之和$\\sum_{k=1}^nX_k$的标准化变量$Y_n=\\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt{n}\\sigma}$的分布函数$F_n(x)$对任意x满足$\\lim_{n\\to\\infty}F_n(x)=\\Phi(x)$。这就是说，n足够大的时候，近似地有$\\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt{n}\\sigma}\\sim N(0,1)$或$\\overline{X}~N(\\mu,\\frac{\\sigma^2}{n})$ Lyapunov（李雅普诺夫）定理设随机变量$X_1,X_2,\\ldots,X_n,\\ldots$相互独立，具有数学期望和方差$E(X_k)=\\mu_k,D(X_k)=\\sigma_k^2&gt;0,(k=1,2,\\ldots)$，记$B_n=\\sum_{k=1}^n\\sigma_k^2$，若存在正数$\\delta$，使得当$n\\to\\infty$时，$\\frac{1}{B_n^{2+\\delta}}\\sum_{k=1}^nE{|X_k-\\mu_k|^{2+\\delta}}\\to 0$，则随机化变量之和$\\sum_{k=1}^nX_k$的标准化变量$Z_n=\\frac{\\sum_{k=1}^nX_k-\\sum_{k=1}^n\\mu_k}{B_n}$的分布函数$F_n(x)$对于任意x满足$\\lim_{n\\to\\infty}F_n(x)=\\Phi(x)$。该定理表明，n足够大的时候，近似地有$Z_n\\sim N(0,1)$。 De Moivre-Laplace（棣莫弗-拉普拉斯）定理独立同分布的中心极限定理的特殊情况，设随机变量$\\eta_n(n=1,2,\\ldots)$服从参数为$n,p(0 &lt; p &lt; 1) $的二项分布，则对于任意x，有$\\lim_{n\\to\\infty}P{\\frac{\\eta_n-np}{\\sqrt{np(1-p)}}\\leq x}=\\Phi(x)$。 样本及抽样分布随机样本总体研究对象的全体，它是一个随机变量，用$X$表示。 个体组成总体的每个基本元素。 简单随机样本来自总体$X$的$n$个相互独立且与总体同分布的随机变量$X_{1},X_{2}\\cdots,X_{n}$，称为容量为$n$的简单随机样本，简称样本。 直方图和箱线图直方图箱线图样本分位数若$P(X \\leq x_{\\alpha}) = \\alpha,$则称$x_{\\alpha}$为$X$的$\\alpha$分位数 抽样分布统计量设$X_{1},X_{2}\\cdots,X_{n},$是来自总体$X$的一个样本，$g(X_{1},X_{2}\\cdots,X_{n})$）是样本的连续函数，且$g()$中不含任何未知参数，则称$g(X_{1},X_{2}\\cdots,X_{n})$为统计量。 样本均值$\\overline{X} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i}$ 样本方差$S^{2} = \\frac{1}{n - 1}\\sum_{i = 1}^{n}{(X_{i} - \\overline{X})}^{2}$ 样本矩样本$k$阶原点矩：$A_{k} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i}^{k},k = 1,2,\\cdots$ 样本k阶中心矩$B_{k} = \\frac{1}{n}\\sum_{i = 1}^{n}{(X_{i} - \\overline{X})}^{k},k = 1,2,\\cdots$ 常用统计量分布$\\chi^{2}$分布$\\chi^{2} = X_{1}^{2} + X_{2}^{2} + \\cdots + X_{n}^{2}\\sim\\chi^{2}(n)$，其中$X_{1},X_{2}\\cdots,X_{n},$相互独立，且同服从$N(0,1)$ $t$分布$T = \\frac{X}{\\sqrt{Y/n} }\\sim t(n)$ ，其中$X\\sim N\\left( 0,1 \\right),Y\\sim\\chi^{2}(n),$且$X$，$Y$ 相互独立。 $F$分布$F = \\frac{X/n_{1} }{Y/n_{2} }\\sim F(n_{1},n_{2})$，其中$X\\sim\\chi^{2}\\left( n_{1} \\right),Y\\sim\\chi^{2}(n_{2}),$且$X$，$Y$相互独立。 正态总体的常用样本分布设$X_{1},X_{2}\\cdots,X_{n}$为来自正态总体$N(\\mu,\\sigma^{2})$的样本，$\\overline{X} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i},S^{2} = \\frac{1}{n - 1}\\sum_{i = 1}^{n}{ {(X_{i} - \\overline{X})}^{2} }$，则： $\\overline{X}\\sim N\\left( \\mu,\\frac{\\sigma^{2} }{n} \\right){\\ \\ }$或者$\\frac{\\overline{X} - \\mu}{\\frac{\\sigma}{\\sqrt{n} } }\\sim N(0,1)$ $\\frac{(n - 1)S^{2} }{\\sigma^{2} } = \\frac{1}{\\sigma^{2} }\\sum_{i = 1}^{n}{ {(X_{i} - \\overline{X})}^{2}\\sim\\chi^{2}(n - 1)}$ $\\frac{1}{\\sigma^{2} }\\sum_{i = 1}^{n}{ {(X_{i} - \\mu)}^{2}\\sim\\chi^{2}(n)}$ ${\\ \\ }\\frac{\\overline{X} - \\mu}{S/\\sqrt{n} }\\sim t(n - 1)$ 重要公式与结论 对于$\\chi^{2}\\sim\\chi^{2}(n)$，有$E(\\chi^{2}(n)) = n,D(\\chi^{2}(n)) = 2n$； 对于$T\\sim t(n)$，有$E(T) = 0,D(T) = \\frac{n}{n - 2}(n &gt; 2)$； 对于$F\\sim{\\ }F(m,n)$，有 $\\frac{1}{F}\\sim F(n,m),F_{a/2}(m,n) = \\frac{1}{F_{1 - a/2}(n,m)}$； 对于任意总体$X$，有 $E(\\overline{X}) = E(X),E(S^{2}) = D(X),D(\\overline{X}) = \\frac{D(X)}{n}$ 参数估计点估计矩估计法最大似然估计法基于截尾样本的最大似然估计估计量的评选标准无偏性有效性相和性区间估计正态总体均值与方差的区间估计(0-1)分布参数的区间估计单侧置信区间假设试验假设检验正态总体均值的假设检验单个总体$N(\\mu,\\sigma^2)$均值$\\mu$的检验$\\sigma^2$已知，关于$\\mu$的检验（Z检验）$\\mu$已知，关于$\\sigma^2$的检验（t检验）两个正态总体均值差的检验（t检验）基于成对数据的检验（t检验）正态总体方差的假设检验单个总体的情况两个总体的情况置信区间与假设检验之间的关系样本容量的选取分布拟合检验单个分布的$\\chi^2$拟合检验法分布族的$\\chi^2$拟合检验偏度、峰度检验秩和检验假设检验问题的p值检验法","link":"/2018/12/03/2018-12-03-概率论与数理统计/"},{"title":"图论","text":"这里用类似邻接表的方法存图。有的算法可能需要邻接矩阵，详见线性代数部分。 12345678910111213141516171819202122232425struct Graph{ struct Vertex { vector&lt;int&gt; o, i; //相关出边和入边编号 int siz, dep, top, dfn; //树链剖分中使用，依次代表子树节点数、深度、所在链的顶端节点、dfs序 }; struct Edge : pair&lt;int, int&gt; { ll len, cap; //边长、容量，图论算法使用 }; vector&lt;Vertex&gt; v; //点集 vector&lt;Edge&gt; e; //边集 Graph(int n) : v(n) {} void add(const Edge &amp;ed) { if (ed.first == ed.second) return; //如果有需要请拆点 v[ed.first].o.push_back(e.size()); v[ed.second].i.push_back(e.size()); e.push_back(ed); } int ch(int u, int i = 0) { return e[v[u].o[i]].second; } //u的第i个孩子节点 int fa(int u, int i = 0) { return e[v[u].i[i]].first; } //u的第i个父节点}; 最短路Dijkstra算法使用示例，适用于边权为正的情况（无论有向图还是无向图），用于求单源最短路。 直接给出其优先队列优化的版本。另外，由于priority_queue并不提供修改优先级的操作，为避免重复扩展，这里选择将新元素直接插入队列并在运行时判断该点是否被处理，并不影响结果的正确性。 1234567891011121314151617181920212223242526struct Dijkstra : Graph{ vector&lt;ll&gt; d; vector&lt;int&gt; p; Dijkstra(int n) : Graph(n) {} void ask(int s) { d.assign(v.size(), INF); p.assign(v.size(), NPOS); priority_queue&lt;pair&lt;ll, int&gt;&gt; q; for (q.push(make_pair(d[s] = 0, s)); !q.empty();) { ll dis = -q.top().first; int u = q.top().second; if (q.pop(), d[u] &lt; dis) continue; for (int i = 0, k, to; i != v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, d[to] &gt; d[u] + e[k].len) { d[to] = d[u] + e[k].len, p[to] = k; q.push(make_pair(-d[to], to)); } } }}; BellmanFord算法使用示例，直接给出其队列优化、国内称之为SPFA算法的版本。较之Dijkstra算法，此算法不够快速稳定但是可以允许负边存在，当s到达负权回路时会直接返回0。稀疏图上性能优秀。 1234567891011121314151617181920212223242526struct BellmanFord : Graph{ vector&lt;ll&gt; d; vector&lt;int&gt; p; BellmanFord(int n) : Graph(n) {} bool ask(int s) { d.assign(v.size(), INF); p.assign(v.size(), NPOS); vector&lt;int&gt; cnt(v.size(), 0), flag(v.size(), d[s] = 0); for (deque&lt;int&gt; q(cnt[s] = flag[s] = 1, s); !q.empty(); q.pop_front()) for (int u = q.front(), i = flag[u] = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, d[to] &gt; d[u] + e[k].len) { d[to] = d[u] + e[k].len, p[to] = k; if (!flag[to]) { if (v.size() == ++cnt[to]) return 0; flag[to] = 1, q.push_back(to); } } return 1; }}; 差分约束系统按如下方式建图、跑SPFA： 对每个不等式$x_i−x_j\\leq d$，从$j$向$i$连一条边，边长为$d$。 若不等号的方向相反，即$x_i−x_j\\geq d$，则在不等式两边同时乘以$-1$，变成$x_j−x_i\\leq -d$，即从$i$到$j$连一条边，边长为$d$。 Floyed求多源最短路不连通的权置INF。 1234567891011struct Floyed : Matrix{ void ask() { for (int k = 0; k &lt; n; ++k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; }}; Astar求k短路使用示例，在这个比较坑的例子中需要在调用前补一句if(s==t)++k;。k下标从0开始，即最短路==第0短路。 朴素的想法是使用priority_queue从原点出发向外探索，当取出终点t第k次时就得到第k短路，类似bfs的思想，缺陷是越往后状态数越多。 我们在反向图上从$t\\to s$跑Astar算法，通过优先展开到s近的状态，使搜索方向靠近答案，而不是一层一层全都展开，估价函数$f\\approx g+h$，f是估计的s到t的距离，g是到达当前点已经点的花费，h是预计剩下的花费。这里h取当前点的距离到s距离，可通过从s跑一遍Dijkstra可以预处理得出。 Astar算法是只有到达终点的时候才能统计答案，这导致可能拓展很多个状态才能得到一个用来更新答案的有效状态。例如一个n元环，当我们到达终点之后,可能还要拓展n次才能得到下一个状态，于是时间复杂度就被卡到$O(nk)$。 12345678910111213141516171819202122232425struct Astar : Dijkstra{ vector&lt;ll&gt; ans; Astar(int n) : Dijkstra(n) {} void ask(int s, int t, int k) { Dijkstra::ask(s); ans.assign(k, INF); if (d[t] == INF) return; vector&lt;int&gt; cnt(v.size(), 0); priority_queue&lt;pair&lt;ll, int&gt;&gt; q; for (q.push(make_pair(-d[t], t)); cnt[s] &lt; k &amp;&amp; !q.empty();) { ll dis = -q.top().first; int u = q.top().second; if (u == s) ans[cnt[s]] = dis; if (q.pop(), ++cnt[u] &gt; k) continue; for (int i = 0, k; i &lt; v[u].i.size(); ++i) k = v[u].i[i], q.push(make_pair(d[u] - d[e[k].first] - e[k].len - dis, e[k].first)); } }}; 网络流ISAP求最大流使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct ISAP : Graph{ ll flow; vector&lt;ll&gt; f; vector&lt;int&gt; h, cur, gap; ISAP(int n) : Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.first, ed.second), ed.cap = 0; Graph::add(ed); } ll dfs(int s, int u, int t, ll r) { if (r == 0 || u == t) return r; ll _f, _r = 0; for (int &amp;i = cur[u], k; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], h[u] == h[e[k].second] + 1) { _f = dfs(s, e[k].second, t, min(r - _r, e[k].cap - f[k])); f[k] += _f, f[k ^ 1] -= _f, _r += _f; if (_r == r || h[s] &gt;= v.size()) return _r; } if (!--gap[h[u]]) h[s] = v.size(); return ++gap[++h[u]], cur[u] = 0, _r; } void ask(int s, int t) { h.assign(v.size(), 0); cur.assign(v.size(), 0); gap.assign(v.size() + 2, 0); /* for(deque&lt;int&gt; q(h[t]=gap[t]=1,t); !q.empty(); q.pop_front())//优化，加了能快一点 for(int i=0,u=q.front(),k,to; i&lt;v[u].o.size(); ++i) if(to=e[v[u].o[i]].second,!h[to]) ++gap[h[to]=h[u]+1],q.push_back(to); */ for (f.assign(e.size(), flow = 0); h[s] &lt; v.size();) flow += dfs(s, s, t, INF); }}; PrimalDual求费用流使用示例，定义一条边的费用为流量*边长，求总费用最小的最大流。性能优秀，只能跑非负权图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct PrimalDual : Graph{ ll flow, cost; vector&lt;ll&gt; f; PrimalDual(int n) : Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1; Graph::add(ed); } void ask(int s, int t) //询问s到t的最小费用最大流，答案存在flow、cost中 { vector&lt;int&gt; p(v.size(), NPOS); vector&lt;ll&gt; d(v.size(), INF), h(v.size(), 0); for (f.assign(e.size(), flow = cost = 0);;) { priority_queue&lt;pair&lt;ll, int&gt;&gt; q; for (q.push(make_pair(d[s] = 0, s)); !q.empty();) { ll dis = -q.top().first; int u = q.top().second; if (q.pop(), d[u] &lt; dis) continue; for (int i = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, e[k].cap &gt; f[k] &amp;&amp; d[to] &gt; d[u] + e[k].len + h[u] - h[to]) { d[to] = d[u] + e[k].len + h[u] - h[to], p[to] = k; q.push(make_pair(-d[to], to)); } } if (d[t] == INF) return; for (int i = 0; i &lt; d.size(); ++i) if (d[i] != INF) h[i] += d[i], d[i] = INF; ll _f = INF; for (int u = t; u != s; u = e[p[u]].first) _f = min(_f, e[p[u]].cap - f[p[u]]); for (int u = t; u != s; u = e[p[u]].first) cost += _f * e[p[u]].len, f[p[u]] += _f, f[p[u] ^ 1] -= _f; flow += _f; } }}; EK求费用流使用示例，定义一条边的费用为流量*边长，求总费用最小的最大流。BellmanFord算法找增广路，可能被卡但是可以跑负费用流（最大费用流）。 1234567891011121314151617181920212223242526272829303132333435363738struct EdmondKarp : Graph{ ll flow, cost; vector&lt;ll&gt; f; EdmondKarp(int n) : Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1; Graph::add(ed); } void ask(int s, int t) { vector&lt;int&gt; p(v.size(), NPOS); for (f.assign(e.size(), flow = cost = 0);;) { vector&lt;ll&gt; d(v.size(), INF); vector&lt;int&gt; flag(v.size(), d[s] = 0); for (deque&lt;int&gt; q(flag[s] = 1, s); !q.empty(); q.pop_front()) for (int u = q.front(), i = flag[u] = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, e[k].cap &gt; f[k] &amp;&amp; d[to] &gt; d[u] + e[k].len) { d[to] = d[u] + e[k].len, p[to] = k; if (!flag[to]) q.push_back(to), flag[to] = 1; } if (d[t] == INF) return; ll _f = INF; for (int u = t; u != s; u = e[p[u]].first) _f = min(_f, e[p[u]].cap - f[p[u]]); for (int u = t; u != s; u = e[p[u]].first) cost += _f * e[p[u]].len, f[p[u]] += _f, f[p[u] ^ 1] -= _f; flow += _f; } }}; ZKW求费用流使用示例，定义一条边的费用为流量*边长，求总费用最小的最大流。 对于最终流量较大，而费用取值范围不大的图，或者是增广路径比较短的图（如二分图），zkw算法都会比较快，原因是充分发挥优势。比如流多说明可以同一费用反复增广，费用窄说明不用改太多距离标号就会有新增广路，增广路径短可以显著改善最坏情况，因为即使每次就只增加一条边也可以很快凑成最短路。如果恰恰相反，流量不大，费用不小，增广路还较长，就不适合 zkw 算法了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct ZKW : Graph{ ll flow, cost; vector&lt;ll&gt; h, f; vector&lt;int&gt; vis; ZKW(int n) : Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1; Graph::add(ed); } ll dfs(int u, int t, ll r) { if (r == 0 || u == t) return r; if (vis[u]) return 0; ll _f = vis[u] = 1, _r = 0; for (int i = 0, k; r &gt; _r &amp;&amp; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], h[e[k].second] + e[k].len == h[u]) _f = dfs(e[k].second, t, min(r - _r, e[k].cap - f[k])), f[k] += _f, f[k ^ 1] -= _f, _r += _f; return _r; } void ask(int s, int t) { h.assign(v.size(), 0); vis.assign(v.size(), 0); for (f.assign(e.size(), flow = cost = 0);;) { ll _f = dfs(s, t, INF), d = INF; flow += _f, cost += _f * h[s]; for (int u = 0; u &lt; v.size(); ++u) for (int i = 0, k; vis[u] &amp;&amp; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], !vis[e[k].second] &amp;&amp; e[k].cap &gt; f[k]) d = min(d, e[k].len + h[e[k].second] - h[e[k].first]); if (d == INF) return; for (int i = 0; i &lt; v.size(); ++i) if (vis[i]) h[i] += d, vis[i] = 0; } }}; 上下界有源汇网络流T向S连容量正无穷的边，将有源汇转化为无源汇。每条边容量减去下界，设$in[i]$表示流入i的下界之和减去流出i的下界之和。新建超级源汇SS,TT，对于$in[i]&gt;0$的点，SS向i连容量为$in[i]$的边。对于$in[i]&lt;0$的点，i向TT连容量为$−in[i]$的边。 求出以 SS,TT 为源汇的最大流，如果等于$\\sum in[i](in[i] &gt; 0)$则存在可行流。再求出以S,T为源汇的最大流即为最大流。 费用流：建完图后等价于求以SS,TT为源汇的的费用流。 上下界费用流：先把下界的费用加入答案。 判断边是否属于某一割集在残余网络 (还有流量的边) 中求强连通分量，顶点不在同一 SCC 且满流的边。 判断边是否为全部最小割集的边： 在上一条的基础上，还要满足起点与 S 在同一 SCC，且终点与T在同一SCC。 线性规划转费用流首先添加松弛变量，将不等号都变为等号。分别用下一个式子减去上一个式子，如果每个变量只出现了两次且符号一正一负，那么可以转化为费用流。对于每个式子建立一个点，那么每个变量对应一条边，从一个点流出，向另一个点流入。这样，对于等式右边的常数，如果是正的，对应从源点向该点连一条流量C，费用0的边；如果是负的对应从该点向汇点连一条流量−C，费用0的边。对于每个变量，从它系数为正的式子向系数为负的式子连一条容量为 inf，费用为它在目标函数里系数的边。这样网络流模型就构造完毕了。 欧拉路使用示例，给定无孤立结点图G，若存在一条路，经过图中每边一次且仅一次，该条路称为欧拉路。 无向图：当仅当该图所有顶点的度数为偶数（此时为回路），或除两个度数为奇数外（作为路径的起点和终点）、其余全为偶数。 有向图：当仅当该图所有顶点出度=入度（此时为回路），或一个顶点出度=入度+1（作为起点）、另一个顶点入度=出度+1（作为终点）、其他顶点出度=入度。 混合图欧拉回路判定：首先给无向边随便定一个方向，设$\\deg x$为x连出去的边数−连入x的边数。若存在$\\deg x$为奇数，或者图不连通，则无解。否则建立源点S，汇点T。对于一个点x，若$\\deg x&gt;0$，则S向x连边，容量$\\frac{\\deg x}{2}$；若$\\deg x&lt;0$，则x向T连边，容量$-\\frac{\\deg x}{2}$。 对于一条定了向的无向边$x\\to y$，x向y连边，容量1，求出最大流，若与 S 和T连的每条边都满流，则有解。 1234567891011121314151617181920212223struct Fleury : Graph{ vector&lt;int&gt; vis, cur, p; Fleury(int n) : Graph(n) {} void dfs(int u) { for (int &amp;i = cur[u], k; i &lt; v[u].i.size(); ++i) //遍历原图的反向图，这里加了一个“当前弧”优化 if (k = v[u].i[i], !vis[k] &amp;&amp; !vis[k ^ 1]) //无向图需要同时检查反向边未被访问过 { vis[k] = 1; dfs(e[k].first); p.push_back(k); } } void ask() //查询欧拉回路，路径上边的序号按顺序存在p中 { vis.assign(e.size(), 0), cur.assign(v.size(), 0), p.clear(); for (int i = 0; i &lt; v.size(); ++i) if (v[i].i.size() % 2) return dfs(i); dfs(0); }}; 连通性无向图求割和双连通分量使用示例割边：在连通图中，删除了连通图的某条边后，图不再连通。这样的边被称为割边，也叫做桥。 割点：在连通图中，删除了连通图的某个点以及与这个点相连的边后，图不再连通。这样的点被称为割点。构造dfs搜索树，在树上有两类节点可以成为割点： 对根节点u，若其有两棵或两棵以上的子树，则该根结点u为割点； 对非根非叶节点u，若其中的某棵子树的节点均没有指向u的祖先节点的回边，说明删除u之后，根结点与该棵子树的节点不再连通；则节点u为割点。 对于一个无向图的子图，当删除其中任意一条边后，不改变图内点的连通性，这样的子图叫做边的双连通子图。而当子图的边数达到最大时，叫做边的双连通分量。原理是图中所有割边再求一次SCC，可直接使用求SCC的代码。 对于一个无向图的子图，当删除其中任意一个点后，不改变图内点的连通性，这样的子图叫做点的双连通子图。而当子图的边数达到最大时，叫做点的双连通分量。下面给出求点双连通分量的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct BCC : Graph //Biconnected Connected Componenet{ vector&lt;int&gt; low, bid, stak, cutPoint, cutEdge; //连通块最早dfs序，边的端点所属双连通块 int bcc_siz; BCC(int n) : Graph(n) {} void ask() { low.assign(v.size(), NPOS); bid.assign(e.size(), NPOS); cutPoint.assign(v.size(), 0); cutEdge.assign(e.size(), 0); for (int i = bcc_siz = 0, cnt = 0; i &lt; v.size(); ++i) if (low[i] == NPOS) dfs(i, NPOS, cnt); } void dfs(int u, int fa, int &amp;cnt) { low[u] = v[u].dfn = ++cnt; for (int i = 0, k, to, ch = 0; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, to != fa) { if (low[to] == NPOS) { ++ch; stak.push_back(k); dfs(to, u, cnt); low[u] = min(low[u], low[to]); if (low[to] &gt;= v[u].dfn) for (++bcc_siz, cutPoint[u] = fa != NPOS || ch &gt; 1;;) { int x = stak.back(); stak.pop_back(); bid[x] = bid[x ^ 1] = bcc_siz - 1; if (x == k) break; } if (low[to] &gt; v[u].dfn) cutEdge[k] = cutEdge[k ^ 1] = 1; } else if (v[to].dfn &lt; v[u].dfn) { stak.push_back(k); low[u] = min(low[u], v[to].dfn); } } }}; 双连通图的构造先求出所有的桥，然后删除这些桥边，剩下的每个连通块都是一个双连通子图。把每个双连通子图收缩为一个顶点，再把桥边加回来，最后的这个图一定是一棵树，边连通度为1。统计出树中度为1的节点的个数，即为叶节点的个数，记为leaf。至少在树上添加(leaf+1)/2条边，就能使树达到边双连通：先把两个最近公共祖先最远的两个叶节点之间连接一条边，这样可以把这两个点到祖先的路径上所有点收缩到一起，因为一个形成的环一定是双连通的；然后再找两个最近公共祖先最远的两个叶节点，这样一对一对找完，恰好是(leaf+1)/2次，把所有点收缩到了一起。 有向图求强连通分量使用示例，如果是无向图，求出来的还是边双连通分量。 123456789101112131415161718192021222324252627282930313233343536struct SCC : Graph //Strongly Connected Componenet{ vector&lt;int&gt; low, sid, stak; //连通块最早dfs序，点所属连通块 int scc_siz; SCC(int n) : Graph(n) {} void ask() { low.assign(v.size(), NPOS); sid.assign(v.size(), NPOS); for (int i = scc_siz = 0, cnt = 0; i != v.size(); ++i) if (low[i] == NPOS) dfs(i, NPOS, cnt); } void dfs(int u, int fa, int &amp;cnt) { low[u] = v[u].dfn = ++cnt; stak.push_back(u); for (int i = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, to != fa, 1) //求边双连通分量把\",1\"注释掉，即不许走回边 { if (low[to] == NPOS) dfs(to, u, cnt), low[u] = min(low[u], low[to]); else if (sid[to] == NPOS) low[u] = min(low[u], v[to].dfn); } if (low[u] == v[u].dfn) for (++scc_siz;;) { int x = stak.back(); stak.pop_back(); sid[x] = scc_siz - 1; if (x == u) break; } }}; 2-SAT使用示例，n个布尔变量$x_0\\ldots x_{n-1}$，逻辑表达式$Y=(A_0+B_0)(A_1+B_1)\\ldots(A_{m-1}+B_{m-1})$，其中$A_i,B_i\\in{x_j,\\overline{x_j}}$，判断是否存在$x_0\\ldots x_{n-1}$的取值使得Y值为1。因为$A+B=(\\overline A\\to B)(\\overline B\\to A)$，所以对于一个要求$A+B$，我们连$\\overline A\\to B,\\overline B\\to A$两条边。如果有一条边$A\\to B$，意味着如果A成立那么B必然成立。若$\\exists i,x_i,\\overline{x_i}\\in$同一SCC，则不存在。 二分图二分图的一个等价定义是：不含有含奇数条边的环的图。 完美匹配图中所有的顶点都是匹配点。 二分图的最小点覆盖（最小割）是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联。二分图中，最小割=最大匹配。 二分图的最小边覆盖（最大独立集）是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。二分图中，最小点覆盖+最小边覆盖=总点数。 Hall定理：二分图中的两部分顶点组成的集合分别为 X,Y ，则有一组无公共点的边，一端恰好为组成 X 的点的充分必要条件是：X 中的任意 k 个点至少与 Y 中的 k 个点相邻。对于区间图只需要考虑极端情况，线段树维护。 关键点：一定在最大匹配中的点。 求出任意一个最大匹配，那么只需要考虑哪些匹配点不一定在。 假设是考虑左侧的点，右侧类似： 将匹配边从右往左，非匹配边从左到右，从左侧每个未匹配点开始DFS到的匹配点都不是关键点。 关键边：求出任意一个最大匹配，将匹配边从右到左，剩余边从左到右，求出 SCC。 对于一条边：若它位于当前匹配中，那么若两端点位于同一SCC，则是可能在，否则必定在；若它不位于当前匹配中，那么若两端点位于同一 SCC，则是可能在，否则必定不在。 Hungary求最大匹配使用示例 左边nl个点$0\\ldots nl-1$，右边nr个点$0\\ldots nr-1$，取n=max(nl,nr)，左i右j间代价a[x][y]。 生成fl[i]表示左边第i个匹配右边第fl[i]个（对应权a[i][fl[i]]），fr同理。时间复杂度$O(n^3)$。 稀疏图的时候考虑用邻接表代替邻接矩阵，并且找完全匹配的时候有问题可直接return。 匹配是一个边集，其中任意两条边都没有公共顶点；扫一遍fl或fr判断有多少不等于NPOS即为最大匹配数。 12345678910111213141516171819struct Hungary : Matrix{ int fl[N], fr[N], vr[N]; bool dfs(int x, int rt) { for (int y = 0; y &lt; n; ++y) if (a[x][y] &amp;&amp; vr[y] != rt) if (vr[y] = rt, fr[y] == NPOS || dfs(fr[y], rt)) return fl[fr[y] = x] = y, 1; return 0; } void ask() { fill(fl, fl + n, NPOS), fill(fr, fr + n, NPOS), fill(vr, vr + n, NPOS); for (int i = 0; i &lt; n; ++i) if (fl[i] == NPOS) dfs(i, i); }} HopcroftKarp求最大匹配使用示例，时间复杂度$O(\\sqrt{|V|}|E|)$，稀疏图上效果明显。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct HopcroftKarp{ vector&lt;int&gt; g[N]; int n, fl[N], fr[N], hl[N], hr[N], q[N]; bool dfs(int x) { for (int i = 0, c = hl[x] + 1, y = hl[x] = NPOS; i &lt; g[x].size(); ++i) if (hr[y = g[x][i]] == c) if (hr[y] = NPOS, fr[y] == NPOS || dfs(fr[y])) return fl[fr[y] = x] = y, 1; return 0; } void ask() { fill(fl, fl + n, NPOS), fill(fr, fr + n, NPOS); for (int x = 0; x &lt; n; ++x) for (int i = 0, y; i &lt; g[x].size(); ++i) if (fr[y = g[x][i]] == NPOS) { fl[fr[y] = x] = y; break; } for (int ql, qr, ok;;) { fill(hl, hl + n, NPOS), fill(hr, hr + n, NPOS); for (int x = ql = qr = ok = 0; x &lt; n; ++x) if (fl[x] == NPOS) hl[q[qr++] = x] = 0; while (ql &lt; qr) for (int i = 0, x = q[ql++], y; i &lt; g[x].size(); ++i) if (hr[y = g[x][i]] == NPOS) { hr[y] = hl[x] + 1; if (fr[y] == NPOS) ok = 1; else if (hl[fr[y]] == NPOS) hl[q[qr++] = fr[y]] = hr[y] + 1; } if (!ok) return; for (int x = 0; x &lt; n; ++x) if (fl[x] == NPOS) dfs(x); } }}; KuhnMunkres求最优完备匹配使用示例，最大费用流时，a初始化0；最大费用最大流时，a初始化-N*INF。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct KuhnMunkres : Matrix{ ll hl[N], hr[N], slk[N]; int fl[N], fr[N], vl[N], vr[N], pre[N], q[N], ql, qr; int check(int i) { if (vl[i] = 1, fl[i] != NPOS) return vr[q[qr++] = fl[i]] = 1; while (i != NPOS) swap(i, fr[fl[i] = pre[i]]); return 0; } void bfs(int s) { fill(slk, slk + n, INF), fill(vl, vl + n, 0), fill(vr, vr + n, 0); for (vr[q[ql = 0] = s] = qr = 1;;) { for (ll d; ql &lt; qr;) for (int i = 0, j = q[ql++]; i &lt; n; ++i) if (!vl[i] &amp;&amp; slk[i] &gt;= (d = hl[i] + hr[j] - a[i][j])) if (pre[i] = j, d) slk[i] = d; else if (!check(i)) return; ll d = INF; for (int i = 0; i &lt; n; ++i) if (!vl[i] &amp;&amp; d &gt; slk[i]) d = slk[i]; for (int i = 0; i &lt; n; ++i) { if (vl[i]) hl[i] += d; else slk[i] -= d; if (vr[i]) hr[i] -= d; } for (int i = 0; i &lt; n; ++i) if (!vl[i] &amp;&amp; !slk[i] &amp;&amp; !check(i)) return; } } void ask() { fill(fl, fl + n, NPOS), fill(fr, fr + n, NPOS), fill(hr, hr + n, 0); for (int i = 0; i &lt; n; ++i) hl[i] = *max_element(a[i], a[i] + n); for (int j = 0; j &lt; n; ++j) bfs(j); }}; 带花树一般图最大匹配使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Blossom : Graph{ vector&lt;int&gt; f; Blossom(int n) : Graph(n) {} void ask() { vector&lt;int&gt; vis(v.size(), NPOS); f = vis; for (int s = 0, t = 0; s &lt; v.size(); ++s) if (f[s] == NPOS) { UnionfindSet ufs(v.size()); vector&lt;int&gt; pre(v.size(), NPOS), flag(pre); for (deque&lt;int&gt; q(flag[s] = 1, s); f[s] == NPOS &amp;&amp; !q.empty(); q.pop_front()) for (int i = 0, x = q.front(), y, a, b; i &lt; v[x].o.size(); ++i) if (y = e[v[x].o[i]].second, y != f[x] &amp;&amp; flag[y] &amp;&amp; ufs.ask(x) != ufs.ask(y)) { if (flag[y] == 1) { for (a = x, b = y, ++t;; swap(a, b)) if (a != NPOS) { if (vis[a = ufs.ask(a)] == t) break; vis[a] = t, a = f[a] != NPOS ? pre[f[a]] : NPOS; } if (ufs.ask(x) != a) pre[x] = y; if (ufs.ask(y) != a) pre[y] = x; for (int p[2] = {x, y}, j = 0; j &lt; 2; ++j) for (int x = p[j], y, z; x != a; ufs.merge(y, x), ufs.merge(x = z, y)) { if (ufs.ask(z = pre[y = f[x]]) != a) pre[z] = y; if (!flag[y]) flag[y] = 1, q.push_back(y); if (!flag[z]) flag[z] = 1, q.push_back(z); } } else if (f[y] == NPOS) { for (pre[y] = x; y != NPOS;) swap(y, f[f[y] = pre[y]]); break; } else pre[y] = x, q.push_back(f[y]), flag[f[y]] = 1, flag[y] = 0; } } }}; 树形图最小生成树无向图同时给出Prim算法（生成新树）、Kruskal算法（消耗小）。 1234567891011121314151617181920212223242526272829303132333435363738394041struct Prim : Graph{ struct DisGreater { bool operator()(const Edge &amp;e1, const Edge &amp;e2) { return e1.len &gt; e2.len; } }; ll ans; vector&lt;int&gt; vis; priority_queue&lt;Edge, vector&lt;Edge&gt;, DisGreater&gt; q; Prim(const Graph &amp;g, int root) : Tree(n), ans(0), vis(g.v.size(), 0) //生成新树，每条边都要有等长反向边 { for (insert(root, g); !q.empty();) { Edge ed = q.top(); if (q.pop(), !vis[ed.second]) insert(ed.second, g), ans += ed.len, add(ed); } } void insert(int u, const Graph &amp;g) //把点和对应的相连的边加入集合 { vis[u] = 1; for (int i = 0, k; i &lt; g.v[u].o.size(); ++i) if (k = g.v[u].o[i], !vis[g.e[k].second]) q.push(g.e[k]); }};ll kruskal(vector&lt;Edge&gt; &amp;e, int n) //会清空边集e，每条边被认作无向边{ ll ret = 0; UnionFindSet ufs(n); for (sort(e.begin(), e.end(), DisGreater()); !e.empty(); e.pop_back()) if (ufs.fa(e.back().from) != ufs.fa(e.back().to)) { ufs.merge(e.back().from, e.back().to); ret += e.back().len; } return /*ufs.siz&gt;1?INF:*/ ret; //视情况选择去注释} 有向图使用示例 指定以root为根，如果没有限定根那么新建一个虚拟点作为根，向所有边连边长最大边长+1的边，在最后生成的图中去掉此边。时间复杂度$O(VE)$。 12345678910111213141516171819202122232425262728293031323334353637383940ll zhuLiu(vector&lt;Edge&gt; &amp;e, int root, int n) //不存在返回INF{ for (ll ret = 0;;) { vector&lt;ll&gt; in(n, INF); vector&lt;int&gt; pre(n, NPOS); for (int i = 0, to; i &lt; e.size(); ++i) { if (e[i].first == (to = e[i].second)) swap(e[i--], e.back()), e.pop_back(); else if (in[to] &gt; e[i].len) in[to] = e[i].len, pre[to] = e[i].first; } for (int i = in [root] = 0; i &lt; n; ++i) if (in[i] == INF) return INF; vector&lt;int&gt; id(n, NPOS), vis(n, NPOS); int tn = 0; for (int i = 0, v; i &lt; n; ++i) { for (ret += in [v = i]; vis[v] != i &amp;&amp; id[v] == NPOS &amp;&amp; v != root; v = pre[v]) vis[v] = i; if (v != root &amp;&amp; id[v] == NPOS) { for (int u = pre[v]; u != v; u = pre[u]) id[u] = tn; id[v] = tn++; } } if (!tn) return ret; for (int i = 0; i &lt; n; ++i) if (id[i] == NPOS) id[i] = tn++; for (int i = 0, v; i &lt; e.size(); ++i) if ((e[i].first = id[e[i].first]) != (e[i].second = id[v = e[i].second])) e[i].len -= in[v]; n = tn, root = id[root]; }} 树链剖分与LCA使用示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct Diagram : Graph{ Fenwick data; //暂用树状数组作为默认数据结构 Diagram(const Graph &amp;g, int root) : Graph(g.v.size()), data(g.v.size()) { build(root, g); int cnt = v[root].dfn = v[root].dep = 1; dfs(v[root].top = root, cnt); } void build(int u, const Graph &amp;g) //无向图dfs建树，且重边在最前，u为根节点 { v[u].siz = 1; for (int i = 0, k, to; i &lt; g.v[u].o.size(); ++i) if (k = g.v[u].o[i], to = g.e[k].second, !v[to].siz) //没访问过的点siz默认0 { build(to, g); v[u].siz += v[to].siz; Graph::add(g.e[k]); if (v[ch(u)].siz &lt; v[to].siz) //重边移到最前 swap(v[u].o.front(), v[u].o.back()); } } void dfs(int u, int &amp;cnt) { for (int i = 0, to; i &lt; v[u].o.size(); ++i) { v[to = ch(u, i)].dfn = ++cnt; v[to].top = i ? to : v[u].top; v[to].dep = v[u].dep + 1; dfs(to, cnt); } } int lca(int x, int y) { for (; v[x].top != v[y].top; x = fa(v[x].top)) if (v[v[x].top].dep &lt; v[v[y].top].dep) swap(x, y); if (v[x].dep &lt; v[y].dep) swap(x, y); return y; } ll ask(int x, int y) { ll ans = 0; for (; v[x].top != v[y].top; x = fa(v[x].top)) { if (v[v[x].top].dep &lt; v[v[y].top].dep) swap(x, y); ans += data.ask(v[v[x].top].dfn, v[x].dfn); } if (v[x].dep &lt; v[y].dep) swap(x, y); return ans += data.ask(v[y].dfn, v[x].dfn); } void add(int x, int y, ll pv) { for (; v[x].top != v[y].top; x = fa(v[x].top)) { if (v[v[x].top].dep &lt; v[v[y].top].dep) swap(x, y); data.add(v[v[x].top].dfn, v[x].dfn, pv); } if (v[x].dep &lt; v[y].dep) swap(x, y); data.add(v[y].dfn, v[x].dfn, pv); }}; 点剖（点分治）使用示例，零号点为虚节点。 1234567891011121314151617181920212223242526272829303132333435struct TreeDiv : Graph{ int root; vector&lt;int&gt; mx, siz, vis; TreeDiv(int n) : Graph(n), mx(n, n), siz(n), vis(n) {} void dfsRoot(int u, int fa) { for (int i = mx[u] = siz[u] = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, to != fa &amp;&amp; !vis[to]) if (dfsRoot(to, u), siz[u] += siz[to], mx[u] &lt; siz[to]) mx[u] = siz[to]; if (mx[u] &lt; mx[0] - ++siz[u]) mx[u] = mx[0] - siz[u]; if (mx[root] &gt;= mx[u]) root = u; } void dfsDis(int u, int fa, ll d) { //用d更新答案 for (int i = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, to != fa &amp;&amp; !vis[to]) dfsDis(to, u, d + e[k].len); } int cal(int u, ll d) //返回符合要求的点对数 { return dfsDis(u, 0, d), /*得到答案*/; } void dfs(int u = 1) { dfsRoot(u, root = 0), ans += cal(u = root, 0), vis[u] = 1; for (int i = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, !vis[to]) ans -= cal(to, e[k].len), mx[0] = siz[to], dfs(to); }};","link":"/2019/02/03/2019-02-03-图论/"},{"title":"Vmware虚拟机安装和配置Ubuntu系统","text":"创建带有 SCSI 控制器类型、虚拟机磁盘类型以及与旧版 VMware 产品兼容性等高级选项的虚拟机 安装前准备： 安装好VMwareWorkstation Ubuntu16.04镜像文件 （下载地址链接：https://pan.baidu.com/s/1MSBBv9NOh7_cFgTMUQPEhQ 提取码：w6g7 ） Ubuntu18.04镜像文件 （下载地址链接：链接：https://pan.baidu.com/s/1uhPj0ttM9M7QxpR3Z4LI5g 提取码：il08 ） 一、Ubuntu的初步安装 创建新的虚拟机 点击下一步，如下图所示 选择兼容性版本 注意修改的信息 修改处理器配置信息，如下图所示 虚拟机内存配置，最低要求2GB,可以根据自己的需求修改，后期也可以再更改 此时，切记千万不要手快点开电源！！！ 二、Ubuntu系统安装设置 设置加载镜像 这些完成后就可以直接开启虚拟机了 拖动窗口，点 continue 继续下一步 设置自己的用户名和密码 : 安装进行中，等待安装 点击 Restart Now 进行重启， 如果出现如下图所示的状况，导致无法进入系统界面，需要点击Vmware的重新启动客户机按钮进行重新启动 如下图所示： 如果出现如下情况，切记千万不要选择更新 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 然后，修改hosts文件 etc目录下的hosts文件 使用vim修改编辑hosts文件sudo vi /etc/hosts 使用gedit修改编辑hosts文件sudo gedit /etc/hosts 如此，即代表系统安装成功 三、安装Vmware Tools 为了让系统能像下图一样适应客户机，需要安装Vmware Tools 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 获取管理员权限 输入以下命令，来获取管理员权限，密码是你在上面设置的密码：sudo passwd 前面我设置的密码是chuanzhi 如果上面你设置的密码不是chuanzhi,请输入你自己设置的密码 切换到 root 最高权限用户 安装Vmware tools工具 选择Vmware顶部工具栏里的 安装Vmware Tools（T）选项 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 打开终端后，进行下面设置 复制CD中的 VMwareTools-10.0.10-4301679.tar.gz 文件到根目录下： cp /media/user/VMware\\ Tools/VMwareTools-10.0.10-4301679.tar.gz / 然到移动到根目录： cd / 解压 VMwareTools-10.0.10-4301679.tar.gz： tar -zxvf VMwareTools-10.0.10-4301679.tar.gz 按下回车，执行解压 如下如所示 解压完成后进入解压文件夹vmware-tools-distrib cd vmware-tools-distrib 运行安装程序： ./vmware-install.pl 一路 y 加 回车 如下图所示 四、设置共享文件夹 设置共享文件夹，可以实现Windows系统和Ubuntu系统的复制粘贴功能 在菜单栏找到虚拟机-&gt;设置，添加自己的共享文件夹 如此，即完成了Ubuntu系统的初步设置 五、修改Ubuntu系统的更新源 更改apt源为国内源方法早就有了，内容大同小异，我们应当掌握其规律了，其实每一版内容不同的地方就是版本号（或者官方一点的说：系统代号），所以我们先了解下新版本的系统代号：使用命令：lsb_release -c得到本系统的系统代号，如下图所示：同样的我们也可以得到之前任意版本的系统代号：Ubuntu 12.04 (LTS)代号为precise。Ubuntu 14.04 (LTS)代号为trusty。Ubuntu 15.04 代号为vivid。Ubuntu 15.10 代号为wily。Ubuntu 16.04 (LTS)代号为xenial。所以这也就解释了为什么利用搜索引擎搜出来的那么多方案里面内容不尽相同的原因，因为大家更改apt安装源时用的系统不一样。 *查看系统版本代号 *lsb_release -a 注意：一定要对准自己的Ubuntu系统版本代号，检查是Ubuntu16.04还是Ubuntu18.04 下面分别提供Ubuntu16.04和ubuntu 18.04两个不同系统版本的阿里源 Ubuntu16.04对应阿里源 123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse Ubuntu18.04对应阿里源 如果是Ubuntu18.04系统可以参照我的简书配置：https://www.jianshu.com/p/e5677ebd5341 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse 修改系统更新源方法步骤如下： 首先备份Ubuntu系统的官方源文件 打开Ubuntu的命令终端，进入源文件 sources.list 所在的目录： 然后执行备份命令，执行 sudo cp sources.list sources.list.backup 对源文件内容进行备份，以防万一。 12cd /etc/aptsudo cp sources.list sources.list.backup 修改源文件内容 将上述对应系统版本的阿里源的文件内容全部复制，使用 sudo vim sources.list 打开文件，输入 ggdG（vim操作指令）删除所有内容（这句指令可以理解为删除第一行到最后一行的的全部内容） 12sudo vim sources.list # 在 /etc/apt 目录下ggdG # 使用vim打开 sources.list 文件后执行此命令 将复制的阿里源文件内容全部粘贴到文件中后，输入 : 然后再输入wq 保存退出。 值得注意的是 sources.list 文件的条目都是有格式的（通过上面的内容大家也看的出来），一般有如下形式： 12deb http://site.example.com/debian distribution component1 component2 component3deb-src http://site.example.com/debian distribution component1 component2 component3 所以后面几个参数是对软件包的分类（Ubuntu下是main， restricted，universe ，multiverse这四个）所以你把内容写成: 1234deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed universe multiverse 上面之类的也是可以的，之前我有这个疑惑，所以在这里一并告知和我有一样疑惑的朋友。 更新源 使用 sudo apt-get update 即可更新获取阿里软件源 提供的软件列表 1sudo apt-get update 更新软件 使用 sudo apt-get upgrade 即可跟新软件 1sudo apt-get upgrade 如下图所示，即代表更新成功 六、安装VIM编辑器 在Ubuntu系统的命令终端输入 sudo apt-get install vim 进行下载 检测是否安装成功 在命令终端输入 vim 回车 如上图所示，即代表安装成功 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 安装完成后的 vim 是默认不显示行号的 上图中在 /etc/vim/ 目录下打开的 输入 sudo vi vimrc后是不显示行号的，如下图所示 进入编辑界面后，按下 G 键（这是大写的 G）直接跳转到文件的最后一行 再次按下 i 键，进行编辑，输入 set number 如下图所示 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 检查设置行号是否生效 如此，即代表安装好修改配置成功 七、安装谷歌浏览器 先下载谷歌浏览器的deb安装包 下载地址如下： https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 等待下载完成 安装谷歌浏览器需执行以下两步，回到终端输入以下命令 sudo apt install libappindicator1 libindicator7 关闭终端，打开下载的存放deb包的文件夹，空白处右键在这里打开终端 输入以下命令 sudo dpkg -i google-chrome-stable_current_amd64.deb 最后在终端中输入以下命令，修复依赖关系 sudo apt -f install 至此谷歌浏览器就安装好了，现在把它设置在快速启动栏 最后将其移动到快速启动栏的合适位置，右键点击图标锁定到启动器，左键拖动选择合适位置！ 至此，谷歌浏览器即安装成功 八、安装Pycharm 下载地址：https://www.jetbrains.com/pycharm/download/#section=linux 右键安装包，点击“Extract Here”意思是提取到这里，相当于解压 提取完成后，会生成一个 pycharm-2019.1.1 的文件夹，然后双击进入该文件夹 ，空白处右键在这里打开终端 选择主题 到这里，我选择秘钥激活的方法 百度：lanyus http://idea.lanyus.com/ 修改 hosts 文件（hosts文件在 /etc 目录下） 120.0.0.0 account.jetbrains.com0.0.0.0 www.jetbrains.com 将上面两行代码添加到，hosts文件中 添加后如下图所示 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 获取注册码后输入 指定Python3解释器（1） 指定Python3解释器（2） 可以通过在命令终端输入：whereis python找到系统的Python解释器路径 如此，Python3的解释器便指定完成 添加Pycharm桌面快捷方式 第一步 创建Pycharm.desktop文件并用gedit的打开 sudo gedit /usr/share/applications/Pycharm.desktop 然后就会弹出一个新框 第二步 粘贴下面的代码输入并保存 123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=sh /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.shIcon=/home/python/Downloads/pycharm-2019.1.1/bin/pycharm.pngTerminal=pycharmCategories=Pycharm 注意一定要将Desktop Entry复制进去，也就是上面的全部都要复制进去 Exec 的路径是 pycharm.sh 的所在路径，即 pycharm 的启动文件 Icon 的路径是 pycharm.png 的所在路径，即 pycharm 的图标 我下载解压后的路径，如下图 路径：/home/python/Downloads/pycharm-2019.1.1/bin Exec 的路径是 pycharm.sh 的所在路径，即 pycharm 的启动文件 /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.sh Icon 的路径是 pycharm.png 的所在路径，即 pycharm 的图标 /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.png 创建的Pycharm.desktop文件如下 123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=sh /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.shIcon=/home/python/Downloads/pycharm-2019.1.1/bin/pycharm.pngTerminal=pycharmCategories=Pycharm 修改完成后，即可发现Pycharm的快捷方式 如此，即表示配置成功 九、安装MySQL数据库 有两种安装方法，请将两种方法都阅读完后，再选择其中的一种方式进行安装 方法一 使用命令安装MySQL数据库 安装前先更新软件包列表： 12在终端执行如下命令：sudo apt-get update Vmware虚拟机安装和配置Ubuntu系统/ 在Ubuntu16.04上安装MySQL： 12在终端执行如下命令：sudo apt-get install mysql-server mysql-client 在安装过程中需要你输入MySQL管理员用户（root）密码，如下图 如上即代表安装完成 方法二 通过APT方式安装 说明：此种方式完全参考官方提供的教程:地址：https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/ 注意：通过APT方式安装的版本都是现在最新的版本，现在我安装的是5.7.18。通过这种方式安装好之后开机自启动都已经配置好，和命令行上的环境变量，无需手动配置。 下载官方提供的mysql-apt-config.deb包进行APT源设置，下载地址：https://dev.mysql.com/downloads/repo/apt/ 找到下载的包路径 输入如下命令： sudo dpkg -i mysql-apt-config_0.8.12-1_all.deb 运行之后会出现如下界面： 一般只需要默认，按方向键选择OK回车即可。 完成后使用以下命令从MySQL APT存储库更新包信息（此步骤是必需的）： sudo apt-get update 说明：官方说通过这个工具这样操作之后，安装MySQL时就是按照上面选择的来进行。 安装 通过以下命令安装MySQL sudo apt-get install mysql-server 这将安装MySQL服务器的包，以及客户端和数据库公共文件的包。 此时如果提示依赖不足，如下所示： 如果没出现依赖问题，那么就不需要使用此命令。 ​ 那么需要运行下面命令解决依赖问题 ​ sudo apt-get install -f ​ 安装MySQL时会一并安装如下所示的软件： 完成后再次运行 sudo apt-get install mysql-server 如果没出现依赖问题，那么就不需要使用此命令。 在安装过程中，系统会要求您为MySQL安装的root用户提供密码,输入即可,如下所示： 重要 确保记住您设置的root密码。想要稍后设置密码的用户可以在对话框中将 密码字段留空，只需按确定即可 ; 在这种情况下，对于使用Unix套接字文件的连接，将通过Socket Peer-Credential Pluggable Authentication对服务器的root访问进行身份 验证。您可以稍后使用程序mysql_secure_installation设置root密码 。 我这里密码设置为：mysql (为了避免忘记密码，建议设置为:mysql) MySQL8.0采用了新的加密方式，一定要注意，正是因为这个加密方式才导致Ubuntu18.04用设置的root密码登录不了MySQL，因为Ubuntu18.04的终端可能有问题，并不支持这个新的加密方式。幸好有界面可以让我们选择使用旧版本5.x的加密方式，所以果断选择采用5.x的加密方式。 确认密码","link":"/2018/05/22/Vmware虚拟机安装和配置Ubuntu系统/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"无旋Treap","slug":"无旋Treap","link":"/tags/无旋Treap/"},{"name":"珂朵莉树","slug":"珂朵莉树","link":"/tags/珂朵莉树/"},{"name":"老司机树","slug":"老司机树","link":"/tags/老司机树/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/莫比乌斯反演/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"最短路","slug":"最短路","link":"/tags/最短路/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"ICPC模板","slug":"ICPC模板","link":"/tags/ICPC模板/"},{"name":"可持久化","slug":"可持久化","link":"/tags/可持久化/"},{"name":"主席树","slug":"主席树","link":"/tags/主席树/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"动态开点","slug":"动态开点","link":"/tags/动态开点/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"环境配置","slug":"环境配置","link":"/tags/环境配置/"},{"name":"Deepin","slug":"Deepin","link":"/tags/Deepin/"},{"name":"ChromeDriver","slug":"ChromeDriver","link":"/tags/ChromeDriver/"},{"name":"Python解释器的安装与配置","slug":"Python解释器的安装与配置","link":"/tags/Python解释器的安装与配置/"},{"name":"chromedriver","slug":"chromedriver","link":"/tags/chromedriver/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"虚拟环境","slug":"虚拟环境","link":"/tags/虚拟环境/"},{"name":"Pycharm","slug":"Pycharm","link":"/tags/Pycharm/"},{"name":"Anaconda","slug":"Anaconda","link":"/tags/Anaconda/"},{"name":"励志","slug":"励志","link":"/tags/励志/"},{"name":"谷歌输入法","slug":"谷歌输入法","link":"/tags/谷歌输入法/"},{"name":"二维计算几何","slug":"二维计算几何","link":"/tags/二维计算几何/"},{"name":"扫描线","slug":"扫描线","link":"/tags/扫描线/"},{"name":"MongoDB数据库","slug":"MongoDB数据库","link":"/tags/MongoDB数据库/"},{"name":"Bug","slug":"Bug","link":"/tags/Bug/"},{"name":"pymysql","slug":"pymysql","link":"/tags/pymysql/"},{"name":"系统配置","slug":"系统配置","link":"/tags/系统配置/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/虚拟机/"}],"categories":[{"name":"程序设计","slug":"程序设计","link":"/categories/程序设计/"},{"name":"Spider","slug":"Spider","link":"/categories/Spider/"},{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"小工具","slug":"小工具","link":"/categories/小工具/"},{"name":"函数程序设计实验","slug":"函数程序设计实验","link":"/categories/函数程序设计实验/"},{"name":"题解","slug":"ACM/题解","link":"/categories/ACM/题解/"},{"name":"算法竞赛入门经典训练指南","slug":"ACM/算法竞赛入门经典训练指南","link":"/categories/ACM/算法竞赛入门经典训练指南/"},{"name":"第3章 实用数据结构","slug":"ACM/算法竞赛入门经典训练指南/第3章-实用数据结构","link":"/categories/ACM/算法竞赛入门经典训练指南/第3章-实用数据结构/"},{"name":"第2章 数学基础","slug":"ACM/算法竞赛入门经典训练指南/第2章-数学基础","link":"/categories/ACM/算法竞赛入门经典训练指南/第2章-数学基础/"},{"name":"吴恩达机器学习笔记","slug":"吴恩达机器学习笔记","link":"/categories/吴恩达机器学习笔记/"},{"name":"区间信息维护","slug":"ACM/算法竞赛入门经典训练指南/第3章-实用数据结构/区间信息维护","link":"/categories/ACM/算法竞赛入门经典训练指南/第3章-实用数据结构/区间信息维护/"},{"name":"数论","slug":"ACM/算法竞赛入门经典训练指南/第2章-数学基础/数论","link":"/categories/ACM/算法竞赛入门经典训练指南/第2章-数学基础/数论/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Template","slug":"ACM/Template","link":"/categories/ACM/Template/"},{"name":"机器学习","slug":"机器学习","link":"/categories/机器学习/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/计算机网络/"},{"name":"并行与分布式计算","slug":"并行与分布式计算","link":"/categories/并行与分布式计算/"},{"name":"超级计算机原理与操作","slug":"超级计算机原理与操作","link":"/categories/超级计算机原理与操作/"},{"name":"环境配置","slug":"环境配置","link":"/categories/环境配置/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"第4章 几何问题","slug":"ACM/算法竞赛入门经典训练指南/第4章-几何问题","link":"/categories/ACM/算法竞赛入门经典训练指南/第4章-几何问题/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/学习笔记/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/categories/计算机组成原理/"}]}