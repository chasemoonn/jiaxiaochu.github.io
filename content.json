{"pages":[{"title":"","text":"由于篇幅短小和时间仓促, 若你发现了错误请告知我。希望我没有误导你，而是带你看了小小的新世界。如果您阅读后有所收获或对您有帮助; 不妨打赏我一下，请我喝杯茶或咖啡! 您小小的支持都是对作者莫大的鼓励！","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"爬取网易财经中股票的历史交易数据","text":"爬取网易财经中股票的历史交易数据需求分析 得到股票代码 股票代码的信息是在东方财富网中获取(http://quote.eastmoney.com/stocklist.html) 得到股票的历史交易记录 股票的历史交易记录是可以在网易财经中直接下载excel表的，地址(http://quotes.money.163.com/trade/lsjysj_603088.html#06f01)这是某一股票的历史交易记录详情，我们可以在页面中找到下载的链接地址。 代码撸起来 首先我们需要在东方财富网中获取到股票的代码，在(http://quote.eastmoney.com/stocklist.html)页面中我们可以看到股票代码，我们可以利用xpath结合正则表达式将这些股票代码获取到 获取股票代码列表的代码： 1234567891011121314151617181920212223242526272829class StockCode(object): def __init__(self): self.start_url = \"http://quote.eastmoney.com/stocklist.html#sh\" self.headers = { \"User-Agent\": \":Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\" } def parse_url(self): # 发起请求，获取响应 response = requests.get(self.start_url, headers=self.headers) if response.status_code == 200: return etree.HTML(response.content) def get_code_list(self, response): # 得到股票代码的列表 node_list = response.xpath('//*[@id=\"quotesearch\"]/ul[1]/li') code_list = [] for node in node_list: try: code = re.match(r'.*?\\((\\d+)\\)', etree.tostring(node).decode()).group(1) print code code_list.append(code) except: continue return code_list def run(self): html = self.parse_url() return self.get_code_list(html) 分析网易财经中历史交易记录下载页面获取到下载的链接。 使用谷歌浏览器检查工具，切换到network，在我们在点击下载的时候可以得到请求接口： 上图中，我们分析到，在点击下载时的url地址，需要传递的参数就是我们的股票代码和下载的起始时间和结束的时间，以及fields后面跟着的一堆参数值，在这里需要注意的是请求的url中股票代码前还多了一位是0。那么我们在爬取的时候，就需要理由xpath来提取页面中要下载数据的起始时间和结束时间，然后将在东方财富网中获取到的股票代码和url进行拼接，拼接成我们想要请求的下载连接。 下载历史交易记录的代码 1234567891011121314151617181920212223242526272829303132333435363738394041class Download_HistoryStock(object): def __init__(self, code): self.code = code self.start_url = \"http://quotes.money.163.com/trade/lsjysj_\" + self.code + \".html\" print self.start_url self.headers = { \"User-Agent\": \":Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\" } def parse_url(self): response = requests.get(self.start_url) print response.status_code if response.status_code == 200: return etree.HTML(response.content) return False def get_date(self, response): # 得到开始和结束的日期 start_date = ''.join(response.xpath('//input[@name=\"date_start_type\"]/@value')[0].split('-')) end_date = ''.join(response.xpath('//input[@name=\"date_end_type\"]/@value')[0].split('-')) return start_date,end_date def download(self, start_date, end_date): download_url = \"http://quotes.money.163.com/service/chddata.html?code=0\"+self.code+\"&amp;start=\"+start_date+\"&amp;end=\"+end_date+\"&amp;fields=TCLOSE;HIGH;LOW;TOPEN;LCLOSE;CHG;PCHG;TURNOVER;VOTURNOVER;VATURNOVER;TCAP;MCAP\" data = requests.get(download_url) f = open(self.code + '.csv', 'wb') for chunk in data.iter_content(chunk_size=10000): if chunk: f.write(chunk) print '股票---',self.code,'历史数据正在下载' def run(self): try: html = self.parse_url() start_date,end_date = self.get_date(html) self.download(start_date, end_date) except Exception as e: print e 运行项目，开始下载数据： 12345678if __name__ == '__main__': code = StockCode() code_list = code.run() for temp_code in code_list: time.sleep(1) download = Download_HistoryStock(temp_code) download.run() 下载数据的时候发现，获取到的股票代码2-5开头的都下载不到历史的交易记录，但是从6开始，是可以下载了，下面是下载来的数据效果：","link":"/2019/07/14/2017-08-14-爬取网易财经中股票的历史交易数据/"},{"title":"补♂课第10场","text":"Overview 凑十个题main()函数不写return默认返回0。下同。 1234567#include&lt;stdio.h&gt;int main(){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\",a+b);} 求一元二次方程的根养成好习惯，浮点数进行比较的时候作差取绝对值。 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ int n; scanf(\"%d\",&amp;n); for(double a,b,c,d,r,i; n--;) { scanf(\"%lf%lf%lf\",&amp;a,&amp;b,&amp;c); d=b*b-4*a*c; if(fabs(d)&lt;1e-9) printf(\"x1=x2=%.5f\\n\", -b/a/2); else if(d&gt;0) printf(\"x1=%.5f;x2=%.5f\\n\", (-b+sqrt(d))/2/a, (-b-sqrt(d))/2/a); else { r=(0-b)/2/a;//直接写-b会导致实部打印负零 i=sqrt(-d)/2/a; printf(\"x1=%.5f+%.5fi;x2=%.5f-%.5fi\\n\", r,i,r,i); } }} 平衡饮食通过预处理降低代码量。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;double cont[10][3]={ 7.5,0.75,78, 10,1.25,75, 1.5,0.19,4.28, 35,18,42, 500,500,60,//一百颗蛋 16.5,28.8,1.05, 17.7,20.33,4.06, 14.9,0.8,0.93, 0,100,0, 0.85,0.5,8},all,sum[3]= {0,0,0},scal[3]= {4.1,9.3,4.1};int main(){ for(int i=0,tmp; i!=10; ++i) { scanf(\"%d\",&amp;tmp); for(int j=0; j!=3; ++j) sum[j]+=tmp*scal[j]*cont[i][j]; } all=sum[0]+sum[1]+sum[2]; for(int i=0; i!=3; ++i) sum[i]/=all; printf(sum[0]&gt;0.14&amp;&amp;sum[0]&lt;0.16&amp;&amp; sum[1]&gt;0.3&amp;&amp;sum[1]&lt;0.35&amp;&amp; sum[2]&gt;0.49&amp;&amp;sum[2]&lt;0.56? \"yes\":\"no\");} 求出e的值12345678910#include&lt;stdio.h&gt;int main(){ int n; double s=1,w=1; scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; ++i) s+=1/(w*=i); printf(\"%.10lf\",s);} 数制转换偷个懒，直接用 stdlib.h 库里的strtol函数。n为0的情况不要漏掉了。 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main(){ long a,b,n=0; char s[32]; scanf(\"%d%s%d\",&amp;a,s,&amp;b); n=strtol(s,NULL,a); if(n==0) { printf(\"0\"); return 0; } for(a=0; n; n/=b) s[a++]=(n%b&gt;9?n%b+'A'-10:n%b+'0'); while(a) printf(\"%c\",s[--a]);} 合唱队形为了方便，给每名队员重新编号，新编号从0开始。记 f[0][i] 为第i名队员左边最多可站的人数，那么有这样的转移关系： f[0][i]=max{0,f[0][j]+1} ，其中j是满足 0&lt;=j&lt;i&amp;&amp;t[i]&gt;t[j] 的所有数；同理，记 f[1][i] 为第i名队员右边最多可站的人数，那么有这样的转移关系： f[1][i]=max{0,f[1][j]+1} ，其中j是满足 i&lt;j&lt;n&amp;&amp;t[i]&gt;t[j] 的所有数；其中，式中的1是第j名同学自身。于是，结果是 n-max{f[0][i]+f[1][i]}-1 ，式中1是第i名队员本身。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int n,tmp=0,t[128]= {0},f[2][128]= {0};//全局数组声明的时候如果没有给初值则初始化为0int main(){ scanf(\"%d\",&amp;n); for(int i=0; i!=n; ++i) { scanf(\"%d\",&amp;t[i]); for(int j=0; j!=i; ++j) if(t[i]&gt;t[j]&amp;&amp;f[0][i]&lt;f[0][j]+1) f[0][i]=f[0][j]+1; } for(int i=n-1; i!=-1; --i) { for(int j=i; j!=n; ++j) if(t[i]&gt;t[j]&amp;&amp;f[1][i]&lt;f[1][j]+1) f[1][i]=f[1][j]+1; if(tmp&lt;f[0][i]+f[1][i]) tmp=f[0][i]+f[1][i]; } printf(\"%d\",n-tmp-1);} 细菌繁殖直接按日模拟。 1234567891011121314151617#include&lt;stdio.h&gt;long n,days[13]= {0,31,28,31,30,31,30,31,31,30,31,30,31};int main(){ scanf(\"%d\",&amp;n); for(long m1,m2,d1,d2,z; n--;) { scanf(\"%d%d%d%d%d\",&amp;m1,&amp;d1,&amp;z,&amp;m2,&amp;d2); for(; m1!=m2||d1!=d2; ++d1,z*=2) if(d1==days[m1]) { ++m1; d1=0; } printf(\"%d\\n\",z); }} 肿瘤面积12345678910111213141516171819#include&lt;stdio.h&gt;int main(){ int n,x[2]= {0,1024},y[2]= {0,1024}; scanf(\"%d\",&amp;n); for(int i=0,tmp; i!=n; ++i) for(int j=0; j!=n; ++j) { scanf(\"%d\",&amp;tmp); if(!tmp) { if(x[0]&lt;i)x[0]=i; if(x[1]&gt;i)x[1]=i; if(y[0]&lt;j)y[0]=j; if(y[1]&gt;j)y[1]=j; } } printf(\"%d\",(x[0]-x[1]-1)*(y[0]-y[1]-1));} 求平均年龄12345678910111213#include&lt;stdio.h&gt;int main(){ int n; double s=0; scanf(\"%d\",&amp;n); for(int i=0,t; i!=n; ++i) { scanf(\"%d\",&amp;t); s+=t; } printf(\"%.2lf\",s/n);} 谁拿了最多奖学金用scanf输入时要占位符加空格。比cin不晓得高到哪里去了？！ 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ int n,sum=0,ans_money=0; char gb,xb,name[32],ans_name[32]; scanf(\"%d\",&amp;n); for(int money,qm,py,lw; n--; sum+=money) { scanf(\"%s %d %d %c %c %d\",name,&amp;qm,&amp;py,&amp;gb,&amp;xb,&amp;lw); money=0; if(qm&gt;80&amp;&amp;lw) money+=8000; if(qm&gt;85&amp;&amp;py&gt;80) money+=4000; if(qm&gt;90) money+=2000; if(qm&gt;85&amp;&amp;xb=='Y') money+=1000; if(py&gt;80&amp;&amp;gb=='Y') money+=850; if(ans_money&lt;money) { ans_money=money; strcpy(ans_name,name); } } printf(\"%s\\n%d\\n%d\",ans_name,ans_money,sum);}","link":"/2017/11/27/2017-11-27-补♂课第10场/"},{"title":"C++51行贪吃蛇","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;deque&gt;#include &lt;windows.h&gt;using namespace std;COORD gSize{32, 16}, pos{1, 0}, food = gSize;deque&lt;COORD&gt; snake(1, {0, 0});int cdprintf(COORD cd, const char *s){ return SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), cd), printf(s);}int isLegal(COORD cd){ for (deque&lt;COORD&gt;::iterator it = snake.begin(); it != snake.end(); ++it) if (it-&gt;X == cd.X &amp;&amp; it-&gt;Y == cd.Y) return 0; return 0 &lt;= cd.X &amp;&amp; cd.X &lt; gSize.X &amp;&amp; 0 &lt;= cd.Y &amp;&amp; cd.Y &lt; gSize.Y;}int main(){ for (int i = 0; i &lt; gSize.Y; ++i) cdprintf({gSize.X, i}, \"♂\"); cdprintf({0, gSize.Y}, \"←↑↓→方向键移动，Space键暂停\"); for (int SCORE = 0, FOOD = 0, BACK = 0; isLegal({snake.front().X + pos.X, snake.front().Y + pos.Y}); Sleep(255)) { if (BACK) --BACK; else cdprintf(snake.back(), \" \"), snake.pop_back(); snake.push_front({snake.front().X + pos.X, snake.front().Y + pos.Y}); cdprintf(snake.front(), \"*\"); if (!isLegal(food)) { char s[63]; sprintf(s, \"WuK的贪吃蛇 %d分\", SCORE += FOOD), SetConsoleTitle(s); for (BACK += FOOD; !isLegal(food = {rand() % gSize.X, rand() % gSize.Y});) ; sprintf(s, \"%d\", FOOD = rand() % 3 + 1), cdprintf(food, s); } if (GetAsyncKeyState(VK_SPACE)) MessageBox(NULL, \"游戏很好玩？\\n请联系wu.kan@foxmail.com\", \"By WuK\", NULL); else if (GetAsyncKeyState(VK_UP) &amp;&amp; pos.Y != 1) pos = {0, -1}; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; pos.Y != -1) pos = {0, 1}; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; pos.X != 1) pos = {-1, 0}; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; pos.X != -1) pos = {1, 0}; } MessageBox(NULL, \"Game Over\", \"By WuK\", NULL);}","link":"/2017/10/04/2017-10-04-C++51行贪吃蛇/"},{"title":"2017-2018 ACM-ICPC, NEERC, Northern Subregional Contest","text":"第一次练习团队配合。五小时三人共做出ABCIK五题。配合有待加强。 Auxiliary Project最开始是用DP做的。 123456789101112131415161718192021#include&lt;fstream&gt;using namespace std;ifstream fin(\"auxiliary.in\");ofstream fout(\"auxiliary.out\");int work(int k){ static int f[1000001]= {0}, cost[10]= {6,2,5,5,4,5,6,3,7,6}; if(k&lt;0)return 0; if(f[k])return f[k]; for(int i=0; i!=10; ++i) if(work(k-cost[i])&gt;0||k==cost[i]) f[k]=max(f[k],work(k-cost[i])+i); return f[k];}int main(){ int n; fin&gt;&gt;n; fout&lt;&lt;work(n);} 其实这题可以贪心：尽量用性价比最高的7，多余的用4和1去补。 123456int work(int k){ return k%3==1 ? k/3*7-3: k%3==2 ? k/3*7+1: k/3*7;} Boolean Satisfability做的时候没注意每个标识符长度为1，导致代码长了很多。 12345678910111213141516171819202122232425#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;ifstream fin(\"boolean.in\");ofstream fout(\"boolean.out\");set&lt;string&gt; b[3];bool flag=1,sign=0;int main(){ for(string s,ss; getline(fin,s,'|');) { while(!isalpha(s.back())) s.pop_back();//不加这个有的样例过不掉 sign=s[0]=='~'; ss=s.substr(sign); b[sign].insert(ss); if(b[!sign].find(ss) !=b[!sign].end()) flag=0; } b[2].insert(b[0].begin(),b[0].end()); b[2].insert(b[1].begin(),b[1].end()); fout&lt;&lt;(1LL&lt;&lt;b[2].size())-flag;} 可以用bitset和位运算弄个大新闻。 1234567891011121314151617181920212223#include&lt;fstream&gt;#include&lt;bitset&gt;using namespace std;ifstream fin(\"boolean.in\");ofstream fout(\"boolean.out\");bitset&lt;'z'-'A'+1&gt; b[3];bool flag=1,sign=0;int main(){ for(char ch; fin&gt;&gt;ch;) { if(isalpha(ch)) { b[sign][ch-'A']=1; if(b[!sign][ch-'A']) flag=0; sign=0; } if(ch=='~')sign=1; } b[2]=b[0]|b[1]; fout&lt;&lt;(1LL&lt;&lt;b[2].count())-flag;} Consonant Fencity暴力dfs。算consonant fencity的时候应当边搜索边计算，如果等搜索到达终点再从头计算会TLE。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;fstream&gt;#include&lt;vector&gt;using namespace std;ifstream fin(\"consonant.in\");ofstream fout(\"consonant.out\");string s,con(\"bcdfghjklmnpqrstvxz\");vector&lt;vector&lt;int&gt; &gt; adjmap(con.size(),vector&lt;int&gt;(con.size(),0));vector&lt;bool&gt; state(con.size(),0),ans_state(con.size(),0);int v=0,ans_v=0;void dfs(int k){ if(k==con.size()) { if(ans_v&lt;v) { ans_v=v; ans_state=state; } return; } dfs(k+1); state[k]=1; int t_v=v; for(int i=0; i!=con.size(); i++) if(i!=k) v+=(state[i]?-1:1)*adjmap[i][k]; dfs(k+1); state[k]=0; v=t_v;}int main(){ fin&gt;&gt;s; for(int i=1,p=con.find(s[0]),q; i!=s.size(); ++i,p=q) { q=con.find(s[i]); if(p!=con.npos&amp;&amp;q!=con.npos) { ++adjmap[p][q]; ++adjmap[q][p]; } } dfs(0); for(int i=0,p; i!=s.size(); ++i) { p=con.find(s[i]); fout&lt;&lt;char(p!=con.npos&amp;&amp;ans_state[p]? toupper(s[i]):s[i]); }} Equal Numbers这n个数第n-1次操作后全变成他们的最小公倍数有两种贪心策略： 每次在未处理的数中选择出现次数最少的数变成最小公倍数。 每次在倍数仍在这组数中的数中选择出现次数最少的数变成其倍数。 最优方案由以上两种策略产生。由于局部最优的方案不一定整体最优，因此将两种策略并行，每次输出其中最优的方案。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;fstream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;ifstream fin(\"equal.in\");ofstream fout(\"equal.out\");vector&lt;int&gt; a,b,d(1e6+1,0);int n;int main(){ fin&gt;&gt;n; for(int i=0,t; i&lt;n; ++i) { fin&gt;&gt;t; ++d[t]; } for(int i=1; i&lt;d.size(); ++i) if(d[i]) { a.push_back(d[i]); for(int j=2*i; j&lt;d.size(); j+=i) if(d[j]) { b.push_back(d[i]); break; } } sort(a.begin(),a.end()); sort(b.begin(),b.end()); for(int i=0,p=0,q=0,sp=0,sq=0; i&lt;=n; ++i) { while(p&lt;a.size()&amp;&amp;sp+a[p]&lt;=i) sp+=a[p++]; while(q&lt;b.size()&amp;&amp;sq+b[q]&lt;=i) sq+=b[q++]; fout&lt;&lt;a.size()-max(p-1,q)&lt;&lt;' '; }} Fygon 2.0dfs。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;bitset&gt;typedef long long ll;typedef std::bitset&lt;32&gt; Bs;Bs bs[32],t;void add(char a,char b){ a=(a=='1'?0:a-'a'+1); b=(b=='1'?0:b-'a'+1); bs[a][b]=1; bs[a][a]=1; bs[b][b]=1;}ll dfs(Bs x){ static std::map&lt;ll,ll&gt; f; if(f.find(x.to_ulong())!=f.end()) return f[x.to_ulong()]; ll &amp;ret=f[x.to_ulong()]=x.none(); for(int i=0; i&lt;32; ++i) if((x&amp;bs[i])==(1&lt;&lt;i)) { x[i]=0; ret+=dfs(x); x[i]=1; } return ret;}ll gcd(ll a,ll b){ return b?gcd(b,a%b):a;}int main(){ freopen(\"fygon20.in\",\"r\",stdin); freopen(\"fygon20.out\",\"w\",stdout); int m; scanf(\"%d\",&amp;m); for(char a,b,c; m--;) { scanf(\" for %c in range(%c, %c):\",&amp;a,&amp;b,&amp;c); add(b,a); add(a,c); } add('1','n'); for(int i=0; i&lt;32; ++i) for(int j=0; j&lt;32; ++j) if(bs[j][i]) bs[j]|=bs[i]; for(int i=0; i&lt;32; ++i) { if(bs[i].none()) t[i]=1; for(int j=i+1; j&lt;32; ++j) if(bs[i]==bs[j]) t[j]=1; } ll an=dfs(t.flip()),ad=1,ag; for(int i=2; i&lt;t.count()-1; ++i)ad*=i; ag=gcd(an,ad); printf(\"%d %lld/%lld\",t.count()-2,an/ag,ad/ag);} Intelligence in Perpendicularia求多边形多边形内部可以看到，但在外部看不到的线条长度。只要拿总周长减去最小外接矩形周长即可。 1234567891011121314151617181920212223242526#include&lt;fstream&gt;using namespace std;ifstream fin(\"intel.in\");ofstream fout(\"intel.out\");int n,ans=0,x[1024],y[1024];int abs(int n){ return n&lt;0?-n:n;}int main(){ fin&gt;&gt;n; x[1023]=y[1023]=-1e7; x[1022]=y[1022]=1e7; for(int i=0; i!=n; ++i) { fin&gt;&gt;x[i]&gt;&gt;y[i]; x[1023]=max(x[1023],x[i]); y[1023]=max(y[1023],y[i]); x[1022]=min(x[1022],x[i]); y[1022]=min(y[1022],y[i]); } for(int i=0; i!=n; ++i) ans+=abs(x[(i+1)%n]+y[(i+1)%n]-x[i]-y[i]); fout&lt;&lt;ans-2*(x[1023]+y[1023]-x[1022]-y[1022]);} Kotlin Island样例是骗人的。例如，第二个样例其实不做任何处理就行。其次，只要处理奇数行和奇数列（编号从0开始）即可。f[i][j] 表示将前i个奇数行和j个奇数列被充水后剩下的联通块数量，容易列出转移方程。转移的时候如果发现 f[i][j]==n 就可以输出了。 12345678910111213141516171819202122232425#include&lt;fstream&gt;using namespace std;ifstream fin(\"kotlin.in\");ofstream fout(\"kotlin.out\");int h,w,n,f[64][64]= {1,0};int main(){ fin&gt;&gt;h&gt;&gt;w&gt;&gt;n; for(int i=0; 2*i&lt;h; ++i) for(int j=0; 2*j&lt;w; ++j) { if(i)f[i][j]=max(f[i][j],f[i-1][j]+j+1); if(j)f[i][j]=max(f[i][j],f[i][j-1]+i+1); if(f[i][j]==n) { for(int x=0; x&lt;h; ++x,fout&lt;&lt;'\\n') for(int y=0; y&lt;w; ++y) fout&lt;&lt;((x%2&amp;&amp;x/2&lt;i)|| (y%2&amp;&amp;y/2&lt;j)? '#':'.'); return 0; } } fout&lt;&lt;\"Impossible\";}","link":"/2017/11/23/2017-11-23-2017-2018 ACM-ICPC, NEERC, Northern Subregional Contest/"},{"title":"补♂课第11场","text":"Overview 晶晶赴约会12345678#incldue&lt;stdio.h&gt;int main(){ int n; scanf(\"%d\",&amp;n); printf(n==1||n==3||n==5? \"NO\":\"YES\");} 陶陶摘苹果123456789101112#include&lt;stdio.h&gt;int main(){ int a[10],h,ans=0; for(int i=0; i!=10; ++i) scanf(\"%d\",&amp;a[i]); scanf(\"%d\",&amp;h); for(int i=0; i!=10; ++i) if(a[i]&lt;=30+h) ++ans; printf(\"%d\",ans);} 大象喝水12345678#include&lt;stdio.h&gt;int main(){ int h,r; scanf(\"%d%d\",&amp;h,&amp;r); double v=3.14159*r*r*h; printf(\"%d\",(int)(20000/v)+1);} 忽略大小写比较字符串大小学习一个gets和puts函数的用法。另外，为了程序高效，尽量减少strlen函数的调用。 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ char s[2][128]; for(int i=0; i!=2; ++i) { gets(s[i]); for(int j=strlen(s[i])-1; j!=-1; --j) if('A'&lt;=s[i][j]&amp;&amp;s[i][j]&lt;='Z') s[i][j]+='a'-'A'; for(int j=strlen(s[i]); j!=128; ++j) s[i][j]=0; } for(int i=0; i!=128; ++i) if(s[0][i]!=s[1][i]) { puts(s[0][i]&lt;s[1][i]?\"&lt;\":\"&gt;\"); return 0; } puts(\"=\");} 已经强调本题禁用strcmp函数结果……本题变得毫无诚意。 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;ctype.h&gt;int main(){ char cmp,s[2][128]; for(int i=0; i!=2; ++i) { gets(s[i]); for(int j=strlen(s[i])-1; j!=-1; --j) s[i][j]=tolower(s[i][j]); } cmp=strcmp(s[0],s[1]); puts(cmp&gt;0?\"&gt;\": cmp&lt;0?\"&lt;\":\"=\");} 学分绩点12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;float scal(int g){ return g&gt;89?4.0: g&gt;84?3.7: g&gt;81?3.3: g&gt;77?3.0: g&gt;74?2.7: g&gt;71?2.3: g&gt;67?2.0: g&gt;63?1.5: g&gt;59?1:0;}int main(){ int n,a[2][10]; float sum[2]= {0,0}; scanf(\"%d\",&amp;n); for(int i=0; i!=2; ++i) for(int j=0; j!=n; ++j) scanf(\"%d\",&amp;a[i][j]); for(int i=0; i!=n; ++i) { sum[0]+=a[0][i]; sum[1]+=a[0][i]*scal(a[1][i]); } printf(\"%.2f\",sum[1]/sum[0]);} 不吉利日期12345678910111213141516#include&lt;stdio.h&gt;int main(){ int w,days[13]= {0,31,28,31,30,31,30,31,31,30,31,30,31}; scanf(\"%d\",&amp;w); for(int d=1,m=1; m!=13; ++d,w=w%7+1) { if(d==13&amp;&amp;w==5) printf(\"%d\\n\",m); if(d==days[m]) { ++m; d=0; } }} 优解：直接从1月13号往上加，利用同余系的性质很漂亮的做掉这一题。 123456789101112#include&lt;stdio.h&gt;int main(){ int w,days[13]= {0,12,31,28,31,30,31,30,31,31,30,31,30}; scanf(\"%d\",&amp;w); for(int m=1; m&lt;=12; ++m) { w=(w+days[m])%7+1; if(w==5) printf(\"%d\\n\",m); }} 生日相同12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;string.h&gt;char str[13][32][128][16]= {0};int n,m,d,size[13][32]= {0};int main(){ scanf(\"%d\",&amp;n); for(char name[16]; n--;) { scanf(\"%s%d%d\",name,&amp;m,&amp;d); strcpy(str[m][d][size[m][d]++],name); } for(m=1; m!=13; ++m) for(d=1; d!=32; ++d) if(size[m][d]&gt;1) { printf(\"%d %d\",m,d); for(int i=0; i!=size[m][d]; ++i) printf(\" %s\",str[m][d][i]); printf(\"\\n\"); }} 跳格问题12345678910111213141516171819202122232425#include&lt;stdio.h&gt;int n,ans=0,a[32]= {1,0};int main(){ scanf(\"%d\",&amp;n); for(int i=1; i&lt;=n; ++i) scanf(\"%d\",&amp;a[i]); for(int pos=0,pre=0; pos&lt;=n;) { if(a[pre=pos]) { pos+=a[pos]; if(pos&lt;0) pos=0; a[pre]=0; ++ans; } else { ++pos; ans+=2; } } printf(\"%d\",ans);} 采药可以看到I、J两题不同的只有数据范围。对于数据范围比较小的I题，可以直接暴力搜索：将草药从1开始编号，记 f[t][m] 为时间t内采集前m棵的草药的最优解，那么有 f[t][m]=max(f[t-cost[m]][m-1]+value[m],f[t][m-1]) ；用自然语言表述，就是m号草药要么采，要么不采。然后考虑搜索的边界条件：如果 t&lt;0 ，说明时间已经是不够用的，那么要返回一个负无穷来表示这个状态不可以被转移；如果 t==0 ，说明根本不给时间采药，那么结果显然是0；如果 m==0 ，说明所有的草药都已经被考虑过，这时候时间还有多，那么返回0表示继续采也不会再有收益了。 123456789101112131415161718192021#include&lt;stdio.h&gt;int cost[128]= {0},value[128]= {0};int max(int a,int b){ return a&gt;b?a:b;}int work(int t,int m){ if(t&lt;0)return -1e9; if(t==0||m==0)return 0; return max(work(t,m-1), work(t-cost[m],m-1)+value[m]);}int main(){ int t,m; scanf(\"%d%d\",&amp;t,&amp;m); for(int i=1; i&lt;=m; ++i) scanf(\"%d%d\",&amp;cost[i],&amp;value[i]); printf(\"%d\",work(t,m));} 还是采药问题注意到在第I题的搜索里，搜索的过程有很多重复的浪费；我们可以用数组手动推转移关系。 12345678910111213int work(int t,int m){ static int f[1024][128]= {0};//定义成static可以把数组全部初始化为0 for(int i=1; i&lt;=t; ++i) for(int j=1;j&lt;=m;++j) { f[i][j]=f[i][j-1]; if(i&gt;=cost[j]) f[i][j]=max(f[i][j], f[i-cost[j]][j-1]+value[j]); } return f[t][m];} 注意到转移方向的特殊性，稍改一下循环的层级和方向，就可以将原先的数组降至一维，从而大大降低函数的内存开销。 123456789int work(int t,int m){ static int f[1024]= {0}; for(int j=1; j&lt;=m; ++j) for(int i=t; i&gt;=cost[j]; --i)//需要倒序循环，否则一株草药可能会被采多次 f[i]=max(f[i], f[i-cost[j]]+value[j]); return f[t];} 当然，也可以在I题中的函数里加上静态（static）记录数组，每次搜索后把结果存起来；在调用函数的时候先判断当前节点是否已经搜索过，如果是则直接返回保存的结果。这样的技术，我们称之为记忆化搜索。当然，也可以使用全局数组代替，但是全局数组可以被程序的其他部分访问，从而可能使函数的运行不符合我们的预期；使用静态数组，可以使搜索函数变成记录数组唯一合法的访问入口，更加保险。注意，和很多常见的记忆化搜索不同，这里的0是有可能（其实是一定，例如 work(0,0) 一定为0）出现在搜索结果中的，因此需要专门使用一个标记数组来记录访问情况，而不能直接判断 f[t][m]！=0 是否成立否则会TLE。当然，这样写的好处是逻辑清晰易写，效率也和之前的动态规划是一个级别（每个点至多只计算一次，而且很多无关点不会被访问）；缺点是函数调用会有一点微小的开销，造成更大的内存空间浪费，也不像之前的规划那样容易降维优化。 1234567891011int work(int t,int m){ static int f[1024][128]= {0}, flag[1024][128]= {0}; if(t&lt;0)return -1e9; if(t==0||m==0)return 0; if(flag[t][m])return f[t][m]; flag[t][m]=1; return f[t][m]=max(work(t,m-1), work(t-cost[m],m-1)+value[m]);}","link":"/2017/11/29/2017-11-29-补♂课第11场/"},{"title":"3D Triangles","text":"三维几何模板分数类模板题目链接 1234567891011int main(){ int t; for(scanf(\"%d\",&amp;t); t--;) { Coord3 p[6]; for(int i=0; i&lt;6; ++i) scanf(\"%lf%lf%lf\",&amp;p[i].X,&amp;p[i].Y,&amp;p[i].Z); printf(\"%d\\n\",TriTriIntersection(p,p+3)); }}","link":"/2017/12/21/2017-12-21-UVA-11275/"},{"title":"Asteroids","text":"三维几何模板题目链接 12345678910111213int main(){ lf ans=0,x,y,z; for(int n,m,flag=1; ~scanf(\"%d\",&amp;n);) { vector&lt;Coord3&gt; p; for(; n--; p.push_back(Coord3(x,y,z))) scanf(\"%lf%lf%lf\",&amp;x,&amp;y,&amp;z); ConvexPolyhedron c(p); ans+=c.dist(c.centroid()); if(flag^=1)printf(\"%.5f\\n\",ans),ans=0; }}","link":"/2017/12/21/2017-12-21-UVALive-4589/"},{"title":"Ardenia","text":"三维几何模板分数类模板题目链接这一题太特殊了，所有运算都要在分数下进行，因此把完整代码贴出来。原有的模板几乎无虚修改即可应用，分数类敲sqrt比较麻烦，因此所有距离计算的是是平方后的值（见注释中的原模板和修改之后的代码）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Fraction{ ll num,den; Fraction(ll n=0,ll d=1):num(n),den(d) { d=__gcd(num,den),num/=d,den/=d; if(den&lt;0)num=-num,den=-den; } friend Fraction operator+(const Fraction&amp; A,const Fraction&amp; B) { ll d=__gcd(A.den,B.den); return Fraction(B.den/d*A.num+A.den/d*B.num,A.den/d*B.den); } Fraction&amp; operator+=(const Fraction &amp;c) { return *this=*this+c; } Fraction operator-()const { Fraction r(*this); return r.num=-r.num,r; } friend Fraction operator-(const Fraction &amp;a,const Fraction &amp;c) { return -c+a; } Fraction&amp; operator-=(const Fraction &amp;c) { return *this=*this-c; } friend Fraction operator*(const Fraction&amp; A,const Fraction&amp; B) { return Fraction(A.num*B.num,A.den*B.den); } Fraction&amp; operator*=(const Fraction &amp;c) { return *this=*this*c; } friend Fraction operator/(const Fraction&amp; A,const Fraction&amp; B) { return Fraction(A.num*B.den,A.den*B.num); } Fraction&amp; operator/=(const Fraction &amp;c) { return *this=*this/c; } friend Fraction operator%(const Fraction &amp;a,const Fraction &amp;c) { return Fraction(a.num*c.den%(c.num*a.den),a.den*c.den); } Fraction&amp; operator%=(const Fraction &amp;c) { return *this=*this%c; } friend bool operator==(const Fraction &amp;a,const Fraction &amp;b) { return a.num*b.den==a.den*b.num; } friend bool operator!=(const Fraction &amp;a,const Fraction &amp;b) { return !(a==b); } friend bool operator&lt;(const Fraction &amp;a,const Fraction &amp;b) { return a.num*b.den&lt;a.den*b.num; } friend bool operator&gt;(const Fraction &amp;a,const Fraction &amp;b) { return b&lt;a; } friend bool operator&lt;=(const Fraction &amp;a,const Fraction &amp;b) { return !(a&gt;b); } friend bool operator&gt;=(const Fraction &amp;a,const Fraction &amp;b) { return !(a&lt;b); } friend Fraction abs(Fraction f) { if(f.num&lt;0)f.num=-f.num; return f; } friend ostream&amp; operator&lt;&lt;(ostream &amp;os,const Fraction &amp;f) { return !f.num?os&lt;&lt;0: f.den==1?os&lt;&lt;f.num: os&lt;&lt;f.num&lt;&lt;'/'&lt;&lt;f.den; }};typedef Fraction lf;const lf EPS=1e-9,INF=1e9;int sgn(lf d){ return (d&gt;EPS)-(d&lt;-EPS);}struct Coord3{ lf X,Y,Z; Coord3(lf X=0,lf Y=0,lf Z=0):X(X),Y(Y),Z(Z) {} friend bool operator!=(const Coord3 &amp;a,const Coord3 &amp;b) { return sgn(a.X-b.X)||sgn(a.Y-b.Y)||sgn(a.Z-b.Z); } friend bool operator==(const Coord3 &amp;a,const Coord3 &amp;b) { return !(a!=b); } Coord3&amp; operator+=(const Coord3 &amp;b) { return X+=b.X,Y+=b.Y,Z+=b.Z,*this; } friend Coord3 operator+(Coord3 a,const Coord3 &amp;b) { return a+=b; } Coord3&amp; operator-=(const Coord3 &amp;b) { return X-=b.X,Y-=b.Y,Z-=b.Z,*this; } friend Coord3 operator-(Coord3 a,const Coord3 &amp;b) { return a-=b; } Coord3&amp; operator*=(lf d) { return X*=d,Y*=d,Z*=d,*this; } friend Coord3 operator*(Coord3 a,lf d) { return a*=d; } friend Coord3 operator*(lf d,Coord3 a) { return a*=d; } Coord3&amp; operator/=(lf d) { return X/=d,Y/=d,Z/=d,*this; } friend Coord3 operator/(Coord3 a,lf d) { return a/=d; }};struct Line3{ Coord3 p,v; Line3(Coord3 p=Coord3(),Coord3 v=Coord3()):p(p),v(v) {} Coord3 point(lf t)const { return p+v*t; }};lf Dot(const Coord3&amp; A,const Coord3&amp; B){ return A.X*B.X+A.Y*B.Y+A.Z*B.Z;}Coord3 Cross(const Coord3&amp; A,const Coord3&amp; B){ return Coord3(A.Y*B.Z-A.Z*B.Y,A.Z*B.X-A.X*B.Z,A.X*B.Y-A.Y*B.X);}lf norm(const Coord3&amp; A){ return Dot(A,A);}/*lf DistanceToLine(Coord3 P,Coord3 A,Coord3 B)//点P到直线AB的距离{ Coord3 v1=B-A,v2=P-A; return abs(Cross(v1,v2))/abs(v1);}*/lf Distance2ToLine(Coord3 P,Coord3 A,Coord3 B)//点P到直线AB的距离{ Coord3 v1=B-A,v2=P-A; return norm(Cross(v1,v2))/norm(v1);}/*lf DistanceToSeg(Coord3 P,Coord3 A,Coord3 B)//点到线段的距离{ if(A==B)return abs(P-A); Coord3 v1=B-A,v2=P-A,v3=P-B; if(sgn(Dot(v1,v2))&lt;0)return abs(v2); if(sgn(Dot(v1,v3))&gt;0)return abs(v3); return fabs(DistanceToLine(P,A,B));}*/lf Distance2ToSeg(Coord3 P,Coord3 A,Coord3 B)//点到线段的距离{ if(A==B)return norm(P-A); Coord3 v1=B-A,v2=P-A,v3=P-B; if(sgn(Dot(v1,v2))&lt;0)return norm(v2); if(sgn(Dot(v1,v3))&gt;0)return norm(v3); return abs(Distance2ToLine(P,A,B));}bool LineDistance3D(Coord3 p1,Coord3 u,Coord3 p2,Coord3 v,lf&amp; s)//求异面直线 p1+s*u与p2+t*v的公垂线对应的s，如果平行|重合，返回0{ lf b=Dot(u,u)*Dot(v,v)-Dot(u,v)*Dot(u,v); if(!sgn(b))return 0; lf a=Dot(u,v)*Dot(v,p1-p2)-Dot(v,v)*Dot(u,p1-p2); return s=a/b,1;}Coord3 getCoord3(){ ll x,y,z; return scanf(\"%lld%lld%lld\",&amp;x,&amp;y,&amp;z),Coord3(x,y,z);}int main(){ int t; for(scanf(\"%d\",&amp;t); t--;) { Coord3 A=getCoord3(),B=getCoord3(),C=getCoord3(),D=getCoord3(); lf s,t,ans=INF; if(LineDistance3D(A,B-A,C,D-C,s)&amp;&amp;0&lt;s&amp;&amp;s&lt;1&amp;&amp; LineDistance3D(C,D-C,A,B-A,t)&amp;&amp;0&lt;t&amp;&amp;t&lt;1) ans=norm(Line3(A,B-A).point(s)-Line3(C,D-C).point(t)); else { ans=min(ans,Distance2ToSeg(A,C,D)); ans=min(ans,Distance2ToSeg(B,C,D)); ans=min(ans,Distance2ToSeg(C,A,B)); ans=min(ans,Distance2ToSeg(D,A,B)); } printf(\"%lld %lld\\n\",ans.num,ans.den); }}","link":"/2017/12/21/2017-12-21-UVALive-4973/"},{"title":"补♂课第111场","text":"overview 试剂配制练习使用位运算。 12345678910111213141516#include&lt;stdio.h&gt;int n,t,a[8]= {0};int main(){ scanf(\"%d\",&amp;n); while(n--) { scanf(\"%d\",&amp;t); a[t-1]=1; } printf(\"%d\", !(a[0]&amp;a[1])&amp; !(a[2]&amp;a[3])&amp; !(a[4]^a[5])&amp; (a[6]|a[7]));} 异常细胞检测1234567891011121314151617#include&lt;stdio.h&gt;int n,cnt=0,a[128][128]= {0};int main(){ scanf(\"%d\",&amp;n); for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;n; ++j) scanf(\"%d\",&amp;a[i][j]); for(int i=1; i&lt;n-1; ++i) for(int j=1; j&lt;n-1; ++j) if(a[i-1][j]&gt;=a[i][j]+50&amp;&amp; a[i+1][j]&gt;=a[i][j]+50&amp;&amp; a[i][j-1]&gt;=a[i][j]+50&amp;&amp; a[i][j+1]&gt;=a[i][j]+50) ++cnt; printf(\"%d\",cnt);} 按顺序输出12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int a[3];int intGreaterCmp(const void *a,const void *b){ return *(int*)b-*(int*)a;}int main(){ scanf(\"%d%d%d\",&amp;a[0],&amp;a[1],&amp;a[2]); qsort(a,3,sizeof(int),intGreaterCmp); printf(\"%d %d %d\",a[0],a[1],a[2]);} 求和12345678910#include&lt;stdio.h&gt;#include&lt;math.h&gt;int a,n,s=0;int main(){ scanf(\"%d%d\",&amp;a,&amp;n); for(int i=1; i&lt;=n; ++i) s+=(pow(10,i)-1)/9*a; printf(\"%d\",s);} 满足条件的整数12345678910#include&lt;stdio.h&gt;int main(){ for(int a=1; a&lt;=100; ++a) for(int b=a; b&lt;=100; ++b) for(int c=b; c&lt;=100; ++c) if(a*a+b*b==c*c) printf(\"%d*%d + %d*%d = %d*%d\\n\", a,a,b,b,c,c);} 吃糖果即斐波那契数列第n+1项。 12345678910111213#include&lt;stdio.h&gt;int work(int n){ static int f[32]= {1,1}; if(f[n])return f[n]; return f[n]=work(n-1)+work(n-2);}int main(){ int n; scanf(\"%d\",&amp;n); printf(\"%d\",work(n));} 也可以像这样不用数组直接递推。 1234567891011int work(int n){ int a=1; for(int i=2,b=1,c; i&lt;=n; ++i) { c=a; a+=b; b=c; } return a;} 小白鼠排队注意到每只小白鼠的体重都不同且范围小，存表比排序更快。 1234567891011#include&lt;stdio.h&gt;char color[1024][16]= {0};int n,t;int main(){ for(scanf(\"%d\",&amp;n); n--;) scanf(\"%d%s\",&amp;t,color[t]); for(int i=1000; i; --i) if(color[i][0]) printf(\"%s\\n\",color[i]);} 单词替换123456789101112#include&lt;stdio.h&gt;#include&lt;string.h&gt;char s[128][128];int cnt=0;int main(){ while(scanf(\"%s\",s[cnt++])!=EOF); for(int i=0; i&lt;=cnt-4; ++i) printf(\"%s \", strcmp(s[i],s[cnt-3])? s[i]:s[cnt-2]);} 拦截导弹123456789101112131415#include&lt;stdio.h&gt;int k,ans=0,h[32],f[32];int main(){ scanf(\"%d\",&amp;k); for(int i=0; i!=k; ++i) { scanf(\"%d\",&amp;h[i]); for(int j=f[i]=0; j!=i; ++j) if(h[i]&lt;=h[j]&amp;&amp;f[i]&lt;f[j]+1) f[i]=f[j]+1; if(ans&lt;f[i])ans=f[i]; } printf(\"%d\",ans+1);} 玩游戏123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;string.h&gt;int k,n,a;int main(){ for(scanf(\"%d%d\",&amp;k,&amp;n); n--;) { char s[9]; scanf(\"%s%d\",s,&amp;a); if(!strcmp(s,\"plus\")) k+=a; if(!strcmp(s,\"minus\")) k-=a; if(!strcmp(s,\"multiply\")) k*=a; } printf(\"%d\",k);}","link":"/2017/12/28/2017-12-28-补♂课第111场/"},{"title":"2018 Multi-University Training Contest 2","text":"Game先手的人可以通过 选1,不选1 的方式操纵游戏的进程，因此有必胜策略。 12345#include&lt;stdio.h&gt;int main(){ for(int n; ~scanf(\"%d\",&amp;n);)printf(\"Yes\\n\");} Swaps and Inversions一个逆序对对答案的贡献是 min(x,y) 。 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll merge_sort(ll *b,ll *e){ if(e-b&lt;2)return 0; ll i=0,j=0,*m=b+(e-b)/2,ans=merge_sort(b,m)+merge_sort(m,e); vector&lt;ll&gt; l(b,m),r(m,e); while(i&lt;l.size()&amp;&amp;j&lt;r.size()) { if(r[j]&lt;l[i])*(b++)=r[j++],ans+=l.size()-i; else *(b++)=l[i++]; } while(i&lt;l.size())*(b++)=l[i++]; while(j&lt;r.size())*(b++)=r[j++]; return ans;}ll n,x,y,a[100009];int main(){ while(~scanf(\"%lld%lld%lld\",&amp;n,&amp;x,&amp;y)) { for(int i=0; i&lt;n; ++i)scanf(\"%lld\",&amp;a[i]); printf(\"%lld\\n\",merge_sort(a,a+n)*min(x,y)); }} Naive Operations线段树暴力维护每个区间被加的值、达到下一更新点所需要增加的最小值及该区间的答案，每次 maintain 时检查如果超过这个值就把该区间的add标记下传到子区间并递归维护子区间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;int n,q,l,r,b[100009];struct SegmentTree{ struct Node { ll add,need,sum; }; vector&lt;Node&gt; v; int LAST,L,R; SegmentTree(int n):LAST(n),v(2*n+1) {} Node &amp;lv(int l,int r) { return v[l+r|l!=r]; } void push_down(Node &amp;lc,Node &amp;rc,Node &amp;fa) { lc.add+=fa.add,rc.add+=fa.add,fa.add=0; } void build(ll b[],int l,int r) { if(l&lt;r) { int m=l+(r-l)/2; build(b,l,m),build(b,m+1,r),lv(l,r).add=0; } else lv(l,r).add=0,lv(l,r).need=b[l]; maintain(l,r); } void push_up(const Node &amp;lc,const Node &amp;rc,Node &amp;fa) { fa.need=min(lc.need-lc.add,rc.need-rc.add); fa.sum=lc.sum+rc.sum; } void maintain(int l,int r) { if(l&lt;r) { int m=l+(r-l)/2; if(lv(l,r).add&gt;=lv(l,r).need) { push_down(lv(l,m),lv(m+1,r),lv(l,r)); maintain(l,m),maintain(m+1,r); } push_up(lv(l,m),lv(m+1,r),lv(l,r)); return; } for(; lv(l,r).add&gt;=lv(l,r).need; ++lv(l,r).sum) lv(l,r).add-=lv(l,r).need,lv(l,r).need=b[l]; } Node ask(int l,int r,ll val=0,bool out=1) { if(out)return L=l,R=r,ask(1,LAST,val,0); else if(L&lt;=l&amp;&amp;r&lt;=R)v[0]=lv(l,r); else { int m=l+(r-l)/2; if(R&lt;=m)return ask(l,m,lv(l,r).add+val,0); if(L&gt;m)return ask(m+1,r,lv(l,r).add+val,0); push_up(ask(l,m,lv(l,r).add+val,0),ask(m+1,r,lv(l,r).add+val,0),v[0]); } return v[0]; } void add(int l,int r,ll val,bool out=1) { if(out)return L=l,R=r,add(1,LAST,val,0); if(L&lt;=l&amp;&amp;r&lt;=R)lv(l,r).add+=val; else { int m=l+(r-l)/2; push_down(lv(l,m),lv(m+1,r),lv(l,r)); if(L&lt;=m)add(l,m,val,0); else maintain(l,m); if(R&gt;m)add(m+1,r,val,0); else maintain(m+1,r); } maintain(l,r); }};int main(){ while(~scanf(\"%d%d\",&amp;n,&amp;q)) { for(int i=1; i&lt;=n; ++i)scanf(\"%d\",&amp;b[i]); SegmentTree t(n); t.build(b,1,n); for(char s[9]; q--;) { scanf(\"%s%d%d\",s,&amp;l,&amp;r); if(s[0]=='a')t.add(l,r,1); else printf(\"%d\\n\",t.ask(l,r).sum); } }}","link":"/2018/08/18/2018-08-18-2018 Multi-University Training Contest 2/"},{"title":"Frequency Hopping","text":"题目链接图论模板先求一次最大流若流量不小于C则possible，否则依次把最小割里的弧容量加到C再看流量是否大于C。蓝书上说这样会T但是事实上并没有…加上蓝书上的两个优化也不过只快了一两百ms而已。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll INF=0x3f3f3f3f;struct Graph{ struct Vertex { vector&lt;int&gt; a; }; struct Edge { int from,to; ll cap; bool operator&lt;(const Edge &amp;e)const { return from!=e.from? from&lt;e.from: to&lt;e.to; } }; vector&lt;Vertex&gt; v; vector&lt;Edge&gt; e; Graph(int n):v(n) {} void add(const Edge &amp;ed) { v[ed.from].a.push_back(e.size()); e.push_back(ed); }};struct ISAP:Graph{ ll flow; vector&lt;ll&gt; f; vector&lt;int&gt; h,cur,gap; ISAP(int n):Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.from,ed.to),ed.cap=0; Graph::add(ed); } ll dfs(int s,int u,int t,ll r) { if(r==0||u==t)return r; ll _f,_r=0; for(int &amp;i=cur[u],k; i&lt;v[u].a.size(); ++i) if(k=v[u].a[i],h[u]==h[e[k].to]+1) { _f=dfs(s,e[k].to,t,min(r-_r,e[k].cap-f[k])); f[k]+=_f,f[k^1]-=_f,_r+=_f; if(_r==r||h[s]&gt;=v.size())return _r; } if(!--gap[h[u]])h[s]=v.size(); return ++gap[++h[u]],cur[u]=0,_r; } void ask(int s,int t) { h.assign(v.size(),0); cur.assign(v.size(),0); gap.assign(v.size()+2,0); for(f.assign(e.size(),flow=0); h[s]&lt;v.size();) flow+=dfs(s,s,t,INF); }};int main(){ for(int n,e,c,kase=0; scanf(\"%d%d%d\",&amp;n,&amp;e,&amp;c)&amp;&amp;n;) { printf(\"Case %d: \",++kase); ISAP g(n+1); for(ISAP::Edge ed; e--; g.add(ed)) scanf(\"%d%d%d\",&amp;ed.from,&amp;ed.to,&amp;ed.cap); g.ask(1,n); if(g.flow&gt;=c) { printf(\"possible\\n\"); continue; } vector&lt;int&gt; vis(n+1,0),mincut; for(deque&lt;int&gt; q(1,vis[1]=1); !q.empty(); q.pop_front()) for(int i=0,u=q.front(),k,to; i!=g.v[u].a.size(); ++i) if(k=g.v[u].a[i],to=g.e[k].to, !vis[to]&amp;&amp;g.e[k].cap&gt;g.f[k]) q.push_back(to),vis[to]=1; for(int i=0; i!=g.e.size(); ++i) if(vis[g.e[i].from]&amp;&amp;!vis[g.e[i].to]&amp;&amp;g.e[i].cap&gt;0) mincut.push_back(i); vector&lt;ISAP::Edge&gt; ans; for(int i=0,tmp=c; i!=mincut.size(); ++i) { swap(tmp,g.e[mincut[i]].cap); g.ask(1,n); if(g.flow&gt;=c)ans.push_back(g.e[mincut[i]]); swap(tmp,g.e[mincut[i]].cap); } if(ans.empty()) { printf(\"not possible\\n\"); continue; } printf(\"possible option:\"); sort(ans.begin(),ans.end()); for(int i=0; i!=ans.size(); ++i) printf(\"(%d,%d)%c\", ans[i].from,ans[i].to, i+1!=ans.size()?',':'\\n'); }}","link":"/2018/03/30/2018-03-30-UVA-11248/"},{"title":"2018 Multi-University Training Contest 6","text":"oval-and-rectangle易积分得答案$\\frac{1}{b}\\int_0^b(4c+4a\\sqrt{1-\\frac{c^2}{b^2} }),dc=2b-a\\pi$。 12345678#include&lt;stdio.h&gt;#include&lt;math.h&gt;int t,a,b;int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"%.6f\\n\",2*b+a*acos(-1)-5e-7)) scanf(\"%d%d\",&amp;a,&amp;b);} bookshelf预处理阶乘需要两倍大…因为这个wa了七发，好气啊。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) ((1LL)*(a)*(b)%(c))#define inv(a,b) pow(a,(b)-2,b)using namespace std;typedef int ll;const ll N=1e6+7,M=1e9+7;ll pow(ll a,ll b,ll m){ ll r=1; for(a%=m; b; b&gt;&gt;=1,a=mul(a,a,m)) if(b&amp;1)r=mul(r,a,m); return r;}struct Factorial{ vector&lt;ll&gt; fac,ifac; ll M; Factorial(int N,ll M):fac(N,1),ifac(N,1),M(M) { for(int i=1; i&lt;N; ++i)fac[i]=mul(fac[i-1],i,M); ifac[N-1]=inv(fac[N-1],M); for(int i=N-1; i; --i)ifac[i-1]=mul(ifac[i],i,M); } ll c(int n,int m) { return mul(mul(fac[n],ifac[m],M),ifac[n-m],M); }} f(2*N,M);struct Fibonacci:vector&lt;ll&gt;{ Fibonacci(int N,ll M):vector&lt;ll&gt;(N,0) { for(int i=at(1)=1; i+1&lt;N; ++i)at(i+1)=(at(i)+at(i-1))%M; }} fb(N,M-1);struct Factor:vector&lt;ll&gt;{ Factor(ll n) { for(ll i=1; i*i&lt;=n; ++i) if(n%i==0)push_back(i),push_back(n/i); sort(begin(),end()),resize(unique(begin(),end())-begin()); }};int t,n,k,s,a[N];int ask(int n,int k){ if(~a[n])return a[n]; if(n==1)return a[n]=k; Factor fac(n); for(ll i=a[n]=0; i&lt;fac.size(); ++i) if(fac[i]&gt;1)a[n]=(a[n]+ask(n/fac[i],k))%M; return a[n]=(f.c(n+k-1,k-1)-a[n]+M)%M;}int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"%lld\\n\",mul(inv(f.c(n+k-1,k-1),M),s,M))) { scanf(\"%d%d\",&amp;n,&amp;k),fill(a,a+n+1,-1); Factor fac(n); for(ll i=s=0; i&lt;fac.size(); ++i) s=(s+mul((pow(2,fb[fac[i]],M)-1+M)%M,ask(n/fac[i],k),M))%M; }} 这个 ask 函数也可以不记忆化搜索直接通过莫比乌斯反演求。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) ((1LL)*(a)*(b)%(c))#define inv(a,b) pow(a,(b)-2,b)using namespace std;typedef int ll;const ll N=1e6+7,M=1e9+7;ll pow(ll a,ll b,ll m){ ll r=1; for(a%=m; b; b&gt;&gt;=1,a=mul(a,a,m)) if(b&amp;1)r=mul(r,a,m); return r;}struct Factorial{ vector&lt;ll&gt; fac,ifac; ll M; Factorial(int N,ll M):fac(N,1),ifac(N,1),M(M) { for(int i=1; i&lt;N; ++i)fac[i]=mul(fac[i-1],i,M); ifac[N-1]=inv(fac[N-1],M); for(int i=N-1; i; --i)ifac[i-1]=mul(ifac[i],i,M); } ll c(int n,int m) { return mul(mul(fac[n],ifac[m],M),ifac[n-m],M); }} f(2*N,M);struct Fibonacci:vector&lt;ll&gt;{ Fibonacci(int N,ll M):vector&lt;ll&gt;(N,0) { for(int i=at(1)=1; i+1&lt;N; ++i)at(i+1)=(at(i)+at(i-1))%M; }} fb(N,M-1);struct EulerSieve{ vector&lt;int&gt; p,m,mu; EulerSieve(int N):m(N,0),mu(N,0) { mu[1]=1; for(long long i=2,k; i&lt;N; ++i) { if(!m[i])p.push_back(m[i]=i),mu[i]=-1; for(int j=0; j&lt;p.size()&amp;&amp;(k=i*p[j])&lt;N; ++j) { if((m[k]=p[j])==m[i]) { mu[k]=0; break; } mu[k]=-mu[i]; } } }} e(N);struct Factor:vector&lt;ll&gt;{ Factor(ll n) { for(ll i=1; i*i&lt;=n; ++i) if(n%i==0)push_back(i),push_back(n/i); sort(begin(),end()),resize(unique(begin(),end())-begin()); }};int ask(int n,int k){ ll r=0; Factor fac(n); for(int i=0; i&lt;fac.size(); ++i) if(n%fac[i]==0) r=(r+mul(f.c(n/fac[i]+k-1,k-1),(e.mu[fac[i]]+M)%M,M))%M; return r;}int main(){ int t,n,k,s; for(scanf(\"%d\",&amp;t); t--; printf(\"%lld\\n\",mul(inv(f.c(n+k-1,k-1),M),s,M))) { scanf(\"%d%d\",&amp;n,&amp;k); Factor fac(n); for(ll i=s=0; i&lt;fac.size(); ++i) s=(s+mul((pow(2,fb[fac[i]],M)-1+M)%M,ask(n/fac[i],k),M))%M; }} Ringland队友写的wa了…有空改。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=500000+10;int t,n,l,u;long long ans1,ans2,g;int a[maxn],b[maxn];int main(){ scanf(\"%d\",&amp;t); while (t--) { scanf(\"%d%d\",&amp;n,&amp;l); u=l/2; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;b[i]); if (a[1]&lt;=b[1]) swap(a,b); ans1=ans2=0; for (int i=1;i&lt;=n;i++) { g=a[i]-b[i]; if (g&lt;0) g=-g; if (g&gt;u) g=l-g; ans1+=g; } for (int i=1;i&lt;n;i++) { g=a[i]-b[i+1]; if (g&lt;0) g=-g; if (g&gt;u) g=l-g; ans2+=g; } g=b[1]-a[n]; if (g&lt;0) g=-g; if (g&gt;u) g=l-g; ans2+=g; printf(\"%I64d\\n\",min(ans1,ans2)); } return 0;} Werewolf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn=100000+10;int t,n,ans;vector &lt;int&gt; pre[maxn];int nxt[maxn],v[maxn],ind[maxn];bool vis[maxn];char s[15];queue &lt;int&gt; q;int dfs(int cur){ vis[cur]=true; if ((v[cur]==0)||(vis[nxt[cur]])) return cur; dfs(nxt[cur]);}int main(){ scanf(\"%d\",&amp;t); while (t--) { scanf(\"%d\",&amp;n); memset(ind,0,sizeof(ind)); for (int i=1;i&lt;=n;i++) { scanf(\"%d%s\",&amp;nxt[i],s); if (s[0]=='v') v[i]=1;//1 村民 else v[i]=0; pre[nxt[i]].push_back(i); ind[nxt[i]]++; } for (int i=1;i&lt;=n;i++) if (ind[i]==0) q.push(i); while (!q.empty()) { int g=q.front(); q.pop(); ind[nxt[g]]--; if (ind[nxt[g]]==0) q.push(nxt[g]); } memset(vis,false,sizeof(vis)); for (int i=1;i&lt;=n;i++) if (ind[i]&amp;&amp;(!vis[i])&amp;&amp;(v[i]==0)) { int k=dfs(nxt[i]); if (k==i) q.push(nxt[i]); } ans=0; while (!q.empty()) { int g=q.front(); q.pop(); ans++; for (int i=0;i&lt;pre[g].size();i++) if (v[pre[g][i]]==1) q.push(pre[g][i]); } printf(\"0 %d\\n\",ans); for (int i=1;i&lt;=n;i++) pre[i].clear(); } return 0;} Pinball模拟每次落点时的速度即可。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#define X real()#define Y imag()using namespace std;const double EPS=1e-9,PI=acos(-1),g=9.8;typedef complex&lt;double&gt; Coord;int sgn(double d){ return (d&gt;EPS)-(d&lt;-EPS);}int t,ans;int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"%d\\n\",ans)) { double a,b,x,t; scanf(\"%lf%lf%lf%lf\",&amp;a,&amp;b,&amp;x,&amp;t); for(Coord p(x,-x*b/a),v(ans=0,-sqrt(2*g*(t+x*b/a))); sgn(p.X)&lt;=0; ++ans) v*=polar(1.0,2*arg(Coord(-a,b))-2*arg(v)+PI), t=2*(b*v.X/a+v.Y)/g, p=Coord(p.X+v.X*t,p.Y+v.Y*t-g*t*t/2), v=Coord(v.X,v.Y-g*t); }}","link":"/2018/08/21/2018-08-21-2018 Multi-University Training Contest 6/"},{"title":"自动生成三位JK卡诺图","text":"应付数电实验期末考试用的…按顺序输进去六位数字，自动生成Markdown格式的每个JK触发器的卡诺图。生成Excel可以直接打开的csv表格。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;char f[8],c=',';int a[6];int main(){ for(int i=0; i&lt;6; ++i)cin&gt;&gt;a[i]; ofstream cout(\"KarnaughMap.csv\"); cout&lt;&lt;\"NextMap\\n\"&lt;&lt;c&lt;&lt;\"State\" &lt;&lt;c&lt;&lt;\"$Q_2$\"&lt;&lt;c&lt;&lt;\"$Q_1$\"&lt;&lt;c&lt;&lt;\"$Q_0$\"&lt;&lt;c&lt;&lt;\"\\n\" &lt;&lt;c&lt;&lt;\"-\"&lt;&lt;c&lt;&lt;\"\\n\"; for(int i=0; i&lt;6; ++i) { cout&lt;&lt;c&lt;&lt;a[i]; for(int x=2; ~x; --x)cout&lt;&lt;c&lt;&lt;(a[(i+1)%6]&gt;&gt;x&amp;1); cout&lt;&lt;c&lt;&lt;\"\\n\"; } for(int x=2; ~x; --x) for(int j=1; ~j; --j) { fill(f,f+8,'X'); for(int i=0; i&lt;6; ++i) if(j!=(a[i]&gt;&gt;x&amp;1)) f[a[i]]='0'+(j==(a[(i+1)%6]&gt;&gt;x&amp;1)); cout&lt;&lt;(j?\"$J_\":\"$K_\")&lt;&lt;x&lt;&lt;\"$Map\\n\"&lt;&lt;c&lt;&lt;\"$Q_0\\\\setminus Q_1Q_2$\" &lt;&lt;c&lt;&lt;\"00\"&lt;&lt;c&lt;&lt;\"01\"&lt;&lt;c&lt;&lt;\"11\"&lt;&lt;c&lt;&lt;\"10\"&lt;&lt;c&lt;&lt;\"\\n\" &lt;&lt;c&lt;&lt;\"-\"&lt;&lt;c&lt;&lt;\"\\n\" &lt;&lt;c&lt;&lt;\"0\"&lt;&lt;c&lt;&lt;f[0]&lt;&lt;c&lt;&lt;f[4]&lt;&lt;c&lt;&lt;f[6]&lt;&lt;c&lt;&lt;f[2]&lt;&lt;c&lt;&lt;\"\\n\" &lt;&lt;c&lt;&lt;\"1\"&lt;&lt;c&lt;&lt;f[1]&lt;&lt;c&lt;&lt;f[5]&lt;&lt;c&lt;&lt;f[7]&lt;&lt;c&lt;&lt;f[3]&lt;&lt;c&lt;&lt;\"\\n\"; }} 生成Markdown格式，然后就可以直接导进CSDN里了。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;char f[8],c='|';int a[6];int main(){ for(int i=0; i&lt;6; ++i)cin&gt;&gt;a[i]; ofstream cout(\"KarnaughMap.md\"); cout&lt;&lt;\"NextMap\\n\"&lt;&lt;c&lt;&lt;\"State\" &lt;&lt;c&lt;&lt;\"$Q_2$\"&lt;&lt;c&lt;&lt;\"$Q_1$\"&lt;&lt;c&lt;&lt;\"$Q_0$\"&lt;&lt;c&lt;&lt;\"\\n\" &lt;&lt;c&lt;&lt;\"-\"&lt;&lt;c&lt;&lt;\"\\n\"; for(int i=0; i&lt;6; ++i) { cout&lt;&lt;c&lt;&lt;a[i]; for(int x=2; ~x; --x)cout&lt;&lt;c&lt;&lt;(a[(i+1)%6]&gt;&gt;x&amp;1); cout&lt;&lt;c&lt;&lt;\"\\n\"; } for(int x=2; ~x; --x) for(int j=1; ~j; --j) { fill(f,f+8,'X'); for(int i=0; i&lt;6; ++i) if(j!=(a[i]&gt;&gt;x&amp;1)) f[a[i]]='0'+(j==(a[(i+1)%6]&gt;&gt;x&amp;1)); cout&lt;&lt;(j?\"$J_\":\"$K_\")&lt;&lt;x&lt;&lt;\"$Map\\n\"&lt;&lt;c&lt;&lt;\"$Q_0\\\\setminus Q_1Q_2$\" &lt;&lt;c&lt;&lt;\"00\"&lt;&lt;c&lt;&lt;\"01\"&lt;&lt;c&lt;&lt;\"11\"&lt;&lt;c&lt;&lt;\"10\"&lt;&lt;c&lt;&lt;\"\\n\" &lt;&lt;c&lt;&lt;\"-\"&lt;&lt;c&lt;&lt;\"\\n\" &lt;&lt;c&lt;&lt;\"0\"&lt;&lt;c&lt;&lt;f[0]&lt;&lt;c&lt;&lt;f[4]&lt;&lt;c&lt;&lt;f[6]&lt;&lt;c&lt;&lt;f[2]&lt;&lt;c&lt;&lt;\"\\n\" &lt;&lt;c&lt;&lt;\"1\"&lt;&lt;c&lt;&lt;f[1]&lt;&lt;c&lt;&lt;f[5]&lt;&lt;c&lt;&lt;f[7]&lt;&lt;c&lt;&lt;f[3]&lt;&lt;c&lt;&lt;\"\\n\"; }}","link":"/2018/07/03/2018-07-03-自动生成三位JK卡诺图/"},{"title":"2018 Multi-University Training Contest 1","text":"垫底进队之后第一次集训。 Maximum Multiple 3的倍数拆 1,1,1 ，4的倍数拆 1,1,2 ，优先拆3的倍数。 123456789#include&lt;stdio.h&gt;long long t,n;int main(){ for(scanf(\"%lld\",&amp;t); t--; printf(\"%lld\\n\",n%3==0?n*n*n/27: n%4==0?n*n*n/32:-1)) scanf(\"%lld\",&amp;n);} Balanced Sequence 具体思想是把每个串按删去可以自匹配的括号后的剩余串（形如 )))(( ）排序： 左括号多于右括号的串排在左括号少于右括号的串前面； 同类型的串中，左括号多于右括号的串右括号少的放前面，右括号多于左括号的串左括号少的放前面。 现场谜之排序 WA 了十一发… 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100009;struct Node{ int l,r; bool operator&lt;(const Node &amp;t)const { return r&lt;l?(t.r&lt;t.l?r&lt;t.r:1):(t.r&lt;t.l?0:l&gt;t.l); }} v[N];char s[N];int t,n,ans;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;n); for(int i=ans=0; i&lt;n; ++i) { scanf(\"%s\",s); for(int j=v[i].l=v[i].r=0; s[j]; ++j) { if(s[j]=='(')++v[i].l; else if(v[i].l)--v[i].l,++ans; else ++v[i].r; } } sort(v,v+n); for(int i=0,cnt=0; i&lt;n; ++i) { ans+=min(cnt,v[i].r); cnt+=v[i].l-min(cnt,v[i].r); } printf(\"%d\\n\",ans*2); }} Triangle Partition把所有点按照横坐标-纵坐标的字典序排序，选取依次相邻三项。 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;struct Coord:pair&lt;int,int&gt;{ int id;} p[10009];int t,n;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;n); for(int i=0; i&lt;3*n; ++i) scanf(\"%d%d\",&amp;p[i].first,&amp;p[i].second),p[i].id=i; sort(p,p+3*n); for (int i=0; i&lt;3*n; ++i) printf(\"%d%c\",p[i].id+1,i%3!=2?' ':'\\n'); }} Distinct Values 队友写的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn=100000+10;pair&lt;int,int&gt; a[maxn];int ans[maxn];int t,n,m;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;int main(){ scanf(\"%d\",&amp;t); while (t--) { scanf(\"%d%d\",&amp;n,&amp;m); memset(ans,0,sizeof(ans)); if (m==0) { for (int i=1;i&lt;n;i++) printf(\"1 \"); printf(\"1\\n\"); continue; } for (int i=1;i&lt;=m;i++) scanf(\"%d%d\",&amp;a[i].first,&amp;a[i].second); sort(a+1,a+m+1); while (!q.empty()) q.pop(); // for (int i=1;i&lt;=m;i++) printf(\"!%d %d\\n\",a[i].first,a[i].second); for (int i=1;i&lt;a[1].first;i++) ans[i]=1; for (int i=a[1].first;i&lt;=a[1].second;i++) ans[i]=i-a[1].first+1; int l=a[1].first,r=a[1].second,mx=ans[a[1].second]; for (int i=2;i&lt;=m;i++) { if (a[i].second&lt;=r) continue; if (a[i].first&lt;=r) { for (int j=l;j&lt;a[i].first;j++) q.push(ans[j]); for (int j=r+1;j&lt;=a[i].second;j++) if (!q.empty()) ans[j]=q.top(),q.pop(); else ans[j]=++mx; } else { while (!q.empty()) q.pop(); mx=0; for (int j=a[i].first;j&lt;=a[i].second;j++) ans[j]=++mx; } l=a[i].first; r=a[i].second; } for (int i=1;i&lt;=n;i++) if (ans[i]==0) ans[i]=1; for (int i=1;i&lt;n;i++) printf(\"%d \",ans[i]); printf(\"%d\\n\",ans[n]); }} Maximum Weighted Matching1//假装会写 Period Sequence1//假装会写 Chiaki Sequence Revisited队友$O(\\log\\⁡log ⁡N)$的二分强行跑掉！太强啦！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;typedef long long ll;const ll mod=1e9+7;int t;ll n,v,ans,u;inline ll geti(ll x){ ll l=x/2-1,r=x; while (r-l&gt;1) { ll mid=(l+r)/2,k=mid; ll g=0; while (k&gt;0) { g+=k; k/=2; } // printf(\"%lld %lld %lld %lld\\n\",l,r,mid,g); if (g&lt;x) l=mid; else r=mid; } return r;}inline ll cal(ll x){ ll ret=0,t=1; u=0; while (x&gt;0) { if (x&amp;1) ret=(ret+((x%mod)*((x+1)/2%mod)%mod)*t)%mod; else ret=(ret+(((x+1)%mod)*((x/2)%mod)%mod)*t)%mod; //printf(\"ret=%lld\\n\",ret); u+=x; t=(t*2)%mod; x/=2; } return ret;}int main(){ scanf(\"%d\",&amp;t); while (t--) { scanf(\"%lld\",&amp;n); v=geti(n-1); // printf(\"%lld \",v); ans=cal(v-1); ans=(ans+v*(n-1-u)+1)%mod; printf(\"%lld\\n\",ans); } return 0;} RMQ Similar Sequence学习一个一队大爷的分治做法，正解好像和笛卡尔树有关？dfs写起来奥妙重重…递归要尽量写在函数尾，而且写void形式，否则爆栈。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define mul(a,b,m) (1LL*(a)*(b)%(m))#define inv(a,m) pow(a,(m)-2,m)#define log2(n) LOG2[n]using namespace std;typedef int ll;const int N=1e6+7,M=1e9+7;ll pow(ll a,ll b,ll m){ ll r=1; for(a%=m; b; b&gt;&gt;=1,a=mul(a,a,m)) if(b&amp;1)r=mul(r,a,m); return r;}struct Factorial{ vector&lt;ll&gt; fac,ifac; ll M; Factorial(int N,ll M):fac(N,1),ifac(N,1),M(M) { for(int i=1; i&lt;N; ++i)fac[i]=mul(fac[i-1],i,M); ifac[N-1]=inv(fac[N-1],M); for(int i=N-1; i; --i)ifac[i-1]=mul(ifac[i],i,M); } ll c(int n,int m) { return mul(mul(fac[n],ifac[m],M),ifac[n-m],M); }} F(N,M);struct Log:vector&lt;ll&gt;{ Log(int N,ll e):vector&lt;ll&gt;(N,-1) { for(int i=1; i&lt;N; ++i)at(i)=at(i/e)+1; }} LOG2(N,2);int t,n,s;struct SparseTable{ typedef pair&lt;int,int&gt; ll; vector&lt;vector&lt;ll&gt; &gt; f; SparseTable(const vector&lt;ll&gt; &amp;a):f(log2(a.size())+1,a) { for(int k=0; k+1&lt;f.size(); ++k) for(int i=0; i+(1&lt;&lt;k)&lt;a.size(); ++i) f[k+1][i]=min(f[k][i],f[k][i+(1&lt;&lt;k)]); } ll ask(int l,int r) { int k=log2(r-l+1); return min(f[k][l],f[k][r+1-(1&lt;&lt;k)]); } void dfs(int l,int r) { if(l&gt;r)return; int m=ask(l,r).second; if(l&lt;m&amp;&amp;m&lt;r)s=mul(s,F.c(r-l,m-l),M); dfs(l,m-1),dfs(m+1,r); }};int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"%d\\n\",s)) { scanf(\"%d\",&amp;n); vector&lt;pair&lt;int,int&gt; &gt; a; for(int i=0; i&lt;n; ++i) scanf(\"%d\",&amp;s),a.push_back(make_pair(-s,i)); SparseTable st(a); s=mul(mul(n,F.ifac[2],M),F.ifac[n],M),st.dfs(0,n-1); }} Lyndon Substring1//假装会写 Turn Off The Light1//假装会写 Time Zone读到的 double 乘十后要四舍五入，且 istringstream 速度太慢过不了。 1234567891011121314#include&lt;stdio.h&gt;char s[9];double d;int t,a,b;int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"%02d:%02d\\n\",(a+b/60)%24,b%60)) { scanf(\"%d%d%s\",&amp;a,&amp;b,&amp;s); sscanf(s+3,\"%lf\",&amp;d); if(d-=8,d&lt;0)d+=24; b+=6*(int)(d*10+0.5); }}","link":"/2018/08/14/2018-08-14-2018 Multi-University Training Contest 1/"},{"title":"2018 Multi-University Training Contest 3","text":"Problem A. Ascending Rating从后向前扫描维护当前位置开始的m个区间的LIS。全程使用 long long 减少取模次数，否则会T。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#define N 10000009long long t,n,m,k,p,q,r,M,a[N],Q[N];int main(){ for(scanf(\"%lld\",&amp;t); t--;) { scanf(\"%lld%lld%lld%lld%lld%lld%lld\",&amp;n,&amp;m,&amp;k,&amp;p,&amp;q,&amp;r,&amp;M); for(int i=1; i&lt;=k; ++i)scanf(\"%lld\",&amp;a[i]); for(int i=k+1; i&lt;=n; ++i)a[i]=(p*a[i-1]+q*i+r)%M; for(int i=n,l=r=p=q=0; i; --i) { while(l&lt;r&amp;&amp;a[Q[r-1]]&lt;=a[i])--r; Q[r++]=i; if(i&lt;=n-m+1) { if(Q[l]-Q[r-1]+1&gt;m)++l; p+=i^a[Q[l]]; q+=i^(r-l); } } printf(\"%lld %lld\\n\",p,q); }} Problem C. Dynamic Graph Matching1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv=3000;const int mod=1e9+7;int num[maxv],f[maxv];int g[12][12];int t,n,m,k,x,y,v;char s[4];int ans[10];void init(){ for (int i=0;i&lt;1024;i++) { for (int j=0;j&lt;10;j++) if ((1&lt;&lt;j)&amp;i) num[i]++; if (num[i]&amp;1) num[i]=0; else num[i]/=2; }}int main(){ init(); scanf(\"%d\",&amp;t); while (t--) { memset(g,0,sizeof(g)); memset(f,0,sizeof(f)); f[0]=1; scanf(\"%d%d\",&amp;n,&amp;m); k=n/2; v=(1&lt;&lt;n)-1; while (m--) { scanf(\"%s%d%d\",s,&amp;x,&amp;y); if (s[0]=='+') { for (int i=0;i&lt;=v;i++) { if (((1&lt;&lt;(x-1))&amp;i) &amp;&amp; ((1&lt;&lt;(y-1))&amp;i)) f[i]+=f[i-(1&lt;&lt;(x-1))-(1&lt;&lt;(y-1))]; f[i]%=mod; } g[x][y]++; } else { for (int i=0;i&lt;=v;i++) { if (((1&lt;&lt;(x-1))&amp;i) &amp;&amp; ((1&lt;&lt;(y-1))&amp;i)) f[i]-=f[i-(1&lt;&lt;(x-1))-(1&lt;&lt;(y-1))]; if (f[i]&lt;0) f[i]+=mod; } g[x][y]--; } // for (int i=1;i&lt;=v;i++) printf(\"%d \",f[i]); // printf(\"\\n\"); memset(ans,0,sizeof(ans)); for (int i=1;i&lt;=v;i++) ans[num[i]]+=f[i],ans[num[i]]%=mod; for (int i=1;i&lt;k;i++) printf(\"%d \",ans[i]); printf(\"%d\\n\",ans[k]); } }} Problem D. Euler Function1234567#include&lt;stdio.h&gt;int t,k;int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"%d\\n\",k==1?5:k+5)) scanf(\"%d\",&amp;k);} Grab The Tree12345678910111213#include&lt;stdio.h&gt;int t,n,s,w;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;n); for(int i=s=0; i&lt;n; ++i) scanf(\"%d\",&amp;w),s^=w; for(printf(\"%c\\n\",s?'Q':'D'); --n;) scanf(\"%d%d\",&amp;s,&amp;w); }} Problem L. Visual Cube12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;char s[99][99];int t,a,b,c;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); for(int i=0; i&lt;(b+c)*2+1; ++i) for(int j=0; j&lt;(a+b)*2+1; ++j) s[i][j]='.'; for(int i=0; i&lt;b; ++i) { for(int j=0; j&lt;a; ++j) { s[2*i][2*b-2*i+2*j]='+'; s[2*i+1][2*b-2*i+2*j-1]='/'; s[2*i][2*b-2*i+2*j+1]='-'; } s[2*i][2*b-2*i+a*2]='+'; } for(int i=0; i&lt;=c; ++i) { for(int j=0; j&lt;b; ++j) { s[2*i+2*b-2*j-1][2*a+2*j+1]='/'; s[2*i+2*b-2*j-2][2*a+2*j+2]='+'; if(i&lt;c)s[2*i+2*b-2*j-1][2*a+2*j+2]='|'; } for(int j=0; j&lt;a; ++j) { if(i)s[2*i+2*b-1][j*2]='|'; s[2*i+2*b][j*2]='+'; s[2*i+2*b][j*2+1]='-'; } s[2*i+2*b][2*a]='+'; if(i)s[2*i+2*b-1][2*a]='|'; } for(int i=0; i&lt;(b+c)*2+1; ++i,printf(\"\\n\")) for(int j=0; j&lt;(a+b)*2+1; ++j) printf(\"%c\",s[i][j]); }}","link":"/2018/08/18/2018-08-18-2018 Multi-University Training Contest 3/"},{"title":"2018 Multi-University Training Contest 4","text":"Problem B. Harvest of Apples1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) ((a)*(b)%(c))#define inv(a,m) pow(a,m-2,m)#define C(n,m) mul(mul(f.fac[n],f.ifac[m],M),f.ifac[(n)-(m)],M)using namespace std;typedef long long ll;const ll N=1e5+7,M=1e9+7,BS=sqrt(N);ll t,n,m,ans[N];ll pow(ll a,ll b,ll m){ ll r=1; for(a%=m; b; b&gt;&gt;=1,a=mul(a,a,m)) if(b&amp;1)r=mul(r,a,m); return r;}struct Factorial{ vector&lt;ll&gt; fac,ifac; Factorial(int N):fac(N,1),ifac(N,1) { for(int i=1; i&lt;N; ++i)fac[i]=mul(fac[i-1],i,M); ifac[N-1]=inv(fac[N-1],M); for(int i=N-1; i; --i)ifac[i-1]=mul(ifac[i],i,M); }} f(N);struct Mo{ struct Query { int l,r,id; bool operator&lt;(const Query&amp; q)const { return l/BS!=q.l/BS?l&lt;q.l:r&lt;q.r; } }; vector&lt;Query&gt; q; ll L,R,ANS; void query(int l,int r) { q.push_back(Query {l,r,q.size()}); } void cal(int id) { ans[id]=ANS; } void ask() { sort(q.begin(),q.end()); ANS=L=1,R=0; for(int i=0; i&lt;q.size(); ++i) { for(; L&lt;q[i].l; ++L)ANS=(2*ANS-C(L,R)+M)%M; for(; R&gt;q[i].r; --R)ANS=(ANS-C(L,R)+M)%M; for(; R&lt;q[i].r; ++R)ANS=(ANS+C(L,R+1))%M; for(; L&gt;q[i].l; --L)ANS=mul((ANS+C(L-1,R))%M,f.ifac[2],M); cal(q[i].id); } }} mo;int main(){ for(scanf(\"%lld\",&amp;t); t--; mo.query(n,m))scanf(\"%lld%lld\",&amp;n,&amp;m); mo.ask(); for(int i=0; i&lt;mo.q.size(); ++i)printf(\"%lld\\n\",ans[i]);} Problem D. Nothing is Impossible123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,m,a,b[127];int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0; i&lt;n; ++i)scanf(\"%d%d\",&amp;a,&amp;b[i]); sort(b,b+n); b[n]=2e9,a=0; for(long long p=1; p&lt;=m; ++a)p*=b[a]+1; printf(\"%d\\n\",a-1); }} Problem E. Matrix from Arrays1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;typedef long long ll;ll t,l,q,a[15],x0,x1,y0,y1,M[999][999],b[31][31];void init(){ ll cursor = 0,T=2*l; for (ll i = 0; i&lt;3*T; ++i) { for (ll j = 0; j &lt;= i; ++j) { M[j][i - j] = a[cursor]; cursor = (cursor + 1) % l; } } for(ll i=0; i&lt;T; ++i) for(ll j=0; j&lt;T; ++j) b[i+1][j+1]=M[i][j]+b[i+1][j]+b[i][j+1]-b[i][j];}ll ask(ll x,ll y){ ++x,++y; ll T=2*l,tx=x/T,ty=y/T,dx=x%T,dy=y%T; return tx*ty*b[T][T]+b[dx][T]*ty+b[T][dy]*tx+b[dx][dy];}int main(){ for(scanf(\"%lld\",&amp;t); t--;) { scanf(\"%lld\",&amp;l); for(ll i=0; i&lt;l; ++i)scanf(\"%lld\",&amp;a[i]); init(); for(scanf(\"%lld\",&amp;q); q--;) { scanf(\"%lld%lld%lld%lld\",&amp;x0,&amp;y0,&amp;x1,&amp;y1); printf(\"%lld\\n\",ask(x1,y1)-ask(x0-1,y1)-ask(x1,y0-1)+ask(x0-1,y0-1)); } }} Problem J. Let Sudoku Rotate1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct reg{ int X[4],Y[4];}C[20];void turn(int k){ int a=C[k].X[0],b=C[k].X[1],c=C[k].X[2],d=C[k].X[3]; C[k].X[0]=C[k].Y[0]; C[k].X[1]=C[k].Y[1]; C[k].X[2]=C[k].Y[2]; C[k].X[3]=C[k].Y[3]; C[k].Y[0]=d;C[k].Y[1]=c;C[k].Y[2]=b;C[k].Y[3]=a;}int ans;int y[20];void DFS(int k,int cnt,int x0,int x1,int x2,int x3){ if (k&gt;15) { ans=min(ans,cnt); return; } if (k%4==0) x0=x1=x2=x3=0; if (cnt&gt;=ans) return; for (int i=0;i&lt;=3;++i) { bool ok=true; for (int j=k%4*4;j&lt;=k%4*4+3;++j) if (y[j]&amp;C[k].Y[j%4]) {ok=false;break;} if (ok &amp;&amp; ((x0&amp;C[k].X[0])==0) &amp;&amp; ((x1&amp;C[k].X[1])==0) &amp;&amp; ((x2&amp;C[k].X[2])==0) &amp;&amp; ((x3&amp;C[k].X[3])==0)) { for (int j=k%4*4;j&lt;=k%4*4+3;++j) y[j]|=C[k].Y[j%4]; DFS(k+1,cnt+i,x0|C[k].X[0],x1|C[k].X[1],x2|C[k].X[2],x3|C[k].X[3]); for (int j=k%4*4;j&lt;=k%4*4+3;++j) y[j]-=C[k].Y[j%4]; } turn(k); }}int n;char s[20][20];int change(char c){ if ('0'&lt;=c &amp;&amp; c&lt;='9') return (1&lt;&lt;(c-'0')); return (1&lt;&lt;(c-'A'+10));}int main(){ scanf(\"%d\",&amp;n); while (n--) { memset(C,0,sizeof(C)); ans=50; for (int i=0;i&lt;=15;++i) scanf(\"%s\",s[i]); for (int i=0;i&lt;=15;++i) { int X=i/4,Y=i%4; int x1=X*4,x2=X*4+3,y1=Y*4,y2=Y*4+3; for (int x=x1;x&lt;=x2;++x) for (int y=y1;y&lt;=y2;++y) { C[i].X[x-x1]|=change(s[x][y]); C[i].Y[y-y1]|=change(s[x][y]); } } memset(y,0,sizeof(y)); DFS(0,0,0,0,0,0); printf(\"%d\\n\",ans); }} Problem K. Expression in Memories12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int T;char s[1000];int main(){ scanf(\"%d\",&amp;T); while (T--) { scanf(\"%s\",s+1); bool op=true,zero=false,OK=true; for (int i=1;s[i];++i) { if (s[i]=='?') { if (zero) { zero=false;op=true;s[i]='+'; }else { op=zero=false;s[i]='1'; } } else if (s[i]=='+' || s[i]=='*') { if (op) {OK=false;break;} op=true;zero=false; } else if (s[i]=='0') { if (zero) {OK=false;break;} if (op) zero=true; op=false; } else if ('1'&lt;=s[i] &amp;&amp; s[i]&lt;='9') { if (zero) {OK=false;break;} op=zero=false; } } if (op) OK=false; if (OK) printf(\"%s\\n\",s+1); else printf(\"IMPOSSIBLE\\n\"); }} Problem L. Graph Theory Homework1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;int t,n;int a[100010];int main(){ scanf(\"%d\",&amp;t); while (t--) { scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); int del=abs(a[1]-a[n]); for (int i=1;i&lt;=100000;++i) { if (i*i&gt;del) {printf(\"%d\\n\",i-1);break;} } }}","link":"/2018/08/19/2018-08-19-2018 Multi-University Training Contest 4/"},{"title":"2018 Multi-University Training Contest 7","text":"Sequence12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) (1LL*(a)*(b)%(c))using namespace std;typedef int ll;const ll N=3,M=1e9+7;struct Matrix{ static int n; ll a[N][N]; Matrix(ll k=0) { for(int i=0; i&lt;n; ++i)fill(a[i],a[i]+n,0),a[i][i]=k; }};int Matrix::n=N;Matrix operator*(const Matrix &amp;a,const Matrix &amp;b){ Matrix r(0); for(int i=0; i&lt;r.n; ++i) for(int j=0; j&lt;r.n; ++j) for(int k=0; k&lt;r.n; ++k) r.a[i][j]=(r.a[i][j]+mul(a.a[i][k],b.a[k][j],M))%M; return r;}Matrix pow(Matrix a,ll b){ Matrix r(1); for(; b; b&gt;&gt;=1,a=a*a) if(b&amp;1)r=r*a; return r;}int main(){ int t,a,b,c,d,p,n; for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d,&amp;p,&amp;n); Matrix ans,e; ans.a[0][0]=a,ans.a[1][0]=b; e.a[1][0]=c,e.a[1][1]=d,e.a[0][1]=e.a[1][2]=e.a[2][2]=1; for(int i=3,last; i&lt;=n; i=last+1) { if(ans.a[2][0]=p/i,ans.a[2][0])last=min(p/ans.a[2][0],n); else last=n; ans=pow(e,last-i+1)*ans; } printf(\"%lld\\n\",ans.a[1][0]); }}","link":"/2018/08/22/2018-08-22-2018 Multi-University Training Contest 7/"},{"title":"2018 Multi-University Training Contest 5","text":"Beautiful Now以为是贪心但是贪心的策略过不了 2311 ，于是暴搜。 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;char s[15];int t,k,mi,ma;void dfs(int n,int k,int v){ if(k&lt;0)return; if(!s[n])mi=min(mi,v),ma=max(ma,v); for(int i=n; s[i]; ++i) { swap(s[n],s[i]); if(s[0]!='0')dfs(n+1,k-(s[n]!=s[i]),v*10+s[n]-'0'); swap(s[n],s[i]); }}int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"%d %d\\n\",mi,ma)) scanf(\"%s%d\",s,&amp;k),mi=1e9,dfs(0,k,ma=0);} Everything Has Changed对于每个小圆B，在最终答案里加上其在主圆C内部的弧长、减去C在B中的弧长。 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const double EPS=1e-9,PI=acos(-1);typedef complex&lt;double&gt; Coord;struct Circle{ Coord c; double r; Circle(Coord c=Coord(),double r=0):c(c),r(r) {}};int sgn(double d){ return (d&gt;EPS)-(d&lt;-EPS);}double cal(Circle C,Circle B){ double d=abs(B.c-C.c); return sgn(B.r+C.r-d)&lt;0||sgn(fabs(B.r-C.r)-d)&gt;0?0: 2*C.r*acos((d*d+C.r*C.r-B.r*B.r)/2/d/C.r);}int main(){ int t,m,x,y,r; for(scanf(\"%d\",&amp;t); t--;) { Circle C(Coord(0,0)); double s=0; for(scanf(\"%d%lf\",&amp;m,&amp;C.r); m--;) { scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;r); Circle B(Coord(x,y),r); s+=cal(B,C)-cal(C,B); } printf(\"%.9f\\n\",s+2*PI*C.r); }} Glad You Came12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned ul;ul rng61(ul &amp;x,ul &amp;y,ul &amp;z){ return x^=x&lt;&lt;11,x^=x&gt;&gt;4,x^=x&lt;&lt;5,x^=x&gt;&gt;14,swap(x,y),swap(y,z),z^=x^y;}struct SegmentTree{ struct Node { ll set; }; vector&lt;Node&gt; v; int LAST,L,R; SegmentTree(int n):LAST(n),v(2*n+1) {} Node &amp;lv(int l,int r) { return v[l+r|l!=r]; } void set(int l,int r,ll val,bool out=1) { if(out)return L=l,R=r,set(1,LAST,val,0); if(val&lt;lv(l,r).set)return; if(L&lt;=l&amp;&amp;r&lt;=R) { lv(l,r).set=val; return; } int m=l+(r-l)/2; if(L&lt;=m)set(l,m,val,0); if(R&gt;m)set(m+1,r,val,0); } ll ask(int l,int r) { if(l==r)return l*lv(l,r).set; int m=l+(r-l)/2; lv(l,m).set=max(lv(l,m).set,lv(l,r).set); lv(m+1,r).set=max(lv(m+1,r).set,lv(l,r).set); return ask(l,m)^ask(m+1,r); }};int main(){ ul t,n,m,x,y,z; for(scanf(\"%u\",&amp;t); t--;) { scanf(\"%u%u%u%u%u\",&amp;n,&amp;m,&amp;x,&amp;y,&amp;z); SegmentTree tree(n); for(int i=0,l,r; i&lt;m; ++i) { if(l=rng61(x,y,z)%n+1,r=rng61(x,y,z)%n+1,l&gt;r)swap(l,r); tree.set(l,r,rng61(x,y,z)%(1&lt;&lt;30)); } printf(\"%lld\\n\",tree.ask(1,n)); }}","link":"/2018/08/20/2018-08-20-2018 Multi-University Training Contest 5/"},{"title":"2018 Multi-University Training Contest 10","text":"Problem G. Cyclic递推。 12345678910111213#include&lt;stdio.h&gt;#define N 100009#define M 998244353#define mul(a,b,c) ((a)*(b)%(c))typedef long long ll;ll t,n,f[N]= {0,1,0,1,1};int main(){ for(ll i=5; i&lt;N; ++i) f[i]=(mul(i-3,f[i-1],M)+mul(2*i-4,f[i-2],M)+mul(i-2,f[i-3],M))%M; for(scanf(\"%lld\",&amp;t); t--; printf(\"%lld\\n\",f[n])) scanf(\"%lld\",&amp;n);} Problem H. Pow交了一个高精度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;struct Wint:vector&lt;int&gt;{ static const int width=9,base=1e9; Wint(unsigned long long n=0) { for(; n; n/=base)push_back(n%base); } explicit Wint(const string &amp;s) { for(int len=int(s.size()-1)/width+1,b,e,i=0; i!=len; ++i) for(e=s.size()-i*width,b=max(0,e-width),push_back(0); b!=e; ++b) back()=back()*10+s[b]-&apos;0&apos;; trim(0); } Wint&amp; trim(bool up=1) { for(int i=1; up&amp;&amp;i&lt;size(); ++i) { if(at(i-1)&lt;0)--at(i),at(i-1)+=base; if(at(i-1)&gt;=base)at(i)+=at(i-1)/base,at(i-1)%=base; } while(!empty()&amp;&amp;back()&lt;=0)pop_back(); for(; up&amp;&amp;!empty()&amp;&amp;back()&gt;=base; at(size()-2)%=base) push_back(back()/base); return *this; }};Wint&amp; operator*=(Wint &amp;a,const Wint &amp;b){ Wint c; c.assign(a.size()+b.size()+2,0); for(int j=0,k,l; j&lt;b.size(); ++j) if(b[j]) for(int i=0; i&lt;a.size(); ++i) { unsigned long long n=a[i]; for(n*=b[j],k=i+j; n; n/=c.base)c[k++]+=n%c.base; for(l=i+j; c[l]&gt;=c.base||l&lt;k; c[l++]%=c.base)c[l+1]+=c[l]/c.base; } return swap(a,c),a.trim(0);}ostream&amp; operator&lt;&lt;(ostream &amp;os,const Wint &amp;n){ if(n.empty())return os.put(&apos;0&apos;); os&lt;&lt;n.back(); char ch=os.fill(&apos;0&apos;); for(int i=n.size()-2; ~i; --i) os.width(n.width),os&lt;&lt;n[i]; return os.fill(ch),os;}typedef Wint ll;ll pow(ll a,int b){ ll r=1; for(; b; b&gt;&gt;=1,a*=a) if(b&amp;1)r*=a; return r;}int main(){ int t,n; for(cin&gt;&gt;t; t--; cout&lt;&lt;pow(ll(2),n)&lt;&lt;&apos;\\n&apos;) cin&gt;&gt;n;} 可以直接修改cout的浮点输出方式为指数形式输出。 12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int t,n; for(cin&gt;&gt;t; t--; cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;pow(2,n)&lt;&lt;'\\n') cin&gt;&gt;n;} Problem I. Count12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct EulerSieve{ vector&lt;int&gt; p,m,phi; vector&lt;ll&gt; sum; EulerSieve(int N):m(N,0),phi(N,0),sum(N,0) { phi[1]=1; for(long long i=2,k; i&lt;N; ++i) { if(!m[i])p.push_back(m[i]=i),phi[i]=i-1; sum[i]=sum[i-1]+(i%2?phi[i]/2:phi[i]); for(int j=0; j&lt;p.size()&amp;&amp;(k=i*p[j])&lt;N; ++j) { phi[k]=phi[i]*p[j]; if((m[k]=p[j])==m[i])break; phi[k]-=phi[i]; } } }} e(2e7+7);int main(){ ll t,n; for(scanf(\"%lld\",&amp;t); t--; printf(\"%lld\\n\",e.sum[n]))scanf(\"%lld\",&amp;n);} Problem J. CSGO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=100000+10;int t,n,m,k,v;long long f[70],g[70];int x[10];long long ans;int main(){ scanf(\"%d\",&amp;t); while (t--) { memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); ans=0; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for (int i=1;i&lt;=n;i++) { scanf(\"%d\",&amp;v); for (int i=1;i&lt;=k;i++) scanf(\"%d\",&amp;x[i]); for (int j=0;j&lt;(1&lt;&lt;(k+1));j++) { long long sum=v; for (int l=1;l&lt;=k;l++) if ((1&lt;&lt;l)&amp;j) sum+=x[l]; else sum-=x[l]; f[j]=max(f[j],sum); } } for (int i=1;i&lt;=m;i++) { scanf(\"%d\",&amp;v); for (int i=1;i&lt;=k;i++) scanf(\"%d\",&amp;x[i]); for (int j=0;j&lt;(1&lt;&lt;(k+1));j++) { long long sum=v; for (int l=1;l&lt;=k;l++) if ((1&lt;&lt;l)&amp;j) sum+=x[l]; else sum-=x[l]; ans=max(ans,sum+f[(1&lt;&lt;(k+1))-1-j]); } } printf(\"%lld\\n\",ans); } return 0;} Problem L.Videos最大费用流。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const ll INF=1e9,NPOS=-1;struct Graph{ struct Vertex { vector&lt;int&gt; a; }; struct Edge { int from,to; ll dist,cap; }; vector&lt;Vertex&gt; v; vector&lt;Edge&gt; e; Graph(int n):v(n) {} void add(const Edge &amp;ed) { v[ed.from].a.push_back(e.size()); e.push_back(ed); }};struct EdmondKarp:Graph{ ll flow,cost; vector&lt;ll&gt; f; EdmondKarp(int n):Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.from,ed.to),ed.cap=0,ed.dist*=-1; Graph::add(ed); } void ask(int s,int t) { vector&lt;int&gt; p(v.size(),NPOS); for(f.assign(e.size(),flow=cost=0);;) { vector&lt;ll&gt; d(v.size(),INF); vector&lt;int&gt; flag(v.size(),d[s]=0); for(deque&lt;int&gt; q(flag[s]=1,s); !q.empty(); q.pop_front()) for(int u=q.front(),i=flag[u]=0,k,to; i&lt;v[u].a.size(); ++i) if(k=v[u].a[i],to=e[k].to, e[k].cap&gt;f[k]&amp;&amp;d[to]&gt;d[u]+e[k].dist) { d[to]=d[u]+e[k].dist,p[to]=k; if(!flag[to])q.push_back(to),flag[to]=1; } if(d[t]==INF)return; ll _f=INF; for(int u=t; u!=s; u=e[p[u]].from) _f=min(_f,e[p[u]].cap-f[p[u]]); for(int u=t; u!=s; u=e[p[u]].from) cost+=_f*e[p[u]].dist,f[p[u]]+=_f,f[p[u]^1]-=_f; flow+=_f; } }};int t,n,m,k,w,S[255],T[255],W[255],P[255];int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d%d%d\",&amp;n,&amp;m,&amp;k,&amp;w); EdmondKarp g(m*2+3); for(int i=1; i&lt;=m; ++i) scanf(\"%d%d%d%d\",&amp;S[i],&amp;T[i],&amp;W[i],&amp;P[i]); for(int i=1; i&lt;=m; ++i) { for(int j=1; j&lt;=m; ++j) if(S[j]&gt;=T[i]) g.add({2*i+1,2*j,P[i]==P[j]?w:0,1}); g.add({1,2*i,0,1}); g.add({2*i,2*i+1,-W[i],1}); g.add({2*i+1,2*m+2,0,1}); } g.add({0,1,0,k}); g.ask(0,2*m+2); printf(\"%d\\n\",-g.cost); }}","link":"/2018/08/24/2018-08-24-2018 Multi-University Training Contest 10/"},{"title":"2018 Multi-University Training Contest 8","text":"Character Encoding容斥一下即可。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) ((a)*(b)%(c))#define inv(a,b) pow(a,(b)-2,b)using namespace std;typedef long long ll;const ll N=1e5+7,M=998244353;ll pow(ll a,ll b,ll m){ ll r=1; for(a%=m; b; b&gt;&gt;=1,a=mul(a,a,m)) if(b&amp;1)r=mul(r,a,m); return r;}struct Factorial{ vector&lt;ll&gt; fac,ifac; ll M; Factorial(int N,ll M):fac(N,1),ifac(N,1),M(M) { for(int i=1; i&lt;N; ++i)fac[i]=mul(fac[i-1],i,M); ifac[N-1]=inv(fac[N-1],M); for(int i=N-1; i; --i)ifac[i-1]=mul(ifac[i],i,M); } ll c(int n,int m) { return mul(mul(fac[n],ifac[m],M),ifac[n-m],M); }} f(2*N,M);int main(){ int t,n,m,k,ans; for(scanf(\"%d\",&amp;t); t--; printf(\"%d\\n\",ans)) { scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=ans=0; k+m-1-i*n&gt;=m-1&amp;&amp;i&lt;=m; ++i) { if(i%2)ans=(ans-mul(f.c(m,i),f.c(k+m-1-i*n,m-1),M)+M)%M; else ans=(ans+mul(f.c(m,i),f.c(k+m-1-i*n,m-1),M))%M; } }} Parentheses Matrix两种方案并行选最优。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;void printH(int h,int w){ for(int i=0; i&lt;h; ++i,printf(\"\\n\")) for(int j=0; j&lt;w; ++j) printf(i%2?\")\":\"(\");}void printW(int h,int w){ for(int i=0; i&lt;h; ++i,printf(\"\\n\")) for(int j=0; j&lt;w; ++j) printf(j%2?\")\":\"(\");}char s[255][255];void PH(int h,int w){ for(int i=0; i&lt;h; ++i) for(int j=0; j&lt;w; ++j) s[i][j]=i%2?')':'('; for(int i=1; i&lt;h-2; i+=2) for (int j=0; j&lt;w/2; ++j)swap(s[i][j],s[i+1][j]); for(int i=0; i&lt;h; ++i,printf(\"\\n\")) for (int j=0; j&lt;w; ++j)printf(\"%c\",s[i][j]);}void PW(int h,int w){ for(int i=0; i&lt;h; ++i) for(int j=0; j&lt;w; ++j) s[i][j]=j%2?')':'('; for(int j=1; j&lt;w-2; j+=2) for (int i=0; i&lt;h/2; ++i)swap(s[i][j],s[i][j+1]); for(int i=0; i&lt;h; ++i,printf(\"\\n\")) for (int j=0; j&lt;w; ++j)printf(\"%c\",s[i][j]);}void cal1(int h,int w){ if(h&gt;w)PW(h,w); else PH(h,w);}void cal(int h,int w){ for(int i=0; i&lt;h; ++i,printf(\"\\n\")) for(int j=0; j&lt;w; ++j) printf(!i?\"(\": i==h-1?\")\": !j?\"(\": j==w-1?\")\": (i+j)%2?\"(\":\")\");}int main(){ int t,h,w; for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d\",&amp;h,&amp;w); if(h%2&amp;&amp;w%2)printW(h,w); else if(h%2)printW(h,w); else if(w%2)printH(h,w); else if(h+w-min(h,w)/2-1&gt;h+w-4)cal1(h,w); else cal(h,w); }} Magic Square1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;struct Matrix{ char a[9][9]; void spin(int x,int y) { swap(a[x][y],a[x+1][y]),swap(a[x+1][y],a[x+1][y+1]),swap(a[x+1][y+1],a[x][y+1]); }} m;int t,n;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;n); for(int i=0; i&lt;3; ++i)scanf(\"%s\",&amp;m.a[i]); for(char s[9]; n--;) { scanf(\"%s\",s); for(int i=s[1]=='C'?1:3; i; --i) m.spin(s[0]=='3'||s[0]=='4',s[0]=='2'||s[0]=='4'); } for(int i=0; i&lt;3; ++i)printf(\"%s\\n\",m.a[i]); }} Taotao Picks Apples123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int maxn=200000+10;struct query{ int id,p,q;}q[maxn];bool cmp(query x,query y) {return x.p&gt;y.p;}int t,n,m,tr,br,cur;int h[maxn],a[maxn],b[maxn],f[maxn],ans[maxn];vector &lt;int&gt; k[maxn];bool inans[maxn];int getpos(int v){ int l=0,r=br,mid; while (r-l&gt;1) { mid=(l+r)/2; if (h[b[mid]]&gt;v) l=mid; else r=mid; } return l;}int main(){ scanf(\"%d\",&amp;t); while (t--) { scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;h[i]); for (int i=1;i&lt;=m;i++) { scanf(\"%d%d\",&amp;q[i].p,&amp;q[i].q); q[i].id=i; } sort(q+1,q+m+1,cmp); tr=1; cur=1; h[0]=1e9*2; for (int i=n;i&gt;=1;i--) { while ((tr&gt;1)&amp;&amp;(h[a[tr-1]]&lt;=h[i])) k[i].push_back(h[a[tr-1]]),tr--; a[tr++]=i; } memset(inans,false,sizeof(inans)); for (int i=1;i&lt;tr;i++) inans[a[i]]=true; cur=0; for (int i=1;i&lt;=n;i++) { f[i]=cur; if (i==a[tr-cur-1]) cur++; } br=1; cur=1; for (int i=n;i&gt;=1;i--) { while ((cur&lt;=m)&amp;&amp;(q[cur].p==i)) { if (q[cur].q&gt;h[i]) { if ((h[a[tr-f[i]]]&gt;=q[cur].q)&amp;&amp;(i!=1)) ans[q[cur].id]=tr-1; else { int g=getpos(q[cur].q); //printf(\"??%d \",g); ans[q[cur].id]=f[i]+g+1; } } else if (q[cur].q&lt;h[i]) { if (!inans[i]) ans[q[cur].id]=tr-1; else { int g1=upper_bound(k[i].begin(),k[i].end(),q[cur].q)-k[i].begin(); int g2=upper_bound(k[i].begin(),k[i].end(),h[a[tr-f[i]]])-k[i].begin(); if (i==1) g2=-1; ans[q[cur].id]=tr-1+k[i].size()-max(g1,g2); // printf(\"? %d %d\\n\",g1,g2); if ((q[cur].q&lt;=h[a[tr-f[i]]])&amp;&amp;(i!=1)) ans[q[cur].id]--; } } else ans[q[cur].id]=tr-1; // printf(\"! %d %d %d %d\\n\",q[cur].id,q[cur].p,q[cur].q,ans[q[cur].id]); cur++; } while ((br&gt;1)&amp;&amp;(h[b[br-1]]&lt;=h[i])) br--; b[br++]=i; } for (int i=1;i&lt;=m;i++) printf(\"%d\\n\",ans[i]); for (int i=1;i&lt;=n;i++) { vector &lt;int&gt; x; swap(k[i],x); } memset(ans,0,sizeof(ans)); } return 0;}","link":"/2018/08/23/2018-08-23-2018 Multi-University Training Contest 8/"},{"title":"2012 ACM-ICPC Asia Dhaka Regional Contest","text":"Wedding of Sultan123456789101112131415161718192021#include&lt;stdio.h&gt;char s[63];int t,k,kase=0,ans[99];void dfs(char u){ for(; s[++k]!=u; dfs(s[k]))++ans[s[k]],++ans[u];}int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%s\",s); for(char c='A'; c&lt;='Z'; ++c) ans[c]=0; dfs(s[k=0]); printf(\"Case %d\\n\",++kase); for(char c='A'; c&lt;='Z'; ++c) if(ans[c]) printf(\"%c = %d\\n\",c,ans[c]); }} Memory Overflow12345678910111213141516#include&lt;stdio.h&gt;char s[511];int t,n,k,kase=0,ans,pre[99];int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"Case %d: %d\\n\",++kase,ans)) { scanf(\"%d%d%s\",&amp;n,&amp;k,s); for(char c='A'; c&lt;='Z'; ++c)pre[c]=-1; for(int i=ans=0; i&lt;n; ++i) { if(~pre[s[i]]&amp;&amp;i-pre[s[i]]&lt;=k)++ans; pre[s[i]]=i; } }} Poker End Games12345678910111213141516171819202122#include&lt;stdio.h&gt;typedef double lf;const lf EPS=1e-6;int t,kase=0,a,b;lf ans0,ans1;void dfs(int a,int b,lf c,int d){ if(c+c*d&lt;EPS)return; if(!b)ans1+=c; if(!a||!b) { ans0+=c*d; return; } int e=a&lt;b?a:b; dfs(a-e,b+e,c/2,d+1),dfs(a+e,b-e,c/2,d+1);}int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"Case %d: %.6f %.6f\\n\",++kase,ans0,ans1)) scanf(\"%d%d\",&amp;a,&amp;b),dfs(a,b,1,ans0=ans1=0);} Overlapping Characters123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N=17,M=43;typedef bitset&lt;N*M&gt; bs;bs b[99];char s[M],t[N*M+9];int n,q,kase=0;int main(){ scanf(\"%d%d%s\",&amp;n,&amp;q,s); for(int i=0; i&lt;n; ++i) { for(int j=0; j&lt;N; ++j) scanf(\"%s\",t+j*M); b[s[i]]=bs(t,N*M,'.','*');//c++11 } for(; q--; printf(\"\\n\")) { scanf(\"%s\",s); printf(\"Query %d: \",++kase); for(int i=0; s[i]; ++i) { bs d=b[s[i]]; for(int j=0; s[j]; ++j) if(s[j]!=s[i]) d&amp;=~b[s[j]]; printf(d.none()?\"N\":\"Y\"); } }} Learning Vector#include&lt;bits/stdc++.h&gt; using namespace std; const int INF=-1e9; struct Vec { int X,Y; bool operator&lt;(const Vec &amp;v)const { return v.Y*X&lt;Y*v.X; } } v[51]; int t,n,k,kase=0,f[51][51][51*51]; int main() { for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d\",&amp;n,&amp;k); for(int i=0; i&lt;n; ++i) scanf(\"%d%d\",&amp;v[i].X,&amp;v[i].Y); sort(v,v+n); for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;=k; ++j) for(int h=51*51; h--;) { if(i) { f[i][j][h]=f[i-1][j][h]; if(j&amp;&amp;h&gt;=v[i].Y) f[i][j][h]=max(f[i][j][h], f[i-1][j-1][h-v[i].Y]+v[i].X*(2*h-v[i].Y)); } else { if(j==1)f[i][j][h]=h==v[i].Y?v[i].X*v[i].Y:INF; else if(j==0)f[i][j][h]=h?INF:0; else f[i][j][h]=INF; } } int ans=0; for(int h=51*51; h--;)ans=max(ans,f[n-1][k][h]); printf(\"Case %d: %d\\n\",++kase,ans); } }","link":"/2018/08/26/2018-08-26-2012 ACM-ICPC Asia Dhaka Regional Contest/"},{"title":"2014 ACM-ICPC Asia Dhaka Regional Contest","text":"Decoding Baby Boos另解：使用链表快速合并。 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;char s[1000009],a[9],b[9];int t,r;int main(){ for(scanf(\"%d\",&amp;t); t--;) { vector&lt;list&lt;int&gt; &gt; l(99); scanf(\"%s%d\",s,&amp;r); for(int i=0; s[i]; ++i) l[s[i]].push_back(i); for(; r--; l[a[0]].splice(l[a[0]].end(),l[b[0]])) scanf(\"%s%s\",a,b); for(int i=0; i&lt;l.size(); ++i) for(list&lt;int&gt;::iterator it=l[i].begin(); it!=l[i].end(); ++it) s[*it]=i; printf(\"%s\\n\",s); }} And Or123456789101112131415#include&lt;stdio.h&gt;long long t,kase,a,b,ansOr,ansAnd;int main(){ for(scanf(\"%lld\", &amp;t); t--;) { scanf(\"%lld%lld\",&amp;a,&amp;b); ansAnd=a,ansOr=a; for(int i=0; !(a&gt;&gt;i&amp;1)&amp;&amp;i&lt;63; ++i) if(b-a&gt;=1LL&lt;&lt;i)ansOr|=1LL&lt;&lt;i; for(; a&lt;=b; a+=a&amp;-a) ansOr|=a,ansAnd&amp;=a; printf(\"Case %lld: %lld %lld\\n\",++kase,ansOr,ansAnd); }} A game for kids123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) (1LL*(a)*(b)%(c))using namespace std;const int M=21092013,H=51;struct GCD{ int a[H][H]; GCD() { for(int i=1; i&lt;H; ++i) for(int j=i; j&lt;H; ++j) a[i][j]=a[j][i]=__gcd(i,j); }} gcd;#define __gcd(i,j) gcd.a[i][j]struct Graph{ struct Vertex { vector&lt;int&gt; a,f; int l,h; Vertex():f(H,0) {} }; struct Edge { int from,to; }; vector&lt;Vertex&gt; v; vector&lt;Edge&gt; e; vector&lt;int&gt; ans; Graph(int n):v(n),ans(H,0) {} void add(const Edge &amp;ed) { v[ed.from].a.push_back(e.size()); e.push_back(ed); } void dfs(int u,int fa) { for(int i=0,to,g; i&lt;v[u].a.size(); ++i) if(to=e[v[u].a[i]].to,to!=fa) { dfs(to,u); for(int j=1; j&lt;H; ++j) for(int k=1; k&lt;H; ++k) g=__gcd(j,k),ans[g]=(ans[g]+mul(v[to].f[k],v[u].f[j],M))%M; for(int k=1; k&lt;H; ++k) for(int j=v[u].l; j&lt;=v[u].h; ++j) g=__gcd(j,k),v[u].f[g]=(v[u].f[g]+v[to].f[k])%M; } for(int i=v[u].l; i&lt;=v[u].h; ++i)v[u].f[i]=(v[u].f[i]+1)%M; }};int main(){ int t,n,kase=0; for(scanf(\"%d\",&amp;t); t--;) { printf(\"Case %d:\\n\",++kase); scanf(\"%d\",&amp;n); Graph g(n); for(int i=1,u,v; i&lt;n; ++i) scanf(\"%d%d\",&amp;u,&amp;v),g.add({u-1,v-1}),g.add({v-1,u-1}); for(int i=0; i&lt;n; ++i)scanf(\"%d\",&amp;g.v[i].l); for(int i=0; i&lt;n; ++i)scanf(\"%d\",&amp;g.v[i].h); g.dfs(0,-1); for(int i=1; i&lt;H; ++i) { for(int j=0; j&lt;n; ++j)g.ans[i]=(g.ans[i]+g.v[j].f[i])%M; printf(\"%d: %d\\n\",i,g.ans[i]); } }} Refraction123456789101112131415#include&lt;stdio.h&gt;#include&lt;math.h&gt;double EPS=3e-6,W,H,x,xe,ye,mu;int t;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%lf%lf%lf%lf%lf%lf\",&amp;W,&amp;H,&amp;x,&amp;xe,&amp;ye,&amp;mu); double tanH=(ye-H)/(xe-W),E=asin(1)-atan(tanH),sinCPN=sin(E)/mu, tanCPN=tan(asin(sinCPN)),h=(tanH*(W-x)-H)/(tanH*tanCPN-1); if(h-EPS&gt;H)printf(\"Impossible\\n\"); else printf(\"%.4f\\n\",h); }} Load Balancing1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define M 161double f[M][4],d;int t,n,kase,s[M],p[M][4];void print(int i,int j){ if(!j)return; print(p[i][j],j-1); printf(\" %d\",p[i][j]);}int main(){ for(scanf(\"%d\",&amp;t); t--; printf(\"Case %d:\",++kase),print(M-1,3),printf(\"\\n\")) { scanf(\"%d\", &amp;n); for(int i=0; i&lt;M; ++i)s[i]=0; for(int i=0,c; i&lt;n; ++i)scanf(\"%d\",&amp;c),++s[c]; for(int i=1; i&lt;M; ++i)s[i]+=s[i-1]; for(int i=0; i&lt;M; ++i) { f[i][0]=fabs(s[i]-n/4.0),f[i][1]=f[i][2]=f[i][3]=1e9; for(int j=1; j&lt;4; ++j) for(int k=0; k&lt;i; ++k) if(d=fabs(s[i]-s[k]-n/4.0),f[i][j]&gt;f[k][j-1]+d) f[i][j]=f[p[i][j]=k][j-1]+d; } }} Maximum Score12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) ((a)*(b)%(c))using namespace std;typedef unsigned long long ll;const ll N=1e5+7,M=1e9+7;pair&lt;ll,ll&gt; p[N];ll t,n,kase;int main(){ for(scanf(\"%llu\",&amp;t); t--;) { scanf(\"%llu\",&amp;n); for(ll i=0; i&lt;n; ++i) scanf(\"%llu%llu\",&amp;p[i].first,&amp;p[i].second); sort(p,p+n); ll sum=p[0].second,ans=sum*p[0].second,per=1; for(ll i=1; i&lt;n; ++i) { sum+=p[i].second; ans=ans+sum*p[i].second; per=mul(per,p[i-1].second+1,M); } printf(\"Case %llu: %llu %llu\\n\",++kase,ans,per); }}","link":"/2018/08/27/2018-08-27-2014 ACM-ICPC Asia Dhaka Regional Contest/"},{"title":"2018 Multi-University Training Contest 9","text":"Rikka with Nash Equilibrium递推很慢的跑掉了，有的编译器会T掉。 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;string.h&gt;typedef long long ll;ll t,n,m,k,f[2][99][99];int main(){ for(scanf(\"%lld\",&amp;t); t--;) { scanf(\"%lld%lld%lld\",&amp;n,&amp;m,&amp;k); memset(f,0,sizeof(f)); f[1][1][1]=n*m; for(int i=2,pre=1; i&lt;=n*m; ++i,pre^=1) for(int x=1; x&lt;=n&amp;&amp;x&lt;=i; ++x) for(int y=1; y&lt;=m&amp;&amp;y&lt;=i; ++y) f[pre^1][x][y]=((n-x+1)*y*f[pre][x-1][y]+ (m-y+1)*x*f[pre][x][y-1]+ (x*y-i+1)*f[pre][x][y])%k; printf(\"%lld\\n\",f[n*m%2][n][m]); }} 赛后翻题解才知道有现成公式… 12345678910111213#include&lt;stdio.h&gt;typedef long long ll;ll t,n,m,k,ans;int main(){ for(scanf(\"%lld\",&amp;t); t--; printf(\"%lld\\n\",ans)) { scanf(\"%lld%lld%lld\",&amp;n,&amp;m,&amp;k); for(ll i=ans=1; i&lt;=n; ++i)ans=ans*i%k; for(ll i=1; i&lt;=m; ++i)ans=ans*i%k; for(ll i=n+m; i&lt;=n*m; ++i)ans=ans*i%k; }} Rikka with Stone-Paper-Scissors123456789101112131415161718#include&lt;stdio.h&gt;typedef long long ll;ll t,a1,b1,c1,a2,b2,c2;ll gcd(ll a,ll b){ return b?gcd(b,a%b):a;}int main(){ for(scanf(\"%lld\",&amp;t); t--; printf(\"\\n\")) { scanf(\"%lld%lld%lld%lld%lld%lld\",&amp;a1,&amp;b1,&amp;c1,&amp;a2,&amp;b2,&amp;c2); ll n=a2*(c1-b1)+b2*(a1-c1)+c2*(b1-a1),d=a1+b1+c1,g; if(n&lt;0)printf(\"-\"),n=-n; g=gcd(n,d),printf(\"%lld\",n/=g); if(d/=g,d&gt;1)printf(\"/%lld\",d); }} Rikka with Time Complexity12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int t,a,b,INF=1e9+7;vector&lt;int&gt; cal(const vector&lt;int&gt; &amp;A){ vector&lt;int&gt; r(4,INF); if(A.size()==1) { r[0]=A[0]+2; } if(A.size()==2) { r[0]=min(A[0]+2,A[1]+1); r[2]=max(A[0]+2,A[1]+1); } if(A.size()==3) { if(A[0]+2&lt;min(A[1]+1,A[2])) { r[0]=A[0]+2; r[2]=min(A[1]+1,A[2]); r[3]=max(A[1]+1,A[2]); } else { r[0]=min(A[1]+1,A[2]); r[1]=max(A[1]+1,A[2]); r[2]=A[0]+2; } } return r;}int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d\",&amp;a,&amp;b); vector&lt;int&gt; A(a),B(b); for(int i=0,t; i&lt;a; ++i)scanf(\"%d\",&amp;A[i]); for(int i=0,t; i&lt;b; ++i)scanf(\"%d\",&amp;B[i]); printf(\"%d\\n\",cal(A)&gt;cal(B)?-1:cal(A)&lt;cal(B)); }} Rikka with Badminton1234567891011121314151617#include&lt;stdio.h&gt;#define mul(a,b,c) ((a)*(b)%(c))typedef long long ll;ll M=998244353,t,a,b,c,d;ll pow(ll a,ll b,ll m){ ll r=1; for(; b; b&gt;&gt;=1,a=mul(a,a,m)) if(b&amp;1)r=mul(r,a,m); return r;}int main(){ for(scanf(\"%lld\",&amp;t); t--; printf(\"%lld\\n\",mul(pow(2,a,M),(pow(2,b,M)-b-1+mul(pow(2,c,M),(b+d+1)%M,M)+M)%M,M))) scanf(\"%lld%lld%lld%lld\",&amp;a,&amp;b,&amp;c,&amp;d);}","link":"/2018/08/24/2018-08-24-2018 Multi-University Training Contest 9/"},{"title":"Sliding Window","text":"题目链接单调队列模板题，求n个数每k个连续的数的最小最大值；最大值可直接插相反数进去，取出的时候再取回即可。poj上STL特别的慢了，语言要选C++而非G++才能勉强跑过…大致能看个做法即可。用数组模拟STL队列直接快了一倍多… 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;deque&gt;using namespace std;const int N=1e6+9;typedef int ll;typedef pair&lt;int,ll&gt; pil;struct MonotoneQueue:deque&lt;pil&gt;{ void push(pil p,int k) { while(!empty()&amp;&amp;back().second&gt;=p.second)pop_back(); for(push_back(p); p.first-front().first&gt;=k;)pop_front(); }} q[2];int n,k,ans[2][N];int main(){ scanf(\"%d%d\",&amp;n,&amp;k); for(int i=0,a; i&lt;n; ++i) { scanf(\"%d\",&amp;a); q[0].push(pil(i,a),k); ans[0][i]=q[0].front().second; q[1].push(pil(i,-a),k); ans[1][i]=-q[1].front().second; } for(int j=0; j&lt;2; ++j) for(int i=k-1; i&lt;n; ++i) printf(\"%d%c\",ans[j][i],i+1==n?'\\n':' ');}","link":"/2018/09/03/2018-09-03-POJ-2823/"},{"title":"ACM ICPC 2013–2014, Northeastern European Regional Contest","text":"Bonus Cards概率dp。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define cin fin#define cout foutusing namespace std;ifstream fin(\"bonus.in\");ofstream fout(\"bonus.out\");double f[3009][3009]/*= {1}*/;//去掉注释会因为生成文件过大而过不了编译？double dp(int n,int a,int b,int c){ for(int i=f[0][0]=1; i&lt;=n; ++i) for(int j=0; j&lt;=i; ++j) { f[i][j]=0; if(a-j+1&gt;0&amp;&amp;b-i+j&gt;=0)f[i][j]+=2*(a-j+1)/(2.0*(a-j+1)+b-i+j+c)*f[i-1][j-1]; if(a-j&gt;=0&amp;&amp;b-i+j+1&gt;0)f[i][j]+=(b-i+j+1)/(2.0*(a-j)+b-i+j+1+c)*f[i-1][j]; } return accumulate(f[n],f[n]+min(a,n)+1,0.0);}int main(){ int n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; cout.precision(9); cout&lt;&lt;1-dp(n,a,b,2)&lt;&lt;'\\n'&lt;&lt;1-dp(n,a,b,1);} Fraud Busters1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define cin fin#define cout foutusing namespace std;ifstream fin(\"fraud.in\");ofstream fout(\"fraud.out\");vector&lt;string&gt; ans;string s,t;int n,flag;int main(){ for(cin&gt;&gt;s&gt;&gt;n; n--;) { cin&gt;&gt;t; for(int i=flag=0; !flag&amp;&amp;i&lt;t.size(); ++i) if(s[i]!='*'&amp;&amp;s[i]!=t[i]) flag=1; if(!flag)ans.push_back(t); } cout&lt;&lt;ans.size(); for(int i=0; i&lt;ans.size(); ++i) cout&lt;&lt;'\\n'&lt;&lt;ans[i];} Hack Protection感觉相当复杂的一题，两小时就有一堆神仙过了…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define cin fin#define cout fout#define log2(n) LOG2[n]#define at(n) operator[](n)using namespace std;typedef int ll;const int N=1e5+9;ifstream fin(\"hack.in\");ofstream fout(\"hack.out\");struct Log:vector&lt;ll&gt;{ Log(int N,ll E):vector&lt;ll&gt;(N,-1) { for(int i=1; i&lt;N; ++i)at(i)=at(i/E)+1; }} LOG2(N,2);struct RangeAnd{ vector&lt;vector&lt;ll&gt; &gt; f; RangeAnd(const vector&lt;ll&gt; &amp;a):f(log2(a.size())+1,a) { for(int k=0; k+1&lt;f.size(); ++k) for(int i=0; i+(1&lt;&lt;k)&lt;a.size(); ++i) f[k+1][i]=min(f[k][i],f[k][i+(1&lt;&lt;k)]); } ll min(ll l,ll r)//区间位与和区间最小值用一样的求法 { return l&amp;r; } ll ask(int l,int r)//[l,r]区间内的位与和 { int k=log2(r-l+1); return min(f[k][l],f[k][r+1-(1&lt;&lt;k)]); } int bs(int l,int r,int b,ll val)//[l,r)区间内找最大的m使ask(b,m)==val { if(r-l&lt;2)return l; int m=l+(r-l)/2; return ask(b,m)&lt;val?bs(l,m,b,val):bs(m,r,b,val); }};struct RangeXor:vector&lt;ll&gt;{ unordered_map&lt;ll,vector&lt;int&gt; &gt; mp; RangeXor(int N):vector&lt;ll&gt;(N,0) {} void init() { for(int i=1; i&lt;size(); ++i)mp[at(i)^=at(i-1)].push_back(i); }};int main(){ long long n,ans=0; cin&gt;&gt;n; RangeXor rx(n+1); for(int i=1; i&lt;=n; ++i)cin&gt;&gt;rx[i]; RangeAnd ra(rx); rx.init(); for(int i=1; i&lt;=n; ++i) for(int l,r; l&lt;=n; l=r+1) { const vector&lt;int&gt; &amp;v=rx.mp[ra.ask(i,l)^rx[i-1]]; r=ra.bs(l,n+1,i,ra.ask(i,l));//[l,r]内任意m，[i,m]区间位与值均为ra.ask(i,l)^rx[i-1] ans+=upper_bound(v.begin(),v.end(),r)-lower_bound(v.begin(),v.end(),l); } cout&lt;&lt;ans;} Join the Conversation玄学字符串处理题，注意不要写丑了… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define cin fin#define cout foutusing namespace std;ifstream fin(\"join.in\");ofstream fout(\"join.out\");struct Identifier:unordered_map&lt;string,int&gt;{ int operator()(const string &amp;a) { if(!count(a))insert(make_pair(a,size())); return at(a); }} id;string s;unordered_map&lt;int,int&gt; mp;pair&lt;int,int&gt; p[50005];int n,user,mention,ans;void print(int ans){ if(ans)print(p[ans].second),cout&lt;&lt;ans&lt;&lt;' ';}int main(){ getline(cin&gt;&gt;n,s); for(int i=1; i&lt;=n; ++i) { getline(cin,s,':'); user=id(s); getline(cin,s); s+=\" \"+s+\" \"; for(int pos=0,len; pos=s.find('@',pos),pos!=s.npos; pos+=len) { len=s.find(' ',pos)-pos; if(s[pos-1]==' '&amp;&amp;s[pos+len]==' ') if(mention=id(s.substr(pos,len)),mention!=user) if(p[i].first&lt;p[mp[mention]].first) { p[i].first=p[mp[mention]].first; p[i].second=mp[mention]; } } if(++p[i].first,p[mp[user]].first&lt;p[i].first)mp[user]=i; if(p[ans].first&lt;p[i].first)ans=i; } cout&lt;&lt;p[ans].first&lt;&lt;'\\n'; print(ans);}","link":"/2018/08/28/2018-08-28-ACM ICPC 2013–2014, Northeastern European Regional Contest/"},{"title":"Hazard","text":"题目链接：BZOJ4295: [PA2015]Hazard权限题所以把题面也贴出来。Time Limit: 10 Sec Memory Limit: 512 MB Description有n个人在轮流玩赌博机，一开始编号为i的人有a[i]元钱。赌博机可以抽象为一个长度为m的仅包含1和-1的序列，若抽到1，那么你将得到1块钱；若抽到-1，你将输掉1块钱。第1局，第1个人会抽到序列中的第1项；第2局，第2个人会抽到序列中的第2项；第3局，第3个人会抽到序列中的第3项……即：第i个人抽完后轮到第i+1个人去抽，特别地，第n个人抽完后轮到第1个人去抽。序列第i项被抽到之后，下一个被抽到的将会是第i+1项，特别地，序列第m项被抽到之后，下一个被抽到的将会是第1项。如果在某一轮，有个人输光了所有的钱，那么这场赌博游戏就会结束，请求出游戏在哪一轮结束，或者判断这个游戏会永远进行下去。 Input第一行包含一个正整数n(1&lt;=n&lt;=1000000)，表示玩家的个数。第二行包含n个正整数a[1],a[2],…,an，依次表示每个玩家一开始持有的钱数。第一行包含一个正整数m(1&lt;=m&lt;=1000000)，表示序列的长度。第四行包含一个长度为m的仅包含W和P的字符串，表示这个序列，其中W表示1，P表示-1。 Output若游戏会永远进行下去，输出-1。否则输出游戏在哪一轮结束。 Sample Input123442 3 2 13WPP Sample Output112 代码把队列和栈用全用数组模拟也只能跑7800ms，status里面最快的神仙只跑了2600ms不知道怎么做到的… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,ll&gt; pil;const ll N=2e6+7,INF=1e18;struct MonotoneQueue:deque&lt;pil&gt;{ void push(pil p,int k) { while(!empty()&amp;&amp;back().second&gt;=p.second)pop_back(); for(push_back(p); p.first-front().first&gt;=k;)pop_front(); }};char s[N];ll ans=INF;int n,m,a[N],vis[N],mn[N],sum[N],pre[N&lt;&lt;1];int main(){ scanf(\"%d\",&amp;n); for(int i=0; i&lt;n; ++i)scanf(\"%d\",&amp;a[i]); scanf(\"%d%s\",&amp;m,s); for(int k=0; k&lt;m; ++k) if(!vis[k]) { MonotoneQueue q; vector&lt;int&gt; v; for(int i=k; !vis[i]; i=(i+n)%m)v.push_back(i),vis[i]=1; for(int i=0; i&lt;2*v.size(); ++i) { q.push(pil(i+1,sum[i+1]=sum[i]+(s[v[i%v.size()]]=='W'?1:-1)),v.size()+1); if(i&gt;=v.size())mn[i-v.size()+1]=sum[i-v.size()]-q.front().second; } for(int i=2*v.size(); pre[sum[i]+N]=i; --i) if(i&lt;=v.size()) for(int j=v[i-1]; j&lt;n; j+=m) if(sum[v.size()]&lt;0||a[j]&lt;=mn[i]) { ll step; if(a[j]&lt;=mn[i])step=pre[sum[i-1]-a[j]+N]-i+1; else { ll lop=(a[j]-mn[i]-1)/(-sum[v.size()])+1; step=lop*v.size()+pre[sum[i-1]-a[j]-lop*sum[v.size()]+N]-i+1; } ans=min(ans,j+1+n*(step-1)); } } printf(\"%lld\",ans&lt;INF?ans:-1LL);}","link":"/2018/09/03/2018-09-03-HYSBZ-4295/"},{"title":"2015 ACM-ICPC Asia Dhaka Regional Contest","text":"Automatic Cheater Detection没注意到难度取值范围小于十，于是写了个二分跑过去了，还挺快的。 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;char r[9];int t,q;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;q); vector&lt;int&gt; dui,cuo; long long ans=0; for(int i=0,s,d; i&lt;q; ++i) { scanf(\"%d%d%s\",&amp;d,&amp;s,r); if(s&amp;&amp;r[0]=='c')dui.push_back(d); if(!s&amp;&amp;r[0]=='i')cuo.push_back(d); } sort(dui.begin(),dui.end()); sort(cuo.begin(),cuo.end()); for(int i=0; i&lt;dui.size(); ++i) ans+=lower_bound(cuo.begin(),cuo.end(),dui[i])-cuo.begin(); printf(\"%lld\\n\",ans); }} Counting Weekend Days123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int mo(const string &amp;s){ return s==\"FEB\"?28: s==\"APR\"||s==\"JUN\"||s==\"SEP\"||s==\"NOV\"?30:31;}int da(const string &amp;s){ return s==\"SUN\"?0: s==\"MON\"?1: s==\"TUE\"?2: s==\"WED\"?3: s==\"THU\"?4: s==\"FRI\"?5:6;}int main(){ int t,ans; string mth,day; for(cin&gt;&gt;t; t--; cout&lt;&lt;ans&lt;&lt;'\\n') { cin&gt;&gt;mth&gt;&gt;day; for(int i=ans=0,m=mo(mth),d=da(day); i&lt;m; ++i,++d) if(d%7&gt;4)++ans; }} Owllen1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;char s[100009];int t,kase,cnt[26];int main(){ for(scanf(\"%d\",&amp;t); t--;) { fill(cnt,cnt+26,0); scanf(\"%s\",s); for(int i=0; s[i]; ++i)++cnt[s[i]-'a']; printf(\"Case %d: %d\\n\",++kase,*min_element(cnt,cnt+26)); }} Sum of MSLCM1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define at operator[]using namespace std;const int N=2e7+7;struct EulerSieve{ vector&lt;int&gt; p,m; EulerSieve(int N):m(N,0) { for(long long i=2,k; i&lt;N; ++i) { if(!m[i])p.push_back(m[i]=i); for(int j=0; j&lt;p.size()&amp;&amp;(k=i*p[j])&lt;N; ++j) if((m[k]=p[j])==m[i])break; } }} e(N);typedef long long ll;struct Solve:vector&lt;ll&gt;{ Solve(int N):vector&lt;ll&gt;(N,0) { for(int i=2; i&lt;N; ++i)at(i)=at(i-1)+cal(i); } ll cal(int x) { if(x==1)return 1; if(at(x))return at(x)-at(x-1); int t=e.m[x]; x/=t; if(x%t==0)return cal(x)*(t+1)-cal(x/t)*t; return cal(x)*(t+1); }} s(N);int main(){ for(int n; scanf(\"%d\",&amp;n),n;)printf(\"%lld\\n\",s[n]);} Design New Capital12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) (1LL*(a)*(b)%(c))#define inv(a,b) pow(a,(b)-2,b)using namespace std;typedef int ll;const ll N=1e5+7,M=7340033,G=3;struct Factorial{ vector&lt;ll&gt; fac,ifac; ll M; Factorial(int N,ll M):fac(N,1),ifac(N,1),M(M) { for(int i=2; i&lt;N; ++i) fac[i]=mul(fac[i-1],i,M),ifac[i]=mul(M-M/i,ifac[M%i],M); for(int i=2; i&lt;N; ++i)ifac[i]=mul(ifac[i],ifac[i-1],M); } ll c(int n,int m) { return mul(mul(fac[n],ifac[m],M),ifac[n-m],M); }} f(N,M);ll pow(ll a,ll b,ll m){ ll r=1; for(; b; b&gt;&gt;=1,a=mul(a,a,m)) if(b&amp;1)r=mul(r,a,m); return r;}struct Rader:vector&lt;int&gt;{ Rader(int n):vector&lt;int&gt;(1&lt;&lt;int(ceil(log2(n)))) { for(int i=at(0)=0; i&lt;size(); ++i) if(at(i)=at(i&gt;&gt;1)&gt;&gt;1,i&amp;1) at(i)+=size()&gt;&gt;1; }};struct FNTT:Rader{ ll M,G; vector&lt;ll&gt; w; FNTT(int N,ll M,ll G):Rader(N),M(M),G(G),w(size(),pow(G,(M-1)/size(),M)) { for(int i=w[0]=1; i&lt;size(); ++i)w[i]=mul(w[i],w[i-1],M); } vector&lt;ll&gt; fntt(const vector&lt;ll&gt; &amp;a)const { vector&lt;ll&gt; x(size()); for(int i=0; i&lt;a.size(); ++i)x[at(i)]=a[i]; for(int i=1; i&lt;size(); i&lt;&lt;=1) for(int j=0; j&lt;i; ++j) for(int k=j; k&lt;size(); k+=i&lt;&lt;1) { ll &amp;l=x[k],&amp;r=x[k+i],t=mul(w[size()/(i&lt;&lt;1)*j],r,M); if(r=l-t,r&lt;0)r+=M; if(l+=t,l&gt;=M)l-=M; } return x; } vector&lt;ll&gt; ask(vector&lt;ll&gt; a,vector&lt;ll&gt; b)const { a=fntt(a),b=fntt(b); for(int i=0; i&lt;size(); ++i)a[i]=mul(a[i],b[i],M); a=fntt(a),reverse(a.begin()+1,a.end()); ll u=inv(size(),M); for(int i=0; i&lt;size(); ++i)a[i]=mul(a[i],u,M); return a; }};int t,n,kase;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;n); vector&lt;ll&gt; a(n+1),b(n+1),c(4,0); for(int i=0,x,y; i&lt;n; ++i) { scanf(\"%d%d\",&amp;x,&amp;y); ++c[x&lt;0&amp;&amp;y&lt;0?3: x&lt;0&amp;&amp;y&gt;0?2: x&gt;0&amp;&amp;y&gt;0]; } for(int i=min(c[0],c[2]); ~i; --i)a[i]=mul(f.c(c[0],i),f.c(c[2],i),M); for(int i=min(c[1],c[3]); ~i; --i)b[i]=mul(f.c(c[1],i),f.c(c[3],i),M); a=FNTT(n+1,M,G).ask(a,b); printf(\"Case %d:\\n\",++kase); for(int i=1; i&lt;=n; ++i) printf(\"%lld%c\",i&amp;1?0:a[i&gt;&gt;1],i&lt;n?' ':'\\n'); }} Numbered Cards1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) (1LL*(a)*(b)%(c))using namespace std;const int N=1e9+7,M=1e9+7;long long t,n,casenum,f[11][1&lt;&lt;11],u[11][1&lt;&lt;11],g[1&lt;&lt;11],h[1&lt;&lt;11];long long ans[1&lt;&lt;11][1&lt;&lt;11];int main(){ f[0][0]=1; for (int i=1; i&lt;10; ++i)f[1][1&lt;&lt;i]=1; for(int i=1; i&lt;10; ++i) for(int j=1&lt;&lt;10; j--;) for(int k=1&lt;&lt;9; k; k&gt;&gt;=1) f[i+1][j|k]=(f[i+1][j|k]+f[i][j])%M; u[0][0]=1; for(int i=0; i&lt;10; ++i) for(int j=1&lt;&lt;10; j--;) for(int k=1&lt;&lt;9; k; k&gt;&gt;=1) u[i+1][j|k]=(u[i+1][j|k]+u[i][j])%M;// for (int i=1;i&lt;1&lt;&lt;6;i++) printf(\"%d \",f[2][i]); for(scanf(\"%lld\",&amp;t); t--;) { fill(g,g+(1&lt;&lt;10),0); vector&lt;int&gt; v; scanf(\"%lld\",&amp;n); for(int j=n+1; j; j/=10)v.push_back(j%10); for(int i=1; i&lt;v.size(); ++i) for(int j=1&lt;&lt;10; j--;) g[j]=(g[j]+f[i][j])%M; for(int i=v.size()-1,now=0; ~i; --i) { for(int j=i==v.size()-1?1:0; j&lt;v[i]; ++j) for(int k=1&lt;&lt;10; k--;) g[k|now|1&lt;&lt;j]=(g[k|now|1&lt;&lt;j]+u[i][k])%M; now|=1&lt;&lt;v[i]; } /* for(int i=1;i&lt;(1&lt;&lt;10);i++) if (g[i]) printf(\"%d %d\\n\",i,g[i]); */ memset(ans,0,sizeof(ans)); ans[0][0]=1; for(int i=0;i&lt;(1&lt;&lt;10)-1;i++) for(int j=0;j&lt;1&lt;&lt;10;j++) { ans[i+1][j]=(ans[i+1][j]+ans[i][j])%M; if (((i+1)&amp;j)==0) ans[i+1][(i+1)|j]=(ans[i+1][(i+1)|j]+(ans[i][j]*g[i+1])%M)%M; } long long val=0; for (int i=0;i&lt;1&lt;&lt;10;i++) val=(val+ans[(1&lt;&lt;10)-1][i])%M; val=(val+M-1)%M; printf(\"Case %lld: %lld\\n\",++casenum,val); }}","link":"/2018/08/31/2018-08-31-2015 ACM-ICPC Asia Dhaka Regional Contest/"},{"title":"The 2018 ACM-ICPC Asia Qingdao Regional Contest, Online","text":"Live Love12345678910111213141516#include&lt;stdio.h&gt;int t,n,m;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d\",&amp;n,&amp;m); if(n==1||!m)printf(\"%d %d\\n\",m,m); else for(int i=1,tmp,res; i&lt;=m; ++i) if(tmp=n/(i+1),res=n-tmp*(i+1),tmp*i+res&gt;=m) { printf(\"%d %d\\n\",m,i); break; } }} Halting Problem1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;struct Instruction{ char s[9]; int v,k,vis[256];} a[10009];int t,n,i,r;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;n); for(i=1; i&lt;=n; ++i) { fill(a[i].vis,a[i].vis+256,0); scanf(\"%s%d\",&amp;a[i].s,&amp;a[i].v); if(a[i].s[1]!='d')scanf(\"%d\",&amp;a[i].k); } for(i=1,r=0; i&lt;=n&amp;&amp;!a[i].vis[r]; ++i) switch(a[i].vis[r]=1,a[i].s[1]) { case 'd': r=(r+a[i].v)%256; break; case 'e': if(r==a[i].v)i=a[i].k-1; break; case 'n': if(r!=a[i].v)i=a[i].k-1; break; case 'l': if(r&lt;a[i].v)i=a[i].k-1; break; case 'g': if(r&gt;a[i].v)i=a[i].k-1; break; } printf(i&gt;n?\"Yes\\n\":\"No\\n\"); }} Traveling on the Axis123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;char s[100009];ll t,ans;int main(){ for(scanf(\"%lld\",&amp;t); t--; printf(\"%lld\\n\",ans)) { scanf(\"%s\",s); for(ll i=ans=0,n=strlen(s); i&lt;n; ++i) { ans+=(i+1)*(n-i); if(s[i]=='0')ans+=n-i; if(i&amp;&amp;s[i]==s[i-1])ans+=i*(n-i); } }} XOR Clique1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,a,k,cnt[31];int main(){ for(scanf(\"%d\",&amp;t); t--;) { fill(cnt,cnt+31,0); for(scanf(\"%d\",&amp;n); n--;) { scanf(\"%d\",&amp;a); for(k=0; a; ++k)a&gt;&gt;=1; ++cnt[k]; } printf(\"%d\\n\",*max_element(cnt,cnt+31)); }}","link":"/2018/09/19/2018-09-19-The 2018 ACM-ICPC Asia Qingdao Regional Contest, Online/"},{"title":"Bad Hair Day","text":"题目链接维护一个递减的单调栈，每次插入后当前这只牛可以被q.size()-1只左边的高于他的牛看到。 12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;deque&gt;using namespace std;const int N=8e4+9;typedef int ll;typedef pair&lt;int,ll&gt; pil;struct MonotoneQueue:deque&lt;pil&gt;{ void push(pil p,int k) { while(!empty()&amp;&amp;back().second&gt;=p.second)pop_back(); for(push_back(p); p.first-front().first&gt;=k;)pop_front(); }} q;long long ans;int n,h;int main(){ for(scanf(\"%d\",&amp;n); n--;) scanf(\"%d\",&amp;h),q.push(pil(n,-h),N),ans+=q.size()-1; printf(\"%lld\",ans);}","link":"/2018/09/03/2018-09-03-POJ-3250/"},{"title":"2009-2010 ACM-ICPC Northeastern European Regional Contest (NEERC 09)","text":"Asteroids模板题，求两空间多面体重心最近的距离，将重心到所在凸包表面的最短距离相加即可。蓝书上的原题，详见这里。 Business Center123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int n,m;int main(){ while (~scanf(\"%d%d\",&amp;n,&amp;m)) { int ans=1000000001; for (int i=1;i&lt;=m;++i) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); int ret=(x*n)%(x+y); if (ret==0) ret=x+y; ans=min(ans,ret); } printf(\"%d\\n\",ans); }} Database1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ for(int n,m,f; cin&gt;&gt;n&gt;&gt;m;) { unordered_map&lt;string,set&lt;int&gt; &gt; mp[15]; string s; getline(cin,s); for(int i=f=1; i&lt;=n; ++i) { unordered_map&lt;int,int&gt; mmp; for(int j=1; j&lt;=m; ++j) { getline(cin,s,j&lt;m?',':'\\n'); if(!f)continue; for(auto it:mp[j][s]) { if(mmp.count(it)) { cout&lt;&lt;\"NO\\n\"&lt;&lt;it&lt;&lt;' '&lt;&lt;i&lt;&lt;'\\n'&lt;&lt;mmp[it]&lt;&lt;' '&lt;&lt;j&lt;&lt;'\\n'; f=0; break; } mmp[it]=j; } mp[j][s].insert(i); } } if(f)cout&lt;&lt;\"YES\\n\"; }} Funny Language123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;void cal(const string &amp;s,int c[]){ fill(c,c+26,0); for(int i=0; i&lt;s.size(); ++i)++c[s[i]-'A'];}string s[1023];int c[1023][31];int main(){ for(int n,m; cin&gt;&gt;m&gt;&gt;n;) { for(int i=0; i&lt;n; ++i) cin&gt;&gt;s[i]; sort(s,s+n); for(int i=0; i&lt;n; ++i)cal(s[i],c[i]); priority_queue&lt;pair&lt;int,string&gt; &gt; q; q.push(make_pair(0,\"\")); while(m) { pair&lt;int,string&gt; pis=q.top(); q.pop(); auto rg=equal_range(s,s+n,pis.second); if(rg.first==rg.second&amp;&amp;!pis.second.empty())cout&lt;&lt;pis.second&lt;&lt;'\\n',--m; cal(pis.second,c[n]); for(pis.second+='A'; pis.second.back()&lt;='Z'; ++pis.second.back()) { ++c[n][pis.second.back()-'A']; for(int i=pis.first=0; i&lt;n; ++i) { ++pis.first; for(int j=0; j&lt;26; ++j) if(c[n][j]&gt;c[i][j]) { --pis.first; break; } } q.push(pis); --c[n][pis.second.back()-'A']; } } }} Headshot12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ for(string s; cin&gt;&gt;s;) { int a=s.size(),b=0,c=0,d=0; for(int i=0; i&lt;a; ++i) if(s[i]=='0') ++b,++c,d+=s[(i+1)%a]=='0'; printf(a*d&gt;b*c?\"SHOOT\\n\":a*d&lt;b*c?\"ROTATE\\n\":\"EQUAL\\n\"); }}","link":"/2018/10/06/2018-10-06-2009-2010 ACM-ICPC Northeastern European Regional Contest (NEERC 09)/"},{"title":"Ural Regional School Programming Contest 2011","text":"GOV Chronicles体验极差的四级阅读理解，大致是在文章里找每个人参加了多少比赛…用一下Ctrl+F。漏了最后面还有两个人各参加了一场比赛还wa了一发。有几个人的信息比较含糊所幸样例里还给了答案。 1234567#include&lt;stdio.h&gt;int n,a[14]= {5,21,12,2,1,4,6,1,4,4,1,0,1,1};int main(){ scanf(\"%d\",&amp;n); printf(\"%d\",a[n]);} Football Goal固定两条棒所成夹角后，显然当树和地面在门内长度相等时面积最大，此时面积可以表示成角度的一个函数，可计算出在135度角时取最大值。 12345678#include&lt;stdio.h&gt;#include&lt;math.h&gt;double a,b;int main(){ scanf(\"%lf%lf\",&amp;a,&amp;b); printf(\"%.9f\",(a*a+b*b)/4+a*b/sqrt(2));} Angry Birds1//待补题 Centipede’s Morning蜈蚣穿鞋子，要求最坏情况下要用多少时间，考虑两种情况：一开始全抽到右脚鞋，这样是2b+40；先抽到39只右脚鞋，然后再给左脚穿上所有的鞋，然后再把所有的剩下的左鞋去试右脚，然后再穿上右鞋，这样是2*a+39。 12345678#include&lt;stdio.h&gt;int a,b;int main(){ scanf(\"%d%d\",&amp;a,&amp;b); a=a*2+39,b=b*2+40; printf(\"%d\",a&gt;b?a:b);} Bicycle Codes1234567#include&lt;stdio.h&gt;int a,b;int main(){ scanf(\"%d%d\",&amp;a,&amp;b); printf(a%2==0||b%2==1?\"yes\":\"no\");} Rubinchik’s Cube看似复杂，实际上只要考虑把红色移到目标位置即可。 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int s[4],ans=1e9;int main(){ for(int i=0,c; i&lt;4; ++i) for(int j=0; j&lt;4; ++j) { scanf(\"%d\",&amp;c); if(c==1) ++s[i&lt;2&amp;&amp;j&lt;2?0: i&lt;2&amp;&amp;j&gt;=2?1: i&gt;=2&amp;&amp;j&gt;=2?2:3]; } for(int i=0; i&lt;4; ++i) ans=min(ans,s[(i+1)%4]+s[(i+2)%4]*2+s[(i+3)%4]); printf(\"%d\",ans);} GOV-internship 2贪心，把0分别换成另一个串中非0且最多的字母或一种指定字母，依次求一遍取最小值。 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100009;typedef long long ll;ll n[2],v[2][N];int main(){ for(int j=0,t; j&lt;2; ++j) { scanf(\"%lld\",&amp;n[j]); for(int i=0; i&lt;n[j]; ++i) scanf(\"%d\",&amp;t),++v[j][t]; } ll tmp=n[0]*n[1]; for(int i=1; i&lt;N; ++i) tmp-=v[0][i]*v[1][i]; ll ans=tmp-v[0][0]**max_element(v[1]+1,v[1]+N)-v[1][0]**max_element(v[0]+1,v[0]+N); for(int i=1; i&lt;N; ++i) ans=min(ans,tmp-v[0][0]*v[1][i]-v[1][0]*v[0][i]-v[0][0]*v[1][0]); printf(\"%lld\",ans);} Psych Up’s Eigenvalues1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int a[16383],siz=0,ans=0;int main(){ for(int i=0,n; i&lt;3; ++i) for(scanf(\"%d\",&amp;n); n--;) scanf(\"%d\",&amp;a[siz++]); sort(a,a+siz); for(int i=2; i&lt;siz; ++i) if(a[i-2]==a[i]&amp;&amp;a[i-1]==a[i]) ++ans; printf(\"%d\",ans);} Long problem statement12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;string s;int h,w,n,r=1,c=0;int main(){ for(cin&gt;&gt;h&gt;&gt;w&gt;&gt;n; n--;) { cin&gt;&gt;s; if(c+s.size()+1&lt;w)c+=s.size()+1; else if(c+s.size()&lt;=w&amp;&amp;w&lt;=c+s.size()+1)c=0,++r; else c=s.size()+1,++r; } if(!c)--r; printf(\"%d\",r/h+(r%h?1:0));} Old Nokia1//待补 Ent’s Birthday在平面上划出一块凸多边形区域使得里面恰好有给定点集的k个。按横纵坐标的字典序排序后选择前k个，用一个五角梯形（不知道怎么形容，看代码，矩形挖掉一个角之后的情况）包住即可。特殊情况是第k个点在上边界，此时退化成四角梯形。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;#define X first#define Y secondusing namespace std;const int INF=1e9;typedef pair&lt;int,int&gt; Coord;int main(){ int n,k; scanf(\"%d%d\",&amp;n,&amp;k); vector&lt;Coord&gt; p(n),ans; for(int i=0,x,y; i&lt;n; ++i) scanf(\"%d%d\",&amp;p[i].X,&amp;p[i].Y); sort(p.begin(),p.end()); ans.push_back(p[k-1]); if(p[k-1].X-1!=-INF)ans.push_back(Coord(p[k-1].X-1,INF)); ans.push_back(Coord(-INF,INF)); ans.push_back(Coord(-INF,-INF)); ans.push_back(Coord(p[k-1].X,-INF)); printf(\"%d\\n\",ans.size()); for(int i=0; i&lt;ans.size(); ++i) printf(\"%d %d\\n\",ans[i].X,ans[i].Y);} Way to the University让人比较头疼的模拟，我的做法是把其中一条车道的车等效到另一个车道上。尽量用整数运算避开浮点运算。 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int n,d,v[16383];int main(){ for(scanf(\"%d\",&amp;n); n--;) scanf(\"%d\",&amp;d),fill(v+d+8,v+d+5+8,1);//8==20/5*2 for(scanf(\"%d\",&amp;n); n--;) scanf(\"%d\",&amp;d),fill(v+d,v+d+5,1); for(int i=0;; ++i) if(*max_element(v+i+8,v+i+8+8)==0) return printf(\"%.6f\",i*0.18),0;//0.18==3600/20000}","link":"/2018/10/01/2018-10-01-Ural Regional School Programming Contest 2011/"},{"title":"Ural Championship 2011","text":"Help in the RNOS12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll cal(char s[],int n){ char t[63]; fill(t,t+n,'0'); t[n-1]='1'; ll ans=0; for(int i=n-1; ~i; --i) if(s[i]!=t[i]) { if(!i)++ans; else t[i-1]='1',ans+=1ll&lt;&lt;i; } return ans;}char a[63],b[63];ll n;int main(){ scanf(\"%lld%s%s\",&amp;n,a,b); while(n&amp;&amp;a[n-1]==b[n-1])--n; cout&lt;&lt;(n&lt;2?n:cal(a,n-1)+cal(b,n-1)+1);} Arirang Show12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N=300009;char s[N]= {0,'a',0};int n,p[N],ps=0,use[127];int main(){ scanf(\"%d\",&amp;n); for(int i=1; i*2&lt;=n; ++i)if(n%i==0)p[ps++]=i; for(int i=2; i&lt;=n; ++i) { fill(use+'a',use+'z'+1,0); for(int j=0,k; j&lt;ps; ++j) { if(k=i+p[j],k&gt;n)k-=n; use[s[k]]=1; if(k=i-p[j],k&lt;1)k+=n; use[s[k]]=1; } for(s[i]='a'; s[i]&lt;='z'; ++s[i]) if(!use[s[i]])break; if(s[i]&gt;'z')return printf(\"Impossible\"),0; } printf(\"%s\",s+1);} Babel Fish12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//待修改#include&lt;bits/stdc++.h&gt;using namespace std;const double EPS=1e-9;struct Coord3{ double X,Y,Z; Coord3(double X=0,double Y=0,double Z=0):X(X),Y(Y),Z(Z) {}};int sgn(double d){ return (d&gt;EPS)-(d&lt;-EPS);}bool operator!=(const Coord3 &amp;a,const Coord3 &amp;b)//不等运算符，涉及到浮点数比较要重写{ return sgn(a.X-b.X)||sgn(a.Y-b.Y)||sgn(a.Z-b.Z);}bool operator==(const Coord3 &amp;a,const Coord3 &amp;b){ return !(a!=b);}Coord3&amp; operator+=(Coord3 &amp;a,const Coord3 &amp;b){ return a.X+=b.X,a.Y+=b.Y,a.Z+=b.Z,a;}Coord3 operator+(Coord3 a,const Coord3 &amp;b){ return a+=b;}Coord3&amp; operator-=(Coord3 &amp;a,const Coord3 &amp;b){ return a.X-=b.X,a.Y-=b.Y,a.Z-=b.Z,a;}Coord3 operator-(Coord3 a,const Coord3 &amp;b){ return a-=b;}int t,l,a,b,c,d;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d%d%d%d\",&amp;l,&amp;a,&amp;b,&amp;c,&amp;d); switch(sgn(a)+sgn(b)+sgn(c)+sgn(d)) { case 4: { Coord3 A(0,0,a),B(0,1,b),C(1,1,c),D(1,0,d); if(B-A+D-A==C-A)printf(\"%.7f\\n\",l*l*(a+c)/2.0); else printf(\"error\\n\"); } break; case 3: { int s[4]= {a,b,c,d},p=min_element(s,s+4)-s; a=s[(p+1)%4],b=s[(p+2)%4],c=s[(p+3)%4],d=b-a-c; if(b&lt;a+c) { printf(\"error\\n\"); break; } printf(\"%.7f\\n\",l*l*((a+c)/2.0-d*d*d/6.0/(a+d)/(c+d))); break; } case 2: printf((a&amp;&amp;c)||(b&amp;&amp;d)?\"error\\n\":\"ambiguous\\n\"); break; case 1: printf(\"ambiguous\\n\"); break; case 0: printf(\"0\\n\"); }; }} Isenbaev’s Number1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;const int N=511,INF=1e9;struct Id:map&lt;string,int&gt;{ int operator()(const string &amp;s) { if(!count(s))insert(make_pair(s,size())); return at(s); }} id;string s[3];int n,f[N][N];int main(){ for(int i=0; i&lt;N; ++i)fill(f[i],f[i]+N,INF),f[i][i]=0; cin&gt;&gt;n; for(int i=0; i&lt;n; ++i) { cin&gt;&gt;s[0]&gt;&gt;s[1]&gt;&gt;s[2]; int p[3]= {id(s[0]),id(s[1]),id(s[2])}; for(int j=0; j&lt;3; ++j) for(int k=0; k&lt;j; ++k) f[p[j]][p[k]]=f[p[k]][p[j]]=min(f[p[j]][p[k]],1); } for(int k=0; k&lt;N; ++k) for(int i=0; i&lt;N; ++i) for(int j=0; j&lt;N; ++j) f[i][j]=min(f[i][j],f[i][k]+f[k][j]); int flag=!id.count(\"Isenbaev\"),p=id(\"Isenbaev\"); for(Id::iterator it=id.begin(); it!=id.end(); ++it) if(!(flag&amp;&amp;it-&gt;second==p)) { cout&lt;&lt;it-&gt;first&lt;&lt;' '; if(f[p][it-&gt;second]==INF)cout&lt;&lt;\"undefined\\n\"; else cout&lt;&lt;f[p][it-&gt;second]&lt;&lt;'\\n'; }} Samurai’s Stroke1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int l,n,a[100009];int main(){ scanf(\"%d%d\",&amp;l,&amp;n),a[n+1]=l; for(int i=1; i&lt;=n; ++i)scanf(\"%d\",&amp;a[i]); if (n&lt;=3) return printf(\"%d\",l),0; int ans=a[2]+l-a[n-1];// printf(\"%d\\n\",ans); for (int i=3;i&lt;=n-1;i++) { int x=a[i-1],y=a[i]; int q=max(2*a[1],2*y-l),p=min(2*x,2*a[n]-l); if (q&lt;x) q=x; if (p&gt;y) p=y; if ((q&gt;y)||(p&lt;x)) {ans+=y-x; continue;} if (p&gt;q) ans+=(y-x-(p-q)); else ans+=y-x;// printf(\"%d %d\\n\",i,ans); } printf(\"%d\",ans);}","link":"/2018/10/05/2018-10-05-Ural Championship 2011/"},{"title":"2012-2013 ACM-ICPC, Central Europe Regional Contest (CERC 12)","text":"Kingdoms破产是收支不平衡时才有概率发生，并且一个国家破产之后有概率导致破产（而不是必定导致连锁破产）。搜索的时候要记忆化。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,a[31][31],cnt[1&lt;&lt;20],ans;void dfs(int s){ if(cnt[s])return; for(int i=0; i&lt;n; ++i) if(!(s&gt;&gt;i&amp;1))++cnt[s]; for(int i=0,sum; i&lt;n; ++i) if(!(s&gt;&gt;i&amp;1)) { if(cnt[s]==1) { ans|=1&lt;&lt;i; return; } for(int j=sum=0; j&lt;n; ++j) if(!(s&gt;&gt;j&amp;1)) sum+=a[j][i]; if(sum&lt;0)dfs(s|1&lt;&lt;i); }}int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;n); for(int i=0; i&lt;n; ++i) for(int j=0; j&lt;n; ++j) scanf(\"%d\",&amp;a[i][j]); fill(cnt,cnt+(1&lt;&lt;20),ans=0); dfs(0); if(!ans)printf(\"0\"); for(int i=0; i&lt;n; ++i) if(ans&gt;&gt;i&amp;1)printf(\"%d \",i+1); printf(\"\\n\"); }} Chemist’s vows1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;bool a[200],s[200][200];char t[50010];bool ok[50010];int n;void pre(){ a['h']=a['b']=a['c']=a['n']=a['o']=a['f']=a['p']=a['s']=a['k']=a['v']=a['y']=a['i']=a['w']=a['u']=true; s['h']['e']=s['l']['i']=s['b']['e']=s['n']['e']=s['n']['a']=s['m']['g']=s['a']['l']=s['s']['i']=s['c']['l']=s['a']['r']=true; s['c']['a']=s['s']['c']=s['t']['i']=s['c']['r']=s['m']['n']=s['f']['e']=s['c']['o']=s['n']['i']=s['c']['u']=s['z']['n']=s['g']['a']=s['g']['e']=s['a']['s']=s['s']['e']=s['b']['r']=s['k']['r']=true; s['r']['b']=s['s']['r']=s['z']['r']=s['n']['b']=s['m']['o']=s['t']['c']=s['r']['u']=s['r']['h']=s['p']['d']=s['a']['g']=s['c']['d']=s['i']['n']=s['s']['n']=s['s']['b']=s['t']['e']=s['x']['e']=true; s['c']['s']=s['b']['a']=s['h']['f']=s['t']['a']=s['r']['e']=s['o']['s']=s['i']['r']=s['p']['t']=s['a']['u']=s['h']['g']=s['t']['l']=s['p']['b']=s['b']['i']=s['p']['o']=s['a']['t']=s['r']['n']=true; s['f']['r']=s['r']['a']=s['r']['f']=s['d']['b']=s['s']['g']=s['b']['h']=s['h']['s']=s['m']['t']=s['d']['s']=s['r']['g']=s['c']['n']=s['f']['l']=s['l']['v']=true; s['l']['a']=s['c']['e']=s['p']['r']=s['n']['d']=s['p']['m']=s['s']['m']=s['e']['u']=s['g']['d']=s['t']['b']=s['d']['y']=s['h']['o']=s['e']['r']=s['t']['m']=s['y']['b']=s['l']['u']=true; s['a']['c']=s['t']['h']=s['p']['a']=s['n']['p']=s['p']['u']=s['a']['m']=s['c']['m']=s['b']['k']=s['c']['f']=s['e']['s']=s['f']['m']=s['m']['d']=s['n']['o']=s['l']['r']=true;}int main(){ pre(); scanf(\"%d\",&amp;n); while (n--) { scanf(\"%s\",t); memset(ok,0,sizeof(ok)); ok[0]=true; int i; for (i=0;t[i];++i) { if (!ok[i]) continue; if (a[t[i]]) ok[i+1]=true; if (s[t[i]][t[i+1]]) ok[i+2]=true; } if (ok[i]) puts(\"YES\"); else puts(\"NO\"); }} Non-boring sequences卡了很久，暴力划分子区间的时候要从左右一起找，单方向找会被卡。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int N=2e5+9;int t,n,pre[N],nxt[N];int dfs(int l,int r){ for(int L=l,R=r; L&lt;=R; ++L,--R) { if(pre[L]&lt;l&amp;&amp;nxt[L]&gt;r) return dfs(L+1,r)&amp;&amp;dfs(l,L-1); if(pre[R]&lt;l&amp;&amp;nxt[R]&gt;r) return dfs(l,R-1)&amp;&amp;dfs(R+1,r); } return l&gt;=r;}int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d\",&amp;n); unordered_map&lt;int,int&gt; mp; fill(pre,pre+n,-1); fill(nxt,nxt+n,n); for(int i=0,a; i&lt;n; ++i) { scanf(\"%d\",&amp;a); if(mp.count(a)) { int &amp;lst=mp[a]; nxt[lst]=i; pre[i]=lst; lst=i; } else mp[a]=i; } if(dfs(0,n-1))printf(\"non-\"); printf(\"boring\\n\"); }} Darts12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int r[11]={200,180,160,140,120,100,80,60,40,20,0};int sc(int x,int y){ int t=x*x+y*y; for (int i=0;i&lt;=10;++i) { if (t&gt;r[i]*r[i]) return i; } return 10;}int main(){ int T; scanf(\"%d\",&amp;T); while (T--) { int n,ans=0; scanf(\"%d\",&amp;n); while (n--) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); ans+=sc(x,y); } printf(\"%d\\n\",ans); }} Conservation拓扑排序的时候把普通队列换成双端队列即可，每次入队时按照两种点的类型分别插入队尾/队首，出队是按照上次点的类型选择从队尾/队首出。分别枚举两类点作为起点，取最小值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;struct Graph{ struct Vertex { vector&lt;int&gt; a; int pos; }; struct Edge { int from,to; }; vector&lt;Vertex&gt; v; vector&lt;Edge&gt; e; Graph(int n):v(n) {} void add(const Edge &amp;ed) { v[ed.from].a.push_back(e.size()); e.push_back(ed); } int topo(int first) { vector&lt;int&gt; deg(v.size(),0); for(int i=0; i&lt;e.size(); ++i)++deg[e[i].to]; deque&lt;int&gt; q; for(int i=0; i&lt;deg.size(); ++i) if(!deg[i]) v[i].pos==first?q.push_front(i):q.push_back(i); int ans=0,pre=q.back(),u; while(!q.empty()) { if(v[q.back()].pos==v[pre].pos) u=q.back(),q.pop_back(); else u=q.front(),q.pop_front(); if(v[u].pos!=v[pre].pos)++ans; for(int i=0,k,to; i&lt;v[u].a.size(); ++i) if(k=v[u].a[i],to=e[k].to,!--deg[to]) v[to].pos==first?q.push_front(to):q.push_back(to); pre=u; } return ans; }};int main(){ int t,n,m; for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d\",&amp;n,&amp;m); Graph g(n); for(int i=0; i&lt;n; ++i)scanf(\"%d\",&amp;g.v[i].pos); for(int i=0,u,v; i&lt;m; ++i) scanf(\"%d%d\",&amp;u,&amp;v),g.add({u-1,v-1}); printf(\"%d\\n\",min(g.topo(1),g.topo(2))); }}","link":"/2018/10/16/2018-10-16-2012-2013 ACM-ICPC, Central Europe Regional Contest (CERC 12)/"},{"title":"Ural Championship 2012","text":"Brainwashing Device123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int N=511,INF=1e9;int n,K,f[N][N],a[N][N],c[N][N],s[N][N],g[N][N];int main(){ scanf(\"%d%d\",&amp;n,&amp;K); for(int i=1,t; i&lt;=n; ++i) for(int j=i+1; j&lt;=n; ++j) { scanf(\"%d\",&amp;a[i][j]); } for (int i=1; i&lt;=n; i++) for (int j=i+1; j&lt;=n; j++) for (int k=1; k&lt;=i; k++) c[i][j]+=a[k][j]; for (int i=1;i&lt;=n;i++) for (int j=i+1; j&lt;=n;j++) for (int k=i+1;k&lt;=j;k++) s[i][j]+=c[i][k]; for (int i=1;i&lt;=n;i++) f[i][1]=s[i][n]; for (int i=2; i&lt;=K;i++) for (int j=1;j&lt;=n;j++) for (int k=j+1;k&lt;=n;k++) { if (s[j][k]+f[k][i-1]&gt;f[j][i]) f[j][i]=s[j][k]+f[k][i-1],g[j][i]=k; } int ans=0,ansnum; for (int i=1;i&lt;=n;i++) if (f[i][K]&gt;ans) ans=f[i][K],ansnum=i; printf(\"%d\\n\",ans); printf(\"%d \",ansnum); while (K&gt;1) { printf(\"%d \",g[ansnum][K]); ansnum=g[ansnum][K]; K--; }} Space Elevators1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn=100000+10;int n,s,cnt,num,l,r;int v[maxn],ans[maxn];queue &lt;int&gt; q;int main(){ scanf(\"%d%d\",&amp;n,&amp;s); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;v[i]); sort(v+1,v+n+1); cnt=num=0; l=1; r=n; while (l&lt;=r) { if (q.empty()) { q.push(v[l++]); // printf(\"%d %d\\n\",l,r); continue; } if (q.front()+v[r]&gt;s) { ans[++cnt]=q.front(); q.pop(); ans[++cnt]=v[r]; r--; num+=2; } else { ans[++cnt]=q.front(); q.pop(); ans[++cnt]=v[l++]; num++; } } if (!q.empty()) ans[++cnt]=q.front(),num++; printf(\"%d\\n\",num); for (int i=1;i&lt;=cnt;i++) printf(\"%d \",ans[i]); return 0;} Neo-Venice123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int n,t,s;int a[200];int main(){ scanf(\"%d%d%d\",&amp;n,&amp;t,&amp;s); for (int i=1;i&lt;=n;++i) scanf(\"%d\",&amp;a[i]); for (int i=1;i&lt;=n;++i) { int del=a[i]-s; double ans=double(t-del); ans=ans/2+del+s; printf(\"%.6lf\\n\",ans); } return 0;} Unidentified Ships1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#define inv(a,b) pow(a,(b)-2,b)#define mul(a,b,c) (1LL*(a)*(b)%(c))using namespace std;typedef int ll;const int N=8191,M=1e9+7;ll pow(ll a,ll b,ll m){ ll r=1; for(a%=m; b; b&gt;&gt;=1,a=mul(a,a,m)) if(b&amp;1)r=mul(r,a,m); return r;}struct Factorial{ vector&lt;ll&gt; fac,ifac; ll M; Factorial(int N,ll M):fac(N,1),ifac(N,1),M(M) { for(int i=1; i&lt;N; ++i)fac[i]=mul(fac[i-1],i,M); ifac[N-1]=inv(fac[N-1],M); for(int i=N-1; i; --i)ifac[i-1]=mul(ifac[i],i,M); } ll c(int n,int m) { return mul(mul(fac[n],ifac[m],M),ifac[n-m],M); }} f(N,M);int n,t,c[N],k,x,s[3];int main(){ scanf(\"%d%d\",&amp;n,&amp;t); for(int i=0; i&lt;n; ++i)scanf(\"%d\",&amp;c[i]); scanf(\"%d%d\",&amp;k,&amp;x); for(int i=0; i&lt;n; ++i)++s[c[i]&gt;c[k-1]?2:c[i]==c[k-1]]; for(int i=min(s[k=0],x-1); ~i; --i) for(int j=min(s[2],t-x); ~j; --j) if(1&lt;=t-i-j&amp;&amp;t-i-j&lt;=s[1]) k=(k+mul(mul(f.c(s[0],i),f.c(s[2],j),M),f.c(s[1]-1,t-i-j-1),M))%M; printf(\"%d\\n\",k);} The Lessons of the Past12345678910111213141516171819202122232425262728using namespace std;const int N=10009;int k,a[15],c[N*2];int check(int t){ for(int i=0; i&lt;k; ++i) t=abs(t-a[i]); return t&lt;=1;}int main(){ scanf(\"%d\",&amp;k); for(int i=0; i&lt;k; ++i)scanf(\"%d\",&amp;a[i]); vector&lt;pair&lt;int,int&gt; &gt; ans; for(int i=-N,l=N; i&lt;N; ++i) if(check(i)) { if(l==N)l=i; if(!check(i+1)) { ans.push_back(make_pair(l,i)); l=N; } } printf(\"%d\\n\",ans.size()); for(int i=0; i&lt;ans.size(); ++i) printf(\"%d %d\\n\",ans[i].first,ans[i].second);} Travel in Time12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define F first#define S secondusing namespace std;typedef int ll;const int N=1e5+9,NPOS=-1;pair&lt;pair&lt;int,int&gt;,pair&lt;int,int&gt; &gt; P[N];vector&lt;int&gt; V[N];int q[N],cur[N],p[N],n,m,s,t,st,tt;bool cmp(int i,int j){ return P[i]&lt;P[j];}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=0; i&lt;m; ++i) scanf(\"%d%d%d%d\",&amp;P[i].S.F,&amp;P[i].S.S,&amp;P[i].F.F,&amp;P[i].F.S); for(int i=m; i&lt;m+2; ++i)scanf(\"%d\",&amp;P[i].S.F),P[i].S.S=P[i].S.F; for(int i=m; i&lt;m+2; ++i)scanf(\"%d\",&amp;P[i].F.F),P[i].F.S=P[i].F.F; for(int i=0; i&lt;m+2; ++i) V[P[i].S.F].push_back(i); for(int i=1; i&lt;=n; ++i)sort(V[i].begin(),V[i].end(),cmp),cur[i]=V[i].size()-1; fill(p,p+m+2,NPOS); q[0]=m; for(int ql=0,qr=1; ql&lt;qr; ++ql) for(int &amp;u=q[ql],&amp;j=cur[P[u].S.S],to; ~j; --j) if(to=V[P[u].S.S][j],to!=u) { if(P[u].F.S&gt;P[to].F.F)break; if(p[to]==NPOS)p[to]=u,q[qr++]=to; } if(p[m+1]==NPOS)return printf(\"Impossible\"),0; vector&lt;int&gt; ans; for(int u=m+1; u!=m; u=p[u]) ans.push_back(u); printf(\"%d\\n\",ans.size()-1); for(int i=ans.size()-1; i; --i) printf(\"%d \",ans[i]+1);} The Lost Civilization1//没人做的题，待补 Coffee and Buns1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll a,at,n,ans;int cnt;ll f[100];void dfs1(int cur,int num,ll tot){ if (tot&gt;n) return ; if (cur&gt;cnt) { if (num==0) return ; ans+=(num&amp;1?1:-1)*(n/tot); return ; } dfs1(cur+1,num,tot); dfs1(cur+1,num+1,tot*f[cur]);}void dfs2(int cur,int num,ll tot){ if (cur&gt;cnt) { if (num==0) return ; ans+=(num&amp;1?1:-1)*(((n/tot)+1)/2); // printf(\"%d %d\\n\",tot,ans); return ; } dfs2(cur+1,num,tot); dfs2(cur+1,num+1,tot*f[cur]);}int main(){ scanf(\"%lld%lld\",&amp;a,&amp;n); at=a; for (int i=2;(ll)i*i&lt;=a;i++) if (at%i==0) { f[++cnt]=i; while (at%i==0) at/=i; } if (at&gt;1) f[++cnt]=at; if (a&amp;1) { ans+=(n+1)/2; n/=2; dfs1(1,0,1); } else { ans+=n/2; dfs2(2,0,1); } printf(\"%lld\",ans); return 0;} Brute-force Search1//待补 Space Recon12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//全场193提交无人通过，待补#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;double X0,X1,X2,Y0,Y1,Y2,z0,z1,z2,vx,vy,vz,r;double A,B,C,D;const double eps=1e-6;void getN(){ double dx=X1-X2,dy=Y1-Y2,dz=z1-z2; A=dy*vz-dz*vy; B=dz*vx-dx*vz; C=dx*vy-dy*vx; D=-X1*A-Y1*B-z1*C;}bool dir(){ double Dx=X1-X0,Dy=Y1-Y0,Dz=z1-z0; if (Dx*vx+Dy*vy+Dz*vz&lt;eps) return true; Dx=X2-X0,Dy=Y2-Y0,Dz=z2-z0; if (Dx*vx+Dy*vy+Dz*vz&lt;eps) return true; return false;}double DD(double x,double y,double z){ double dx=X0-x,dy=Y0-y,dz=z0-z; double L1=(dx*vx+dy*vy+dz*vz)/sqrt(vx*vx+vy*vy+vz*vz); double L2=(dx*dx+dy*dy+dz*dz)-L1*L1; if (L2-r*r&gt;-eps) return -1; double L3=sqrt(r*r-L2); return L1-L3;}int main(){// freopen(\"J.txt\",\"r\",stdin); scanf(\"%lf%lf%lf%lf\",&amp;X0,&amp;Y0,&amp;z0,&amp;r); scanf(\"%lf%lf%lf\",&amp;X1,&amp;Y1,&amp;z1); scanf(\"%lf%lf%lf\",&amp;X2,&amp;Y2,&amp;z2); scanf(\"%lf%lf%lf\",&amp;vx,&amp;vy,&amp;vz); getN(); double dis=(A*X0+B*Y0+C*z0+D)/sqrt(A*A+B*B+C*C); if (dis-r&gt;eps) {printf(\"False alarm\");return 0;} if (!dir()) {printf(\"False alarm\");return 0;} double d1=DD(X1,Y1,z1); double d2=DD(X2,Y2,z2); double d3; if (d1&lt;-eps &amp;&amp; d2&lt;-eps) {printf(\"Warning\");return 0;} if (d1&lt;-eps || d2&lt;-eps) d3=max(d1,d2); else d3=min(d1,d2); double T=d3/sqrt(vx*vx+vy*vy+vz*vz); X1+=vx*T;Y1+=vy*T;z1+=vz*T; X2+=vx*T;Y2+=vy*T;z2+=vz*T; double Px=X1-X2,Py=Y1-Y2,Pz=z1-z2; double Qx=X0-X2,Qy=Y0-Y2,Qz=z0-z2; double Rx=X0-X1,Ry=Y0-Y1,Rz=z0-z1; if (Px*Qx+Py*Qy+Pz*Qz&gt;-eps || Rx*Px+Ry*Py+Rz*Pz&lt;eps) {printf(\"Crash\");return 0;} double k=((X1-X2)*(X0-X2)+(Y1-Y2)*(Y0-Y2)+(z1-z2)*(z0-z2))/((X1-X2)*(X1-X2)+(Y1-Y2)*(Y1-Y2)+(z1-z2)*(z1-z2)); double d4=sqrt(((X1-X2)*k+X2-X0)*((X1-X2)*k+X2-X0)+((Y1-Y2)*k+Y2-Y0)*((Y1-Y2)*k+Y2-Y0)+((z1-z2)*k+z2-z0)*((z1-z2)*k+z2-z0)); if (d4-r&lt;eps) {printf(\"Warning\");return 0;} else {printf(\"Crash\");return 0;} }","link":"/2018/10/06/2018-10-06-Ural Championship 2012/"},{"title":"函数程序设计实验一：分式","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374--import Test.QuickCheckmodule MyFraction whereFraction=(Integer,Integer)--分式化简ratreduction::Fraction-&gt;Fractionratreduction(x,y)=(div x g,div y g)where g=gcd x y--加法ratplus::Fraction-&gt;Fraction-&gt;Fractionratplus(a,b)(c,d)=ratreduction(a*d+b*c,b*d)--减法，调用加法实现ratminus::Fraction-&gt;Fraction-&gt;Fractionratminus(a,b)(c,d)=ratplus(a,b)(-c,d)--乘法rattimes::Fraction-&gt;Fraction-&gt;Fractionrattimes(a,b)(c,d)=ratreduction(a*c,b*d)--除法，调用乘法实现ratdiv::Fraction-&gt;Fraction-&gt;Fractionratdiv(a,b)(c,d)=rattimes(a,b)(d,c)--取整ratfloor::Fraction-&gt;Integerratfloor(a,b)=div a b--转成浮点ratfloat::Fraction-&gt;Floatratfloat(a,b)=fromInteger a/fromInteger b--判断相等rateq::Fraction-&gt;Fraction-&gt;Boolrateq(a,b)(c,d)=a*d==b*c--重载运算符(&lt;+&gt;)::Fraction-&gt;Fraction-&gt;Fraction(a,b)&lt;+&gt;(c,d)=ratplus(a,b)(c,d) (&lt;-&gt;)::Fraction-&gt;Fraction-&gt;Fraction(a,b)&lt;-&gt;(c,d)=ratminus(a,b)(c,d)(&lt;-*-&gt;)::Fraction-&gt;Fraction-&gt;Fraction(a,b)&lt;-*-&gt;(c,d)=rattimes(a,b)(c,d)(&lt;/&gt;)::Fraction-&gt;Fraction-&gt;Fraction(a,b)&lt;/&gt;(c,d)=ratdiv(a,b)(c,d)(&lt;==&gt;)::Fraction-&gt;Fraction-&gt;Bool(a,b)&lt;==&gt;(c,d)=rateq(a,b)(c,d)--确定运算优先级infixl 6 &lt;-*-&gt;,&lt;/&gt;infixl 5 &lt;+&gt;,&lt;-&gt;infixl 4 &lt;==&gt;{---检查任意分数+(0,1)之后仍然等于其本身prop_ratplus_unit :: Fraction -&gt; Propertyprop_ratplus_unit (a,b) = b &gt; 0 ==&gt;(a, b) &lt;+&gt; (0,1) &lt;==&gt; (a, b)--检查任意分数加上相反数之后为0prop_ratplus_inv :: Fraction -&gt; Propertyprop_ratplus_inv (a,b) = b &gt; 0 ==&gt;(a, b) &lt;+&gt; (-a,b) &lt;==&gt; (0, 1)--检查任意非零分数乘上倒数之后为1prop_rattimes_inv :: Fraction -&gt; Propertyprop_rattimes_inv (a,b) = a/=0&amp;&amp;b &gt; 0 ==&gt;(a, b) &lt;-*-&gt; (b,a) &lt;==&gt; (1, 1)-- 检查乘法分配律prop_rattimes_plus_distr :: Fraction -&gt; Fraction -&gt; Fraction -&gt;Propertyprop_rattimes_plus_distr (a,b) (c,d) (e,f) = b &gt; 0 &amp;&amp; d &gt; 0 &amp;&amp; f &gt; 0 ==&gt; (a,b) &lt;-*-&gt; ((c,d) &lt;+&gt; (e,f)) &lt;==&gt; ((a,b) &lt;-*-&gt; (c,d)) &lt;+&gt; ((a,b) &lt;-*-&gt; (e,f))-}","link":"/2018/10/16/2018-10-16-分式/"},{"title":"函数程序设计实验二：递归练习","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172module HW where{-1. 定义求两个非负整数最大公因子的函数：mygcd ::Integer -&gt;Integer -&gt;Integer-}mygcd ::Integer -&gt;Integer -&gt;Integermygcd a 0=amygcd a b=mygcd b (mod a b){-2. 定义阶乘函数fac :: Integer -&gt; Integer -}fac :: Integer -&gt; Integer fac 0=1fac n=n* fac (n-1){-3. 定义下列函数：sumFacs :: Integer -&gt; Integer使得sumFacs n = fac 0 + fac 1 + ... + fac n-}sumFacs :: Integer -&gt; IntegersumFacs 0=fac 0sumFacs n=fac n+sumFacs (n-1){-4. 上述函数sumFacs可以对输入n返回和fac 0 + fac 1 + ... + fac n。任意给定一个函数f, 一个非负整数n, 能否求出和f 0 + f 1 + ... + f n呢？答案是肯定的。请您定义这样的函数：sumFun :: (Integer -&gt; Integer) -&gt; Integer -&gt; Integer使得sumFun f n = f 0 + f 1 + ... + f n-}sumFun :: (Integer -&gt; Integer) -&gt; Integer -&gt; IntegersumFun f 0=f 0sumFun f n=f n+sumFun f (n-1){-5. 定义函数maxFun :: (Integer -&gt; Integer) -&gt; Integer -&gt; Integer使得maxFun f n 等于f 0 ， f 1 ， ... ， f n中的最大值。-}maxFun :: (Integer -&gt; Integer) -&gt; Integer -&gt; IntegermaxFun f 0=f 0maxFun f n=max (f n) (maxFun f n-1){-6. 定义函数：fib :: Integer -&gt;Integer使得fib n 返回第n个斐波那契数，如fib 0 =0, fib 1 = 1, fib 2 = 1, fib 3 = 2, fib 4 = 5 ,...。-}fib :: Integer -&gt;Integerfib n=if(n&lt;2)then n else fib (n-1)+fib(n-2){-7. 利用我们可以利用下列迭代公式求2的近似平方根： xn+1 = (xn + 2/xn)/2方法是从任意一个初值x0开始，如x0 = 1, x1 = (x0 +2/x0)/2 =1.5, x2 = (x1 + 2/x1)/2= 1.41667, ...请定义一个函数sqrt2 :: Float -&gt;Integer -&gt;Float使得sqrt2 x0 n 等于第n个逼近值xn, 例如，sqrt2 1.0 0 = 1.0, sqrt2 1.0 1 = 1.5, sqrt2 1.0 2 = 1.41667, ...。-}sqrt2 :: Float -&gt; Integer -&gt; Floatsqrt2 x0 0=x0sqrt2 x0 n=(x + 2/x)/2 where x=sqrt2 x0 (n-1){-8. 完成解求一元二次方程根的函数。-}roots::(Float,Float,Float)-&gt;(Float,Float)roots (a,b,c)=((-b-sqrtDelta)/2/a,(-b+sqrtDelta)/2/a) where sqrtDelta=sqrt (b*b-4*a*c)","link":"/2018/10/16/2018-10-16-递归练习/"},{"title":"序列终结者","text":"题目链接说是终结者其实是这题的真子集… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct FhqTreap{ struct Node { int ch[2],siz,rev; ll key,val,max,add; void REV() { rev^=1,swap(ch[0],ch[1]); } void ADD(ll v) { val+=v,max+=v,add+=v; } }; vector&lt;Node&gt; v; int root; FhqTreap():v(1),root(0) {} void push_down(int k) { if(!k)return; for(int i=0,*ch=v[k].ch; i&lt;2; ++i) if(ch[i]) { v[ch[i]].ADD(v[k].add); if(v[k].rev)v[ch[i]].REV(); } v[k].add=v[k].rev=0; } void push_up(int k) { if(!k)return; v[k].siz=1,v[k].max=v[k].val; for(int i=0,*ch=v[k].ch; i&lt;2; ++i) if(ch[i]) v[k].siz+=v[ch[i]].siz,v[k].max=max(v[k].max,v[ch[i]].max); } int merge(int a,int b) { if(!a||!b)return a+b; if(v[a].key&lt;v[b].key) return push_down(a),v[a].ch[1]=merge(v[a].ch[1],b),push_up(a),a; return push_down(b),v[b].ch[0]=merge(a,v[b].ch[0]),push_up(b),b; } void split(int a,int s,int &amp;l,int &amp;r) { if(!s)l=0,r=a; else if(v[v[a].ch[0]].siz&lt;s) push_down(a),split(v[a].ch[1],s-v[v[a].ch[0]].siz-1,v[a].ch[1],r),push_up(l=a); else push_down(a),split(v[a].ch[0],s,l,v[a].ch[0]),push_up(r=a); } void push_back(ll d) { v.push_back(Node { {0,0},1,0,rand(),d,d,d}); root=merge(root,v.size()-1); } void add(int l,int r,ll d) { int a,b,c; split(root,r,b,c),split(b,l-1,a,b),v[b].ADD(d),root=merge(merge(a,b),c); } Node ask(int l,int r) { int a,b,c; split(root,r,b,c),split(b,l-1,a,b); Node ret=v[b]; return root=merge(merge(a,b),c),ret; } void reverse(int l,int r) { int a,b,c; split(root,r,b,c),split(b,l-1,a,b),v[b].REV(),root=merge(merge(a,b),c); }};int main(){ int n,k,l,r; FhqTreap t; for(scanf(\"%d\",&amp;n); n--;)t.push_back(0); for(scanf(\"%d\",&amp;n); n--;) { scanf(\"%d%d%d\",&amp;k,&amp;l,&amp;r); if(k==1)scanf(\"%d\",&amp;k),t.add(l,r,k); else if(k==2)t.reverse(l,r); else printf(\"%d\\n\",t.ask(l,r).max); }}","link":"/2018/10/18/2018-10-18-HYSBZ-1251/"},{"title":"Tyvj 1729 文艺平衡树","text":"题目链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct FhqTreap{ struct Node { int ch[2],siz,rev; ll key,val; void REV() { rev^=1,swap(ch[0],ch[1]); } }; vector&lt;Node&gt; v; int root; FhqTreap():v(1),root(0) {} void push_down(int k) { if(!k)return; for(int i=0,*ch=v[k].ch; i&lt;2; ++i) if(ch[i]&amp;&amp;v[k].rev)v[ch[i]].REV(); v[k].rev=0; } void push_up(int k) { if(!k)return; v[k].siz=1; for(int i=0,*ch=v[k].ch; i&lt;2; ++i) if(ch[i]) v[k].siz+=v[ch[i]].siz; } int merge(int a,int b) { if(!a||!b)return a+b; if(v[a].key&lt;v[b].key) return push_down(a),v[a].ch[1]=merge(v[a].ch[1],b),push_up(a),a; return push_down(b),v[b].ch[0]=merge(a,v[b].ch[0]),push_up(b),b; } void split(int a,int s,int &amp;l,int &amp;r) { if(!s)l=0,r=a; else if(v[v[a].ch[0]].siz&lt;s) push_down(a),split(v[a].ch[1],s-v[v[a].ch[0]].siz-1,v[a].ch[1],r),push_up(l=a); else push_down(a),split(v[a].ch[0],s,l,v[a].ch[0]),push_up(r=a); } void push_back(ll d) { v.push_back(Node { {0,0},1,0,rand(),d}); root=merge(root,v.size()-1); } void reverse(int l,int r) { int a,b,c; split(root,r,b,c),split(b,l-1,a,b),v[b].REV(),root=merge(merge(a,b),c); } void print(int u) { if(!u)return; push_down(u); print(v[u].ch[0]); printf(\"%d \",v[u].val); print(v[u].ch[1]); }};int main(){ int n,m; FhqTreap t; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1; i&lt;=n; ++i)t.push_back(i); for(int i=1,l,r; i&lt;=m; ++i)scanf(\"%d%d\",&amp;l,&amp;r),t.reverse(l,r); t.print(t.root);}","link":"/2018/10/18/2018-10-18-HYSBZ-3223/"},{"title":"Ural Championship 2010","text":"The House of Doctor Dee12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define X first#define Y secondusing namespace std;typedef long long ll;typedef pair&lt;ll,ll&gt; Coord;pair&lt;Coord,Coord&gt; v[2];int main(){ for(int i=0; i&lt;2; ++i) { scanf(\"%lld%lld%lld%lld\",&amp;v[i].X.X,&amp;v[i].X.Y,&amp;v[i].Y.X,&amp;v[i].Y.Y); if(v[i].X&gt;v[i].Y)swap(v[i].X,v[i].Y); } if(v[0]&gt;v[1])swap(v[0],v[1]); if(v[0].X.Y&gt;v[0].Y.Y) for(int i=0; i&lt;2; ++i) { v[i].X.Y*=-1,v[i].Y.Y*=-1; if(v[i].X&gt;v[i].Y)swap(v[i].X,v[i].Y); } if(v[1].X.Y&lt;v[1].Y.Y) { if(v[1].X.X&gt;v[0].Y.X||v[1].X.Y&gt;v[0].Y.Y||v[1].Y.Y&lt;v[0].X.Y)return printf(\"0\"),0; v[0].X.X=max(v[0].X.X,v[1].X.X); v[0].X.Y=max(v[0].X.Y,v[1].X.Y); v[0].Y.X=min(v[0].Y.X,v[1].Y.X); v[0].Y.Y=min(v[0].Y.Y,v[1].Y.Y); return printf(\"%lld\",v[0].Y.X-v[0].X.X+v[0].Y.Y-v[0].X.Y),0; } else { if(v[1].X.X&gt;v[0].Y.X||v[1].X.Y&lt;v[0].X.Y||v[1].Y.Y&gt;v[0].Y.Y)return printf(\"0\"),0; v[0].X.X=max(v[0].X.X,v[1].X.X); v[0].X.Y=max(v[0].X.Y,v[1].Y.Y); v[0].Y.X=min(v[0].Y.X,v[1].Y.X); v[0].Y.Y=min(v[0].Y.Y,v[1].X.Y); return printf(\"%lld\",max(v[0].Y.X-v[0].X.X,v[0].Y.Y-v[0].X.Y)),0; }} Circular Strings12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define X real()#define Y imag()using namespace std;typedef double lf;typedef complex&lt;lf&gt; Coord;lf x,y,z,PI=acos(-1),EPS=1e-11;Coord p[127];int n;int sgn(lf d){ return (d&gt;EPS)-(d&lt;-EPS);}int main(){ scanf(\"%d\",&amp;n); for(int i=0; i&lt;n; ++i) scanf(\"%lf%lf\",&amp;x,&amp;y),p[i]=Coord(x,y); for(int i=0; i&lt;n; ++i) { x=abs(p[i]-p[(i+1)%n]),y=abs(p[(i+1)%n]-p[(i+2)%n]),z=abs(p[(i+2)%n]-p[i]); if(sgn(x-y)||sgn((n-2)*PI/n-acos((x*x+y*y-z*z)/2/x/y)))return printf(\"NO\"),0; } printf(\"YES\");} Old Ural Legend1234567891011#include&lt;stdio.h&gt;#define N 1000009char s[N],f[N];int main(){ scanf(\"%s\",s); for(int i=0; s[i]; ++i) for(int j=i,p=0; s[j]&amp;&amp;j&lt;i+6; ++j) f[p=p*10+s[j]-'0']=1; for(int i=1; i&lt;N; ++i)if(!f[i])return printf(\"%d\",i),0;} Ski-Trails for Robots12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define X first#define Y secondusing namespace std;typedef long long ll;const ll INF=1e18;int main(){ int n,s,k; map&lt;int,ll&gt; mp; scanf(\"%d%d%d\",&amp;n,&amp;s,&amp;k); for(int i=mp[s]=0,l,r; i&lt;k; ++i) { scanf(\"%d%d\",&amp;l,&amp;r); if(l&gt;1&amp;&amp;!mp.count(l-1))mp[l-1]=INF; if(r&lt;n&amp;&amp;!mp.count(r+1))mp[r+1]=INF; map&lt;int,ll&gt;::iterator b=mp.lower_bound(l),e=mp.upper_bound(r),it,jt; if(l&gt;1) { jt=mp.find(l-1); --b; jt-&gt;Y=min(jt-&gt;Y,jt-&gt;X-b-&gt;X+b-&gt;Y); ++b; for(it=b; it!=e; ++it) jt-&gt;Y=min(jt-&gt;Y,it-&gt;X-jt-&gt;X+it-&gt;Y); } if(r&lt;n) { jt=mp.find(r+1); jt-&gt;Y=min(jt-&gt;Y,e-&gt;X-jt-&gt;X+e-&gt;Y); for(it=b; it!=e; ++it) jt-&gt;Y=min(jt-&gt;Y,jt-&gt;X-it-&gt;X+it-&gt;Y); } mp.erase(b,e); } ll ans=INF; for(map&lt;int,ll&gt;::iterator it=mp.begin(); it!=mp.end(); ++it) ans=min(ans,it-&gt;Y); printf(\"%lld\",ans);} Metro to Every Home12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define X first#define Y secondusing namespace std;const int N=1e5+9;pair&lt;pair&lt;int,int&gt;,int&gt; v[N];int h,n,vis[N];int main(){ scanf(\"%d%d\",&amp;h,&amp;n); for(int i=0,l,r; i&lt;n; ++i) { scanf(\"%d%d\",&amp;v[2*i].X.X,&amp;v[2*i].X.Y); v[2*i+1].X.X=h-v[2*i].X.Y; v[2*i+1].X.Y=h-v[2*i].X.X; v[2*i].Y=i+1; v[2*i+1].Y=-i-1; } if(v[0].X.X&gt;v[0].X.Y) for(int i=0; i&lt;2*n; ++i) v[i].X.X=h-v[i].X.X,v[i].X.Y=h-v[i].X.Y; sort(v,v+2*n); vector&lt;int&gt; ans; for(int pre=v[0].X.X,d=v[0].X.Y-pre,i=0; i&lt;2*n; ++i) if(v[i].X.X==pre&amp;&amp;!vis[abs(v[i].Y)]) { if(v[i].X.Y-v[i].X.X!=d)return printf(\"0\"),0; pre=v[i].X.Y; ans.push_back(v[i].Y); vis[abs(v[i].Y)]=1; } if(*min_element(vis+1,vis+n+1)==0)return printf(\"0\"),0; for(int i=0; i&lt;ans.size(); ++i)printf(\"%d \",ans[i]);}","link":"/2018/10/20/2018-10-20-Ural Championship 2010/"},{"title":"SuperMemo","text":"题目链接比较全面的一个题了，FhqTreap真是好用啊。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct FhqTreap{ struct Node { int ch[2],siz,rev; ll key,val,min,add; void REV() { rev^=1,swap(ch[0],ch[1]); } void ADD(ll v) { val+=v,min+=v,add+=v; } }; vector&lt;Node&gt; v; int root; FhqTreap():v(1),root(0) {} void push_down(int k) { if(!k)return; for(int i=0,*ch=v[k].ch; i&lt;2; ++i) if(ch[i]) { v[ch[i]].ADD(v[k].add); if(v[k].rev)v[ch[i]].REV(); } v[k].add=v[k].rev=0; } void push_up(int k) { if(!k)return; v[k].siz=1,v[k].min=v[k].val; for(int i=0,*ch=v[k].ch; i&lt;2; ++i) if(ch[i]) v[k].siz+=v[ch[i]].siz,v[k].min=min(v[k].min,v[ch[i]].min); } int merge(int a,int b) { if(!a||!b)return a+b; if(v[a].key&lt;v[b].key) return push_down(a),v[a].ch[1]=merge(v[a].ch[1],b),push_up(a),a; return push_down(b),v[b].ch[0]=merge(a,v[b].ch[0]),push_up(b),b; } void split(int a,int s,int &amp;l,int &amp;r) { if(!s)l=0,r=a; else if(v[v[a].ch[0]].siz&lt;s) push_down(a),split(v[a].ch[1],s-v[v[a].ch[0]].siz-1,v[a].ch[1],r),push_up(l=a); else push_down(a),split(v[a].ch[0],s,l,v[a].ch[0]),push_up(r=a); } void push_back(ll d) { v.push_back(Node { {0,0},1,0,rand(),d,d,d}); root=merge(root,v.size()-1); } void insert(int x,ll d) { v.push_back(Node { {0,0},1,0,rand(),d,d,d}); int a,b,c; split(root,x-1,a,b); root=merge(merge(a,v.size()-1),b); } void erase(int x) { int a,b,c; split(root,x,a,b),split(a,x-1,a,c),root=merge(a,b); } void add(int l,int r,ll d) { int a,b,c; split(root,r,b,c),split(b,l-1,a,b),v[b].ADD(d),root=merge(merge(a,b),c); } Node ask(int l,int r) { int a,b,c; split(root,r,b,c),split(b,l-1,a,b); Node ret=v[b]; return root=merge(merge(a,b),c),ret; } void reverse(int l,int r) { int a,b,c; split(root,r,b,c),split(b,l-1,a,b),v[b].REV(),root=merge(merge(a,b),c); } void revolve(int l,int r,int d) { int a,b,c,e=r-l+1; split(root,r,b,c),split(b,l-1,a,b),split(b,(e-d%e)%e,b,e); root=merge(merge(a,merge(e,b)),c); }};int main(){ int n,x,y,d; char s[9]; FhqTreap t; for(scanf(\"%d\",&amp;n); n--;)scanf(\"%d\",&amp;d),t.push_back(d); for(scanf(\"%d\",&amp;n); n--;) { scanf(\"%s%d\",s,&amp;x); if(s[0]=='A')scanf(\"%d%d\",&amp;y,&amp;d),t.add(x,y,d); else if(s[0]=='I')scanf(\"%d\",&amp;d),t.insert(x+1,d); else if(s[0]=='D')t.erase(x); else if(s[0]=='M')scanf(\"%d\",&amp;y),printf(\"%d\\n\",t.ask(x,y).min); else if(s[3]=='E')scanf(\"%d\",&amp;y),t.reverse(x,y); else scanf(\"%d%d\",&amp;y,&amp;d),t.revolve(x,y,d); }}","link":"/2018/10/18/2018-10-18-OpenJ_Bailian-4090/"},{"title":"Tyvj 1728 普通平衡树","text":"题目链接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct FhqTreap{ struct Node { int ch[2],siz; ll key,val; }; vector&lt;Node&gt; v; int root; FhqTreap():v(1),root(0) {} void push_up(int k) { v[k].siz=v[v[k].ch[0]].siz+v[v[k].ch[1]].siz+1; } int merge(int a,int b) { if(!a||!b)return a+b; if(v[a].key&lt;v[b].key) return v[a].ch[1]=merge(v[a].ch[1],b),push_up(a),a; return v[b].ch[0]=merge(a,v[b].ch[0]),push_up(b),b; } void splitVal(int a,ll w,int &amp;l,int &amp;r)//按值将树划分，使得左子树上的值恰小于w { if(!a)l=r=0; else if(v[a].val&gt;w)splitVal(v[a].ch[0],w,l,v[a].ch[0]),push_up(r=a); else splitVal(v[a].ch[1],w,v[a].ch[1],r),push_up(l=a); } void insert(ll x) { int a,b; v.push_back(Node { {0,0},1,rand(),x}); splitVal(root,x,a,b),root=merge(merge(a,v.size()-1),b); } void erase(ll x) { int a,b,c; splitVal(root,x,a,b),splitVal(a,x-1,a,c); root=merge(merge(a,merge(v[c].ch[0],v[c].ch[1])),b); } ll kth(int k) { for(int u=root,ls;;) { if(ls=v[v[u].ch[0]].siz,ls+1==k) return v[u].val; if(ls&lt;k)k-=ls+1,u=v[u].ch[1]; else u=v[u].ch[0]; } } int lower_bound(ll x) { return upper_bound(x-1); } int upper_bound(ll x) { int a,b,ret; return splitVal(root,x,a,b),ret=v[a].siz+1,root=merge(a,b),ret; }};int main(){ int n,o,x; FhqTreap t; for(scanf(\"%d\",&amp;n); n--;) { scanf(\"%d%d\",&amp;o,&amp;x); if(o==1)t.insert(x); else if(o==2)t.erase(x); else printf(\"%d\\n\",o==3?t.lower_bound(x): t.kth(o==4?x: o==5?t.lower_bound(x)-1: t.upper_bound(x))); }}","link":"/2018/10/18/2018-10-18-HYSBZ-3224/"},{"title":"2017-2018 ACM-ICPC Southeastern European Regional Programming Contest(SEERC 2017)","text":"Concerts题目的辣鸡数据范围有问题。滚动DP。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e7+9,M=1e9+7;char a[N],b[N];int n,k,f[2][N],h[127];int main(){ scanf(\"%d%d\",&amp;k,&amp;n); for(char c='A'; c&lt;='Z'; ++c)scanf(\"%d\",&amp;h[c]); scanf(\"%s%s\",a+1,b+1); fill(f[0],f[0]+n+1,1); int nxt=0; for(int i=1; i&lt;=k; ++i) { f[nxt^=1][0]=0; for(int j=1; j&lt;=n; ++j) { f[nxt][j]=f[nxt][j-1]; if(b[j]==a[i]&amp;&amp;j-1-h[a[i-1]]&gt;=0) f[nxt][j]+=f[nxt^1][j-1-h[a[i-1]]]; if(f[nxt][j]&gt;=M)f[nxt][j]-=M; } } printf(\"%d\",f[nxt][n]);} Robots12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;struct S{ int a,t;}s[10010];bool cmp(const S &amp;x,const S &amp;y){ return x.a&gt;y.a;}int n;int main(){ scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;++i) scanf(\"%d%d\",&amp;s[i].a,&amp;s[i].t); int v=0; double ans=0; for (int i=1;i&lt;=n;++i) { ans-=v*s[i].t+0.5*s[i].a*s[i].t*s[i].t; v+=s[i].a*s[i].t; } sort(s+1,s+n+1,cmp); v=0; for (int i=1;i&lt;=n;++i) { ans+=v*s[i].t+0.5*s[i].a*s[i].t*s[i].t; v+=s[i].a*s[i].t; } printf(\"%.1lf\\n\",ans); } Escape Room1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+9;pair&lt;int,int&gt; a[N];int n,b[N];int main(){ scanf(\"%d\",&amp;n); for(int i=0; i&lt;n; ++i)scanf(\"%d\",&amp;a[i].first),a[i].second=i; sort(a,a+n); for(int i=n; i; --i) b[a[n-i].second]=i; for(int i=0; i&lt;n; ++i)printf(\"%d \",b[i]);}","link":"/2018/10/21/2018-10-21-2017-2018 ACM-ICPC Southeastern European Regional Programming Contest (SEERC 2017)/"},{"title":"Willem, Chtholly and Seniorious","text":"中国珂学院 题目链接珂朵莉树是一个可以维护区间x次方和查询的高效数据结构，原理十分暴力。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define mul(a,b,c) ((a)*(b)%(c))using namespace std;typedef long long ll;typedef pair&lt;int,ll&gt; pil;ll pow(ll a,ll b,ll m){ ll r=1; for(a%=m; b; a=mul(a,a,m),b&gt;&gt;=1) if(b&amp;1)r=mul(r,a,m); return r;}struct ChthollyTree:map&lt;int,pil&gt;{ iterator split(int pos) { iterator it=lower_bound(pos); if(it!=end()&amp;&amp;it-&gt;first==pos)return it; --it; if(pos&gt;it-&gt;second.first)return end(); pair&lt;int,pil&gt; p=*it; erase(it); insert(make_pair(p.first,pil(pos-1,p.second.second))); return insert(make_pair(pos,p.second)).first; } void add(int l,int r,ll val) { for(iterator b=split(l),e=split(r+1); b!=e; ++b)b-&gt;second.second+=val; } void set(int l,int r,ll val) { erase(split(l),split(r+1)),insert(make_pair(l,pil(r,val))); } ll rank(int l,int r,int k) { vector&lt;pair&lt;ll,int&gt; &gt; v; for(iterator b=split(l),e=split(r+1); b!=e; ++b) v.push_back(make_pair(b-&gt;second.second,b-&gt;second.first-b-&gt;first+1)); sort(v.begin(),v.end()); for(int i=0; i&lt;v.size(); ++i) if(k-=v[i].second,k&lt;=0)return v[i].first; return -1; } ll sum(int l,int r,ll ex,ll m) { ll res=0; for(iterator b=split(l),e=split(r+1); b!=e; ++b) res=(res+mul(b-&gt;second.first-b-&gt;first+1,pow(b-&gt;second.second,ex,m),m))%m; return res; }} t;ll n,m,seed,vmax,M=1e9+7;ll rnd(){ ll ret=seed; seed=(seed*7+13)%M; return ret;}int main(){ scanf(\"%lld%lld%lld%lld\",&amp;n,&amp;m,&amp;seed,&amp;vmax); for(int i=1; i&lt;=n; ++i) t.insert(make_pair(i,pil(i,rnd()%vmax+1))); for(int i=1; i&lt;=m; ++i) { int op=rnd()%4+1,l=rnd()%n+1,r=rnd()%n+1; if(l&gt;r)swap(l,r); ll x=rnd()%(op==3?r-l+1:vmax)+1; if(op==1)t.add(l,r,x); if(op==2)t.set(l,r,x); if(op==3)printf(\"%lld\\n\",t.rank(l,r,x)); if(op==4)printf(\"%lld\\n\",t.sum(l,r,x,rnd()%vmax+1)); }}","link":"/2018/10/22/2018-10-22-CodeForces-896C/"},{"title":"函数程序设计实验三：使用Newton-Raphson方式计算平方根","text":"12345678910111213module Newton_Raphson wheresquareroot2 :: Float -&gt; Integer -&gt; Floatsquareroot2 x0 n=squareroot 2 x0 nsquareroot :: Float -&gt; Float -&gt; Integer -&gt; Floatsquareroot r x0 0=x0squareroot r x0 n=(x+r/x)/2 where x=squareroot r x0 (n-1)sqrtSeq :: Float -&gt; Float -&gt; [Float]sqrtSeq r x0=x0:sqrtSeq r (squareroot r x0 1)squareroot' :: Float -&gt; Float -&gt; Float -&gt; Floatsquareroot' r x0 eps=f (sqrtSeq r x0) eps where f (y:ys) eps=if abs((head ys)-y)&lt;eps then y else f ys eps","link":"/2018/10/23/2018-10-23-函数程序设计实验三：使用Newton-Raphson方式计算平方根/"},{"title":"脑洞治疗仪","text":"中国珂学院 题目链接珂朵莉树是一个可以维护区间x次方和查询的高效数据结构，原理十分暴力。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef pair&lt;int,ll&gt; pil;struct ChthollyTree:map&lt;int,pil&gt;{ iterator split(int pos) { iterator it=lower_bound(pos); if(it!=end()&amp;&amp;it-&gt;first==pos)return it; --it; if(pos&gt;it-&gt;second.first)return end(); pair&lt;int,pil&gt; p=*it; erase(it); insert(make_pair(p.first,pil(pos-1,p.second.second))); return insert(make_pair(pos,p.second)).first; } void set(int l,int r,ll val) { erase(split(l),split(r+1)),insert(make_pair(l,pil(r,val))); } void scure(int l,int r,int x,int y) { iterator e=split(r+1),b=split(l),it=b; int sum=0; for(; b!=e; ++b) if(b-&gt;second.second) sum+=b-&gt;second.first-b-&gt;first+1; erase(it,e); insert(make_pair(l,pil(r,0))); if(!sum)return; e=split(y+1),b=split(x),it=b; if(sum&gt;=y-x+1) { erase(b,e); insert(make_pair(x,pil(y,1))); return; } for( ; b!=e; ++b) if(!b-&gt;second.second) { sum-=b-&gt;second.first-b-&gt;first+1; if(sum&lt;0)return set(b-&gt;first,b-&gt;second.first+sum,1); b-&gt;second.second=1; } } ll MAX(int l,int r) { iterator e=split(r+1),b=split(l); ll res=0,now=0; for(; b!=e; ++b) if(!b-&gt;second.second) now+=b-&gt;second.first-b-&gt;first+1; else if(now)res=max(res,now),now=0; return max(res,now); }} t;int main(){ int n,m; scanf(\"%d%d\",&amp;n,&amp;m); t.insert(make_pair(1,pil(n,1))); for(int op,l,r,x,y; m--;) { scanf(\"%d%d%d\",&amp;op,&amp;l,&amp;r); if(op==0)t.set(l,r,0); else if(op==1)scanf(\"%d%d\",&amp;x,&amp;y),t.scure(l,r,x,y); else printf(\"%d\\n\",t.MAX(l,r)); }}","link":"/2018/10/22/2018-10-22-HYSBZ-4592/"},{"title":"GCD - Extreme (II)","text":"题目链接数论模板求$\\sum_{i=1}^n\\sum_{j=i+1}^n\\gcd(i,j)$。 解法一：蓝书解法，计算贡献设$f(n)=\\sum_{i=1}^{n-1}\\gcd(i,n)$，则所求答案为f(n)的前缀和。注意到$\\gcd(i,n)=k$的值一定是n的约数，按照这个约数进行分类。设满足$\\gcd(x,n)=k$的约束有g(n,i)个，则$f(n)=sum{i\\times g(n,i)|d\\mod i==0}$。依次计算f(n)需要枚举每个n的约数i，速度较慢，但是对每个i枚举它的倍数ki来更新f(ki)的值，此时速度和普通筛法同阶。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct EulerSieve{ vector&lt;int&gt; p,m,phi; EulerSieve(int N):m(N,0),phi(N,0) { phi[1]=1; for(long long i=2,k; i&lt;N; ++i) { if(!m[i])p.push_back(m[i]=i),phi[i]=i-1; for(int j=0; j&lt;p.size()&amp;&amp;(k=i*p[j])&lt;N; ++j) { phi[k]=phi[i]*p[j]; if((m[k]=p[j])==m[i])break; phi[k]-=phi[i]; } } }};struct GCDExtremeII:EulerSieve{ vector&lt;ll&gt; f; GCDExtremeII(int N):EulerSieve(N),f(N) { for(int i=1; i&lt;N; ++i) { for(int k=2; k*i&lt;N; ++k) f[k*i]+=i*phi[k]; f[i]+=f[i-1]; } }} g(4e6+9);int main(){ for(int n; ~scanf(\"%d\",&amp;n)&amp;&amp;n;)printf(\"%lld\\n\",g.f[n]);} 解法二：分块1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct EulerSieve{ vector&lt;int&gt; p,m,phi; vector&lt;ll&gt; sum; EulerSieve(int N):m(N,0),phi(N,0),sum(N,0) { phi[1]=1; for(long long i=2,k; i&lt;N; ++i) { if(!m[i])p.push_back(m[i]=i),phi[i]=i-1; for(int j=0; j&lt;p.size()&amp;&amp;(k=i*p[j])&lt;N; ++j) { phi[k]=phi[i]*p[j]; if((m[k]=p[j])==m[i])break; phi[k]-=phi[i]; } } for(int i=0; i&lt;N; ++i)sum[i]=sum[i-1]+phi[i]; }} e(4e6+9);int main(){ for(ll n,sum,tmp; ~scanf(\"%lld\",&amp;n)&amp;&amp;n;) { for(int i=1,j=sum=0; i&lt;=n; i=j+1) tmp=n/i,sum+=tmp*tmp*(e.sum[j=n/tmp]-e.sum[i-1]); printf(\"%lld\\n\",(sum-(n+1)*n/2)/2); }} 解法三：莫比乌斯反演$ans=\\sum_{d=1}^nd\\sum_{i=1}^{n/d}\\mu(i)[\\frac{n}{id}]^2=\\sum_{T=1}^n[\\frac{n}{T}]^2\\sum_{d|T}d\\mu(\\frac{T}{d})$数论分块可$O(\\sqrt n)$查询，总时间复杂度$O(n\\sqrt n)$。 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct EulerSieve{ vector&lt;int&gt; p,m,mu,sum;//素数序列，最小素因子，欧拉函数，莫比乌斯函数 EulerSieve(int N):m(N,0),mu(N,0),sum(N,0) { mu[1]=1;//m[1]=0 for(long long i=2,k; i&lt;N; ++i)//防i*p[j]爆int { if(!m[i])p.push_back(m[i]=i),mu[i]=-1;//i是素数 for(int j=0; j&lt;p.size()&amp;&amp;(k=i*p[j])&lt;N; ++j) { if((m[k]=p[j])==m[i]) { mu[k]=0; break; } mu[k]=-mu[i]; } } for(int i=1; i&lt;N; ++i)sum[i]=sum[i-1]+mu[i]; }} e(4e6+9);int main(){ for(ll n,sum,tmp; ~scanf(\"%lld\",&amp;n)&amp;&amp;n;) { sum=0; for(int i=1; i&lt;=n; ++i) for(ll l=1,r,tmp,m=n/i; l&lt;=m; l=r+1) tmp=m/l,sum+=i*tmp*tmp*(e.sum[r=m/tmp]-e.sum[l-1]); printf(\"%lld\\n\",(sum-(n+1)*n/2)/2); }}","link":"/2018/10/24/2018-10-24-UVA-11426/"},{"title":"2015-2016 Petrozavodsk Winter Training Camp, Saratov SU Contest","text":"Maximum Product1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;vector&lt;ll&gt; a,b,ans;ll n;ll product(const vector&lt;ll&gt; &amp;v){ ll ret=1,i=0; while(!v[i])++i; for(; i&lt;v.size(); ++i)ret*=v[i]; return ret;}int main(){ for(scanf(\"%lld\",&amp;n); n; n/=10)a.push_back(n%10); for(scanf(\"%lld\",&amp;n); n; n/=10)b.push_back(n%10); while(a.size()&lt;b.size())a.push_back(0); reverse(a.begin(),a.end()); reverse(b.begin(),b.end()); ans=b; for(ll i=0; i&lt;b.size(); ++i) if(b[i]) { vector&lt;ll&gt; v(b); --v[i]; fill(v.begin()+i+1,v.end(),9); if(v&gt;=a&amp;&amp;product(ans)&lt;product(v))ans=v; } reverse(ans.begin(),ans.end()); while(ans.back()==0)ans.pop_back(); for(ll i=ans.size()-1; ~i; --i)printf(\"%lld\",ans[i]);} Biathlon 2.012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=500000+10;typedef long long ll;struct track{ ll a,b,id;}t[maxn];struct rifle{ ll c,d;}q[maxn],r[maxn];ll n,m,cur,cnt;ll ans[maxn];bool cmp0(rifle x,rifle y){ if (x.c!=y.c) return x.c&lt;y.c; else return x.d&lt;y.d;}bool cmp1(track x,track y){return (x.a*y.b)&gt;(y.a*x.b);}int main(){ scanf(\"%lld\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%lld%lld\",&amp;t[i].a,&amp;t[i].b),t[i].id=i; scanf(\"%lld\",&amp;m); for (int i=1;i&lt;=m;i++) scanf(\"%lld%lld\",&amp;q[i].c,&amp;q[i].d); sort(t+1,t+n+1,cmp1);// for (int i=1;i&lt;=n;i++) printf(\"%lld %lld %lld\\n\",t[i].a,t[i].b,t[i].id); sort(q+1,q+m+1,cmp0); r[1]=q[1]; cnt=1; for (int i=2;i&lt;=m;i++) { if (q[i].c==r[cnt].c) continue; if (q[i].d&gt;=r[cnt].d) continue; r[++cnt]=q[i]; }// for (int i=1;i&lt;=cnt;i++) printf(\"%d %d\\n\",r[i].c,r[i].d); memset(q,0,sizeof(q)); q[1]=r[1]; q[2]=r[2]; int l=2; for (int i=3;i&lt;=cnt;i++) { while ((l&gt;1)&amp;&amp;((q[l].d-q[l-1].d)*(q[l].c-r[i].c)&lt;(q[l-1].c-q[l].c)*(r[i].d-q[l].d))) l--; q[++l]=r[i]; } cur=1; if (cnt==1) l=1; for (int i=1;i&lt;=n;i++) { while ((cur&lt;l)&amp;&amp;((t[i].a*q[cur].c+t[i].b*q[cur].d)&gt;(t[i].a*q[cur+1].c+t[i].b*q[cur+1].d))) cur++; ans[t[i].id]=t[i].a*q[cur].c+t[i].b*q[cur].d; } for (int i=1;i&lt;=n;i++) printf(\"%lld \",ans[i]); return 0;} Sockets1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N=2e5+9;ll n,m,a[N],b[N],c[N],s[N];int main(){ scanf(\"%lld%lld\",&amp;n,&amp;m); for(ll i=0; i&lt;n; ++i)scanf(\"%lld\",&amp;a[i]); for(ll i=0; i&lt;m; ++i)scanf(\"%lld\",&amp;b[i]); sort(a,a+n),sort(b,b+m); c[0]=1; for(ll i=0,now=0; i&lt;m; ++i) { if(c[now]==0) { if(!n)break; for(ll j=0; j&lt;b[i]; ++j) if(s[j]) { --s[j]; c[now=j+1]+=a[--n]; break; } } while(n&amp;&amp;now&lt;b[i]) { c[now+1]+=a[--n]; --c[now]; while(!c[now])++now; } if(now&lt;=b[i]) { --c[now],++s[now]; if(!c[now])++now; } } ll ans=0; for(ll i=0; i&lt;=m; ++i)ans+=s[i]; printf(\"%lld\",ans);}","link":"/2018/10/30/2018-10-30-2015-2016 Petrozavodsk Winter Training Camp, Saratov SU Contest/"},{"title":"函数程序设计实验四：列表练习（2）","text":"123456789101112131415161718192021222324{-称一个三元组(x,y,z)是毕达哥拉斯三元组，如果x*x + y*y == z*z。例如，(3,4,5), (4,3,5), (6,8,10)等。请定义一个函数triads :: Int -&gt; [(Int, Int, Int)] 使得triads n 给出[1 .. n]中的毕达哥拉斯三元组，如 &gt; triads 5 [(3,4,5),(4,3,5)] &gt; triads 13 [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(12,5,13)]-}triads :: Int -&gt; [(Int, Int, Int)]triads n=[(x,y,z)|x&lt;-[1..n],y&lt;-[1..n],z&lt;-[1..n],x*x+y*y==z*z]{-以上结果中(3,4,5)和(4,3,5)实际上没有区别。请改进该函数，使得结果中不出现这种重复意义的三元组，实现函数 triads2 :: Int -&gt; [(Int, Int, Int)]使得 &gt; triads2 5 [(3,4,5)] &gt; triads2 13 [(3,4,5),(5,12,13),(6,8,10)]-}triads2 :: Int -&gt; [(Int, Int, Int)]triads2 n=[(x,y,z)|x&lt;-[1..n],y&lt;-[x..n],z&lt;-[y..n],x*x+y*y==z*z]","link":"/2018/11/08/2018-11-08-列表练习（2）/"},{"title":"2011 ACM-ICPC Asia Dhaka Regional Contest","text":"Binary Matrix1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define N 2010using namespace std;int const INF=(1&lt;&lt;30);int ask(int *a,int n,int tot){ vector&lt;int&gt; v(a,a+n); int ans=0; for(int i=0; i+1&lt;v.size();++i) { ans+=abs(v[i]-tot); v[i+1]+=v[i]-tot; } return ans;}int a[N],b[N],n,m,T,sum;char s[N];int main(){ scanf(\"%d\",&amp;T); for (int t=1; t&lt;=T; ++t) { scanf(\"%d%d\",&amp;n,&amp;m); memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); sum=0; for (int i=1; i&lt;=n; ++i) { scanf(\"%s\",s+1); for (int j=1; j&lt;=m; ++j) if (s[j]=='1') { ++a[i]; ++b[j]; ++sum; } } int ans1=INF,ans2=INF; if (sum%n==0) { for (int i=1; i&lt;=n; ++i) a[i+n]=a[i]; for (int i=1; i&lt;=n; ++i) ans1=min(ans1,ask(a+i,n,sum/n)); } if (sum%m==0) { for (int i=1; i&lt;=m; ++i) b[i+m]=b[i]; for (int i=1; i&lt;=m; ++i) ans2=min(ans2,ask(b+i,m,sum/m)); } printf(\"Case %d: \",t); if (ans1==INF &amp;&amp; ans2==INF) puts(\"impossible\"); else if (ans1==INF) printf(\"column %d\\n\",ans2); else if (ans2==INF) printf(\"row %d\\n\",ans1); else printf(\"both %d\\n\",ans1+ans2); }} Candles1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define COUNT __builtin_popcountusing namespace std;bool ask(int l,int r,int i){ if(l==0)return i&gt;&gt;r&amp;1; return l!=r&amp;&amp;(i&gt;&gt;r&amp;1)&amp;&amp;(i&gt;&gt;l&amp;1);}int main(){ for(int kase=0,n,a[15],ans; ~scanf(\"%d\",&amp;n)&amp;&amp;n; printf(\"\\n\")) { for(int i=0; i&lt;n; ++i)scanf(\"%d\",&amp;a[i]); for(int i=0,len=ans=(1&lt;&lt;10)-1,flag; i&lt;len; ++i) if(COUNT(i)&lt;COUNT(ans)) { for(int j=flag=0,l,r; !flag&amp;&amp;j&lt;n; ++j) { l=a[j]/10,r=a[j]%10; if(ask(l,r,i))continue; flag=1; if(l==0) { for(int k=1; k+k&lt;r; ++k) if((i&gt;&gt;k&amp;1)&amp;&amp;(i&gt;&gt;r-k&amp;1)) { flag=0; break; } } else { for(int k=1,ii; flag&amp;&amp;k&lt;10; ++k) if(i&gt;&gt;k&amp;1) { l=(a[j]-k)/10,r=(a[j]-k)%10,ii=i&amp;~(1&lt;&lt;k); if(ask(l,r,ii)) { flag=0; break; } for(int kk=0,iii; kk&lt;10; ++kk) if(ii&gt;&gt;kk&amp;1) { if(a[j]-k*10-kk&lt;0)break; l=(a[j]-k*10-kk)/10,r=(a[j]-k*10-kk)%10,iii=ii&amp;~(1&lt;&lt;kk); if(ask(l,r,iii)) { flag=0; break; } } } } } if(!flag)ans=i; } printf(\"Case %d: \",++kase); for(int i=9; ~i; --i) if(ans&gt;&gt;i&amp;1)printf(\"%d\",i); }} Cards123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;typedef double lf;const lf EPS=1e-4,INF=1e4;int t,a[4],kase;lf f[15][15][15][15][5][5];lf dp(int i,int j,int k,int l,int m,int n){ if(f[i][j][k][l][m][n]&gt;=-EPS)return f[i][j][k][l][m][n]; lf &amp;ans=f[i][j][k][l][m][n]=0; int need[4]= {a[0]-i,a[1]-j,a[2]-k,a[3]-l},res=54-i-j-k-l,ca[4]= {13-i,13-j,13-k,13-l}; if(m&lt;4)--need[m],--res; if(n&lt;4)--need[n],--res; if(*max_element(need,need+4)&lt;=0)return ans=54-res; if(ca[0])ans+=dp(i+1,j,k,l,m,n)/res*ca[0]; if(ca[1])ans+=dp(i,j+1,k,l,m,n)/res*ca[1]; if(ca[2])ans+=dp(i,j,k+1,l,m,n)/res*ca[2]; if(ca[3])ans+=dp(i,j,k,l+1,m,n)/res*ca[3]; if(m==4) { lf tmp=INF; for(int t=0; t&lt;4; ++t) if(need[t]&gt;0) tmp=min(tmp,dp(i,j,k,l,t,n)); ans+=tmp/res*2; } else if(n==4) { lf tmp=INF; for(int t=0; t&lt;4; ++t) if(need[t]&gt;0) tmp=min(tmp,dp(i,j,k,l,m,t)); ans+=tmp/res; } if(ans&lt;EPS)ans=INF; return ans;}int main(){ for(scanf(\"%d\",&amp;t); t--;) { printf(\"Case %d: \",++kase); for(int i=0; i&lt;4; ++i)scanf(\"%d\",&amp;a[i]); for(int i=0; i&lt;15; ++i) for(int j=0; j&lt;15; ++j) for(int k=0; k&lt;15; ++k) for(int l=0; l&lt;15; ++l) for(int m=0; m&lt;5; ++m) for(int n=0; n&lt;5; ++n) f[i][j][k][l][m][n]=-1; if(a[0]+a[1]+a[2]+a[3]==0) { printf(\"0.000\\n\"); continue; } if(max(a[0]-13,0)+max(a[1]-13,0)+max(a[2]-13,0)+max(a[3]-13,0)&gt;2) { printf(\"-1.000\\n\"); continue; } printf(\"%.3f\\n\",dp(0,0,0,0,4,4)); }} Packing for Holiday1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int t,a,b,c,kase;int main(){ for(scanf(\"%d\",&amp;t); t--;) { scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); printf(\"Case %d: %s\\n\",++kase,a&lt;21&amp;&amp;b&lt;21&amp;&amp;c&lt;21?\"good\":\"bad\"); }} Pair of Touching Circles123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=1000+10;typedef long long ll;struct r{ int a,b,c;}f[maxn*maxn];int t,h,w,cnt;ll ans;void init(){ for (int i=1;i&lt;=1000;i++) { for(int j=1;j&lt;=1000;++j) { int k=sqrt(i*i+j*j)+0.5; if(k&gt;1000) break; if(i*i+j*j==k*k) {f[++cnt].a=i; f[cnt].b=j; f[cnt].c=k;} } }}int main(){ init(); scanf(\"%d\",&amp;t); for (int cc=1;cc&lt;=t;cc++) { ans=0; scanf(\"%d%d\",&amp;h,&amp;w); for (int i=1;i&lt;=cnt;i++) { int j,k; ll x=f[i].a+f[i].c,y=f[i].b+f[i].c; if ((x&gt;h)||(y&gt;w)) continue; // printf(\"%d %d %d\\n\",f[i].a,f[i].b,f[i].c); for (j=1;((f[i].c-j-f[i].b)&gt;j) || ((f[i].c-j-f[i].a)&gt;j);j++) { // printf(\"%d %d %d ans=%lld \",f[i].a,f[i].b,f[i].c,ans); x=max(f[i].a+f[i].c,(f[i].c-j)*2); y=max(f[i].b+f[i].c,(f[i].c-j)*2); if ((x&gt;h)||(y&gt;w)) continue; ans+=(h-x+1)*(w-y+1)*2; } for (k=f[i].c-1;((k-f[i].b)&gt;(f[i].c-k)) || ((k-f[i].a)&gt;(f[i].c-k));k--) { // printf(\"%d %d %d ans=%lld \",f[i].a,f[i].b,f[i].c,ans); x=max(f[i].a+f[i].c,k*2); y=max(f[i].b+f[i].c,k*2); if ((x&gt;h)||(y&gt;w)) continue; ans+=(h-x+1)*(w-y+1)*2; } // printf(\"%d %d\\n\",j,k); x=f[i].a+f[i].c;y=f[i].b+f[i].c; ll g=(k-j+1)*2; ans+=(h-x+1)*(w-y+1)*g; // if (f[i].c==10) printf(\"%lld\\n\",ans); } // printf(\"! %lld\\n\",ans); for (int i=1;i&lt;=h;i++) for (int j=1;j&lt;=w;j++) { if ((i&amp;1)||(j&amp;1)) continue; if (i==j) continue; if (max(i,j)&gt;(min(i,j)*2)) continue; ll g; if (max(i,j)==(min(i,j)*2)) g=1; else g=2; ans+=(ll)(h-i+1)*(w-j+1)*g; } printf(\"Case %d: %lld\\n\",cc,ans); } return 0;} As Long as I Learn, I Live1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int T,n,m;int line[200][200];int go[200],a[200];int main(){ scanf(\"%d\",&amp;T); for (int t=1;t&lt;=T;++t) { int ans=0; memset(line,0,sizeof(line)); memset(go,0,sizeof(go)); scanf(\"%d%d\",&amp;n,&amp;m); for (int i=0;i&lt;n;++i) scanf(\"%d\",&amp;a[i]); for (int i=0;i&lt;m;++i) { int u,v; scanf(\"%d%d\",&amp;u,&amp;v); line[u][v]=true; ++go[u]; } int now=0; while (go[now]) { int maxid=-1,maxa=0; for (int i=0;i&lt;n;++i) if (line[now][i] &amp;&amp; maxa&lt;a[i]) { maxa=a[i];maxid=i; } ans+=maxa; now=maxid; } printf(\"Case %d: %d %d\\n\",t,ans,now); } }","link":"/2018/10/27/2018-10-27-2011 ACM-ICPC Asia Dhaka Regional Contest/"},{"title":"函数程序设计实验七：石头、剪刀和布","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169{-设计一个交互程序，实现计算机（我）和用户（您）玩猜拳“石头、剪刀和布”。 例如，运行程序实现下来交互游戏：*Main&gt; play请您出手 (R)石头, (S)剪刀, (P)布:p, 您出了布, 我出了石头您赢了这手我的得分: 0您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:s, 您出了剪刀, 我出了布您赢了这手我的得分: 0您的得分: 2请您出手 (R)石头, (S)剪刀, (P)布:r, 您出了石头, 我出了剪刀您赢了这手我的得分: 0您的得分: 3算您赢了这轮。*Main&gt; play请您出手 (R)石头, (S)剪刀, (P)布:s, 您出了剪刀, 我出了布您赢了这手我的得分: 0您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:r, 您出了石头, 我出了石头这一手平手我的得分: 0您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:p, 您出了布, 我出了剪刀我的得分: 1您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:p, 您出了布, 我出了剪刀我的得分: 2您的得分: 1请您出手 (R)石头, (S)剪刀, (P)布:r, 您出了石头, 我出了剪刀您赢了这手我的得分: 2您的得分: 2请您出手 (R)石头, (S)剪刀, (P)布:s, 您出了剪刀, 我出了石头我的得分: 3您的得分: 2哈哈，我赢了！作业要求：1. 模块命名为Game, 程序命名为play:: IO ();2. 程序要仿照以上例子，输出交互过程和相关详细信息；3. 使用下面的手势类型及instance定义，需要 import System.Random:data Hand = Rock | Scissor | Paper deriving (Enum)instance Random Hand where random g = case randomR (0,2) g of (r, g') -&gt; (toEnum r, g') randomR (a,b) g = case randomR (fromEnum a, fromEnum b) g of (r, g') -&gt; (toEnum r, g')你也可以自己将Hand定义为Random的实例，以便能够使用随机手势，如 randomIO :: IO Hand4. 用户（您）的输入用字母表示：r, s和p（不分大小写）分别表示用户选择的石头、剪刀和布5. 建议适当定义一些辅助函数，不要把所有的命令都写在函数play中6. 一点提示：猜数和猜单词中定义了函数：guess :: Int (或者String) -&gt; IO ()其中输入参数是要猜的数或单词，在一系列猜测过程中需要这个信息，以便决定是停止还是继续猜（递归）。那么，猜拳时可能也需要类似的信息。提交要求：1. 提交模块Game;2. 仿照以上例子，至少给出计算机（我）和用户（您）各赢一次的运行截图。-}module Game whereimport System.Randomimport Text.Printfdata Hand = Rock | Scissor | Paper deriving (Enum,Eq)instance Random Hand where random g = case randomR (0,2) g of (r, g') -&gt; (toEnum r, g') randomR (a,b) g = case randomR (fromEnum a, fromEnum b) g of (r, g') -&gt; (toEnum r, g')getHand::IO HandgetHand= do s&lt;-getLine if (s==\"r\")||(s==\"R\") then return Rock else if (s==\"s\")||(s==\"S\") then return Scissor else return PaperisWin::Hand-&gt;Hand-&gt;Bool isWin p c=(p==Rock&amp;&amp;c==Scissor)||(p==Scissor&amp;&amp;c==Paper)||(p==Paper&amp;&amp;c==Rock)toStr::Hand-&gt;StringtoStr Rock=\"石头\"toStr Scissor=\"剪刀\"toStr Paper=\"布\"play::IO()play=game 0 0game::Int-&gt;Int-&gt;IO()game a b= do putStrLn \"请您出手 (R)石头, (S)剪刀, (P)布:\" ta&lt;-getHand tb&lt;-randomIO::IO Hand putStrLn(printf \"您出了%s, 我出了%s\" (toStr ta) (toStr tb)) if isWin ta tb then do putStrLn(printf \"您赢了这手\\n我的得分: %d\\n您的得分: %d\" b (a+1)) if a&gt;1 then putStrLn \"算您赢了这轮。\" else game (a+1) b else if isWin tb ta then do putStrLn(printf \"我赢了这手\\n我的得分: %d\\n您的得分: %d\" (b+1) a) if b&gt;1 then putStrLn \"哈哈，我赢了！\" else game a (b+1) else do putStrLn(printf \"这一手平手\\n我的得分: %d\\n您的得分: %d\" b a) game a b--main::IO()--main=play","link":"/2018/11/14/2018-11-14-函数程序设计实验七：石头、剪刀和布/"},{"title":"函数程序设计实验八：模拟随机事件","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778{-Newton–Pepys problemFrom Wikipedia, the free encyclopediaJump to navigationJump to searchThe Newton–Pepys problem is a probability problem concerning the probability of throwing sixes from a certain number of dice.[1]In 1693 Samuel Pepys and Isaac Newton corresponded over a problem posed by Pepys in relation to a wager he planned to make. The problem was:Which of the following three propositions has the greatest chance of success?A. Six fair dice are tossed independently and at least one “6” appears.B. Twelve fair dice are tossed independently and at least two “6”s appear.C. Eighteen fair dice are tossed independently and at least three “6”s appear.[2]Pepys initially thought that outcome C had the highest probability, but Newton correctly concluded that outcome A actually has the highest probability.请你通过模拟的方法找到问题的答案。要求：1. 说明模拟方法和过程；2. 提交代码，并说明如何运行程序，得到问题答案。-}import System.Randomimport Text.Printfmain::IO()main= do let n=1000 a&lt;-getProbablity eventA n b&lt;-getProbablity eventB n c&lt;-getProbablity eventC n putStrLn(printf \"P(A)=%.7f,P(B)=%.7f,P(C)=%.7f\" a b c)getProbablity::(IO Bool)-&gt;Int-&gt;IO FloatgetProbablity event n=do xs&lt;-happen event n return ((fromIntegral xs)/(fromIntegral n))happen::(IO Bool)-&gt;Int-&gt;(IO Int)happen event 0=return 0happen event n= do e&lt;-event y&lt;-happen event (n-1) if e==True then return (1+y) else return ygetDices::Int-&gt;IO [Int]getDices 0=return []getDices x=do y&lt;-randomRIO(1,6) ys&lt;-getDices(x-1) return (y:ys)eventA::IO BooleventA= do xs&lt;-getDices 6 return ((countSix xs)&gt;0)eventB::IO BooleventB= do xs&lt;-getDices 12 return ((countSix xs)&gt;1)eventC::IO BooleventC= do xs&lt;-getDices 18 return ((countSix xs)&gt;2)countSix::[Int]-&gt;IntcountSix []=0countSix (x:xs)= if x==6 then (countSix xs)+1 else countSix xs","link":"/2018/11/14/2018-11-14-函数程序设计实验八：模拟随机事件/"},{"title":"函数程序设计实验五：打印购物小票","text":"12345678910111213141516171819202122232425module HaskellStore whereimport Text.Printftype Items=[Item]type Item=(Name,Amount,Price)type Name=Stringtype Amount=Floattype Price=FloatprintItems::Items-&gt;IO()printItems its=putStr(printf \"Name\\tAmount\\tPrice\\tSum\\n%sTotal\\t\\t\\t%.2f\\n\" (printItem its) (sumItem its)) where printItem []=\"\" printItem ((n,a,p):xs)=printf \"%s\\t%.2f\\t%.2f\\t%.2f\\n%s\" n a p (a*p) (printItem xs) sumItem []=0 sumItem ((n,a,p):xs)=a*p+(sumItem xs){---测试代码*HaskellStore&gt; printItems [(\"Apple\",2.5,5.99),(\"Bread\",2,3.5)]Name Amount Price SumApple 2.50 5.99 14.97Bread 2.00 3.50 7.00Total 21.97-}","link":"/2018/11/08/2018-11-08-打印购物小票/"},{"title":"Fast Matrix Operations","text":"题目链接数据结构模板对蓝书上的懒标记进行加强，将对区间的操作改成区间线性变换，那么区间修改就是区间先乘0在修改，区间加就是区间先乘1再加。这样敲反而简单很多。 update: 更新了线段树模板。新的模板省去了build操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ll;const int NPOS = -1;struct SegmentTree{ struct Val { int l, r; ll min, max, sum; Val(int l, int r) : l(l), r(r), min(0), max(0), sum(0) {} Val(const Val &amp;lc, const Val &amp;rc) : l(lc.l), r(rc.r), min(std::min(lc.min, rc.min)), max(std::max(lc.max, rc.max)), sum(lc.sum + rc.sum) {} void upd(ll mul, ll add) { min = min * mul + add, max = max * mul + add, sum = sum * mul + add * (r - l + 1); } }; struct Node : Val { int lc, rc; ll mul, add; Node(Val v) : Val(v), lc(NPOS), rc(NPOS), mul(1), add(0) {} }; vector&lt;Node&gt; v; SegmentTree(int l, int r) : v{Val(l, r)} { v.reserve(r - l + 9 &lt;&lt; 1); } void down(int rt) { int m = (v[rt].l + v[rt].r) / 2; if (v[rt].lc == NPOS) v[rt].lc = v.size(), v.push_back(Val(v[rt].l, m)); if (v[rt].rc == NPOS) v[rt].rc = v.size(), v.push_back(Val(m + 1, v[rt].r)); upd(v[v[rt].lc].l, v[v[rt].lc].r, v[rt].mul, v[rt].add, v[rt].lc); upd(v[v[rt].rc].l, v[v[rt].rc].r, v[rt].mul, v[rt].add, v[rt].rc); v[rt].mul = 1; v[rt].add = 0; } void upd(int l, int r, ll mul, ll add, int rt = 0) { if (l &lt;= v[rt].l &amp;&amp; v[rt].r &lt;= r) return v[rt].mul *= mul, v[rt].add = v[rt].add * mul + add, v[rt].upd(mul, add); down(rt); if (r &lt;= v[v[rt].lc].r) upd(l, r, mul, add, v[rt].lc); else if (l &gt;= v[v[rt].rc].l) upd(l, r, mul, add, v[rt].rc); else upd(l, v[v[rt].lc].r, mul, add, v[rt].lc), upd(v[v[rt].rc].l, r, mul, add, v[rt].rc); dynamic_cast&lt;Val &amp;&gt;(v[rt]) = Val(v[v[rt].lc], v[v[rt].rc]); } Val ask(int l, int r, int rt = 0) { if (l &lt;= v[rt].l &amp;&amp; v[rt].r &lt;= r) return v[rt]; down(rt); if (r &lt;= v[v[rt].lc].r) return ask(l, r, v[rt].lc); if (l &gt;= v[v[rt].rc].l) return ask(l, r, v[rt].rc); return Val(ask(l, v[v[rt].lc].r, v[rt].lc), ask(v[v[rt].rc].l, r, v[rt].rc)); }};int main(){ for (int r, c, m, o, b, e, l; ~scanf(\"%d%d%d\", &amp;r, &amp;c, &amp;m);) for (vector&lt;SegmentTree&gt; Tree(r, {1, c}); m--;) { scanf(\"%d%d%d%d%d\", &amp;o, &amp;b, &amp;l, &amp;e, &amp;r); if (o == 3) { SegmentTree::Val ans(l, r); for (ans.min = 1e9, --b; b &lt; e; ++b) ans = SegmentTree::Val(ans, Tree[b].ask(l, r)); printf(\"%d %d %d\\n\", ans.sum, ans.min, ans.max); } else for (scanf(\"%d\", &amp;c), --b; b &lt; e; ++b) Tree[b].upd(l, r, o == 1, c); }} 原：目测是全网最短解法（Vjudge上Length1705，比第二名少了312，同时性能也比较强）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct SegmentTree{ struct Node { int l,r; ll mul,add,min,max,sum; void set(ll m,ll a) { mul*=m,add=add*m+a,min=min*m+a,max=max*m+a,sum=sum*m+a*(r-l+1); } void up(const Node &amp;lc,const Node &amp;rc) { min=std::min(lc.min,rc.min); max=std::max(lc.max,rc.max); sum=lc.sum+rc.sum; } void down(Node &amp;lc,Node &amp;rc) { lc.set(mul,add),rc.set(mul,add),mul=1,add=0; } }; vector&lt;Node&gt; v; SegmentTree(int N):v(N&lt;&lt;2) { build(1,N); } void build(int l,int r,int rt=1) { v[rt]= {l,r}; if(l&gt;=r)return; int m=l+r&gt;&gt;1; build(l,m,rt&lt;&lt;1),build(m+1,r,rt&lt;&lt;1|1),v[rt].up(v[rt&lt;&lt;1],v[rt&lt;&lt;1|1]); } void set(int l,int r,ll mul,ll add,int rt=1) { if(l&lt;=v[rt].l&amp;&amp;v[rt].r&lt;=r)return v[rt].set(mul,add); v[rt].down(v[rt&lt;&lt;1],v[rt&lt;&lt;1|1]); int m=v[rt].l+v[rt].r&gt;&gt;1; if(m&gt;=r)set(l,r,mul,add,rt&lt;&lt;1); else if(m&lt;l)set(l,r,mul,add,rt&lt;&lt;1|1); else set(l,m,mul,add,rt&lt;&lt;1),set(m+1,r,mul,add,rt&lt;&lt;1|1); v[rt].up(v[rt&lt;&lt;1],v[rt&lt;&lt;1|1]); } Node ask(int l,int r,int rt=1) { if(l&lt;=v[rt].l&amp;&amp;v[rt].r&lt;=r)return v[rt]; v[rt].down(v[rt&lt;&lt;1],v[rt&lt;&lt;1|1]); int m=v[rt].l+v[rt].r&gt;&gt;1; if(m&gt;=r)return ask(l,r,rt&lt;&lt;1); if(m&lt;l)return ask(l,r,rt&lt;&lt;1|1); return v[0].up(ask(l,m,rt&lt;&lt;1),ask(m+1,r,rt&lt;&lt;1|1)),v[0]; }};int main(){ for(int r,c,m,o,b,e,l; ~scanf(\"%d%d%d\",&amp;r,&amp;c,&amp;m);) for(vector&lt;SegmentTree&gt; tree(r,c); m--;) { scanf(\"%d%d%d%d%d\",&amp;o,&amp;b,&amp;l,&amp;e,&amp;r); if(o==3) { SegmentTree::Node ans; for(ans.min=1e9,ans.max=ans.sum=0,--b; b&lt;e; ++b) ans.up(ans,tree[b].ask(l,r)); printf(\"%d %d %d\\n\",ans.sum,ans.min,ans.max); } else for(scanf(\"%d\",&amp;c),--b; b&lt;e; ++b) tree[b].set(l,r,o==1,c); }}","link":"/2018/11/17/2018-11-17-UVA-11992/"},{"title":"函数程序设计实验九：检查信用卡号是否合法","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243{-Have you ever wondered how websites validate your credit card number when you shop online? They don’t check a massive database of numbers, and they don’t use magic. In fact, most credit providers rely on a checksum formula for distinguishing valid numbers from random collection of digits (or typing mistakes).In this lab, you will implement a validation algorithm for credit cards. The algorithm follows these steps:•Double the value of every second digit beginning with the rightmost.•Add the digits of the doubled values and the undoubled digits from the original number.•Calculate the modulus of the sum divided by 10. If the result equals 0, then the number is valid. Here is an example of the results of each step on the number 4012888888881881.•In order to start with the rightmost digit, we produce a reversed list of digits. Then, we double every second digit. Result: [1,16,8,2,8,16,8,16,8,16,8,16,2,2,0,8].•We sum all of the digits of the resulting list above. Note that we must again split the elements of the list into their digits (e.g. 16 becomes [1, 6]).Result: 90.•Finally, we calculate the modulus of 90 over 10.Result: 0. Since the final value is 0, we know that the above number is a valid credit card number. If we make a mistake in typing the credit card number and instead provide 4012888888881891, then the result of the last step is 2, proving that the number is invalid.-}import Data.Charimport System.IOimport Text.Printfmain::IO()main= do txt &lt;- readFile \"cards200.txt\" let (a,b)=cal (lines txt) putStr (printf \"%d %d\\n\" a b)cal::[String]-&gt;(Int,Int)cal []=(0,0)cal (x:xs)= if ((work (reverse x))==0) then (a+1,b) else (a,b+1) where (a,b)=cal xswork::String-&gt;Intwork []=0work [x]=(ord x)-(ord '0')work (x1:x2:xs)=mod (((ord x1)-(ord '0'))+2*((ord x2)-(ord '0'))+(work xs)) 10 下面是cards200.txt的内容，运行代码得到答案22 178。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920052067558648192021379105492196115540951298642364927052867249936104590339523768086722756869891751570175372133436865441960412536408198565030867480389302519241001636223821112224859726559326939706338736574583349116913844637722625258074684664193690508527164818115612958052562645266339929105901183103040871669651151264385941225303717689634699256048144343070287419257683131694950379152805537497734955821430889448254169209493328683713087525750075956421459282516351799318459633716487115627478650070970156277372821206158307440364773741503469547781187222103133156447719746399798291748662341976063133240531728915124175897230787874269036040748008214178234923217108878892277178006298241397122634521105145650879658145762107004760097534193188771230323054885886478753273922177074679289686714493173200967368330615081774344594555521266548531205126160083482350040120767532302053015806451273157712841719729917795762335974030035754007167259674014357157441317791240209245467965161497137574885781171899257701133688982794350368378236736041454912777449692694573414683907790401092608622547916116868488027692968023945238717667810450549617664401445632361230366122325152636065406032285323255372554869231587386310271105074799102124366684158654025394230790983717850243586808743291987314047749489766371097759555152908813938012769469671697934275823323325291563746700743232579354570894833736014832430093874132130304075151299641126934107608294466969371237742025394237626395508939573902873721004862957622459158478660202657913484501542772223084035343388074620749812422038069571929951808982331131325310492906276669151069896580952761393941769966549280223171141172736892034758146858997738006518673629107513531187680377165821163966666987219584980921175563937071257839309026238033995592282554069289606635583782378509865685497059828807892321128508863864684291889339923090354130264166681654972532148536349557313802985458176221346807681994722602621796644336079301440587730374804602918046374745587669305556232720762945582429531428556321379289576506897192251561625482211062328695864826456615481474878524986057360085361988964187962546645020349068188053232869079541194062656659468114992846616615393296141788976297025771172193973740846640578505841154790822293970429762423466683588880107998642528027394839067821962109612684056383121641303595671502921756346639312154134462171923673735577072257123898036294144840303038810533072982904243882417220961026224671542603467160146879206404517582871298086600359651093656471813956763248796711187218644054802380498750449910105915678343677212736110262669717928316995325446989375360056499731896507142569062440034338002222751089530890376641214565795259740899665194600260922616842369154112005103939391889246431661393135169592032768426604030469701005485356615133883240839473391936421212877181754128151633974861191924908199880925640870413217851167726800571012692393893449660472023939684571434857891646255494574872246508018512530038654446228673374217789625082932405156295710317245944224673414999934638024096106862625193144313232365203865011001692348140705327607289898057381020684792585213171134759377490205738829956226752602246679112097154252333081225455480435862103172486367625042916820612143067606886207671863851343341223","link":"/2018/11/25/2018-11-25-检查信用卡号是否合法/"},{"title":"第二章：单变量线性回归(Linear Regression with One Variable)","text":"参考了斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 模型表示我们将要用来描述这个回归问题的标记如下:$m$ 代表训练集中实例的数量$x$ 代表特征/输入变量$y$ 代表目标变量/输出变量$(x,y)$ 代表训练集中的实例$(x^{(i)},y^{(i)})$ 代表第 $i$ 个观察实例$h$ 代表学习算法的解决方案或函数也称为假设（hypothesis）一种可能的表达方式为：$h_\\theta(x)=\\theta_0+\\theta_1x$，因为只含有一个特征/输入变量，因此这样的问题叫作单变量线性回归问题。 代价函数引入一些术语我们现在要做的便是为我们的模型选择合适的参数（parameters）$\\theta_{0}$ 和 $\\theta_{1}$，在房价问题这个例子中便是直线的斜率和在$y$ 轴上的截距。我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距就是建模误差（modeling error）。我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。即使得代价函数 $J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$最小。则可以看出在三维空间中存在一个使得$J(\\theta_0,\\theta_1)$最小的点。代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。在后续课程中，我们还会谈论其他的代价函数，但我们刚刚讲的选择是对于大多数线性回归问题非常合理的。 代价函数的直观理解I总结上一节的内容： Hypothesis $h_\\theta(x)=\\theta_0+\\theta_1x$ Parameters $\\theta_0,\\theta_1$ Cost Function $J(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum\\limits_{i=1}^m(h_{\\theta}(x^{(i)})-y^{(i)})^2$ Goal $minimize_{\\theta_0,\\theta_1}J(\\theta_0,\\theta_1)$ 代价函数的直观理解II轮廓图：看起来比较像等高线图。 梯度下降${\\theta_{j} }:={\\theta_{j} }-\\alpha \\frac{\\partial }{\\partial {\\theta_{j} } }J\\left( \\theta \\right)$ 梯度下降的直观理解Repeat {${\\theta_{0} }:={\\theta_{0} }-a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{ \\left({ {h}{\\theta } }({ {x}^{(i)} })-{ {y}^{(i)} } \\right)}$${\\theta{1} }:={\\theta_{1} }-a\\frac{1}{m}\\sum\\limits_{i=1}^{m}{\\left( \\left({ {h}_{\\theta } }({ {x}^{(i)} })-{ {y}^{(i)} } \\right)\\cdot { {x}^{(i)} } \\right)}$} 接下来的内容对线性代数进行一个快速的复习回顾。如果你从来没有接触过向量和矩阵，那么这课件上所有的一切对你来说都是新知识，或者你之前对线性代数有所了解，但由于隔得久了，对其有所遗忘，那就请学习接下来的一组视频，我会快速地回顾你将用到的线性代数知识。通过它们，你可以实现和使用更强大的线性回归模型。事实上，线性代数不仅仅在线性回归中应用广泛，它其中的矩阵和向量将有助于帮助我们实现之后更多的机器学习模型，并在计算上更有效率。正是因为这些矩阵和向量提供了一种有效的方式来组织大量的数据，特别是当我们处理巨大的训练集时，如果你不熟悉线性代数，如果你觉得线性代数看上去是一个复杂、可怕的概念，特别是对于之前从未接触过它的人，不必担心，事实上，为了实现机器学习算法，我们只需要一些非常非常基础的线性代数知识。通过接下来几个视频，你可以很快地学会所有你需要了解的线性代数知识。具体来说，为了帮助你判断是否有需要学习接下来的一组视频，我会讨论什么是矩阵和向量，谈谈如何加、减 、乘矩阵和向量，讨论逆矩阵和转置矩阵的概念。","link":"/2018/11/29/2018-11-29-单变量线性回归/"},{"title":"第一章：引言(Introduction)","text":"参考了斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 欢迎第一个视频主要讲了什么是机器学习，机器学习能做些什么事情。 机器学习是什么Arthur Samuel：他定义机器学习为，在进行特定编程的情况下，给予计算机学习能力的领域。Tom Mitchell提出：一个程序被认为能从经验E中学习，解决任务T，达到性能度量值P，当且仅当，有了经验E后，经过P评判，程序在处理T时的性能有所提升。目前存在几种不同类型的学习算法。主要的两种类型被我们称之为监督学习和无监督学习。监督学习这个想法是指，我们将教计算机如何去完成任务，而在无监督学习中，我们打算让它自己进行学习。 监督学习Supervised Learning监督学习指的就是我们给学习算法一个数据集，并通过数据集做出预测。这个数据集由“正确答案”组成。 回归问题术语“回归”，意味着要预测这一系列值的属性。 分类问题目标是推出离散的结果。 无监督学习Unsupervised Learning不同于监督学习的数据的样子，即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。所以我们已知数据集，却不知如何处理，也未告知每个数据点是什么。别的都不知道，就是一个数据集。我们没有提前告知算法一些信息。要自动地聚类那些个体到各个类，我没法提前知道哪些是哪些。因为我们没有给算法正确答案来回应数据集中的数据，所以这就是无监督学习。无监督学习算法可能会把这些数据分成两个不同的簇。所以叫做聚类算法。聚类只是无监督学习中的一种。","link":"/2018/11/29/2018-11-29-引言/"},{"title":"第三章：线性代数回顾(Linear Algebra Review)","text":"参考了斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 矩阵和向量矩阵的维数即行数$\\times$列数矩阵元素（矩阵项）：$A=\\left[ \\begin{matrix} 1402 &amp; 191 \\ 1371 &amp; 821 \\ 949 &amp; 1437 \\ 147 &amp; 1448 \\\\end{matrix} \\right]$$A_{ij}$指第$i$行，第$j$列的元素。向量是一种特殊的矩阵，讲义中的向量一般都是列向量，如：$y=\\left[ \\begin{matrix} {460} \\ {232} \\ {315} \\ {178} \\\\end{matrix} \\right]$为四维列向量（$4\\times 1$）。如下图为1索引向量和0索引向量，左图为1索引向量，右图为0索引向量，一般我们用1索引向量。$y=\\left[ \\begin{matrix} { {y}{1} } \\ { {y}{2} } \\ { {y}{3} } \\ { {y}{4} } \\\\end{matrix} \\right]$，$y=\\left[ \\begin{matrix} { {y}{0} } \\ { {y}{1} } \\ { {y}{2} } \\ { {y}{3} } \\\\end{matrix} \\right]$ 加法和标量乘法矩阵的加法：行列数相等的可以加。组合算法也类似。 矩阵向量乘法$m\\times n$的矩阵乘以$n\\times 1$的向量，得到的是$m\\times 1$的向量。 矩阵乘法$m\\times n$矩阵乘以$n\\times o$矩阵，变成$m\\times o$矩阵。 矩阵乘法的性质矩阵的乘法不满足交换律：$A\\times B≠B\\times A$矩阵的乘法满足结合律。即：$A\\times (B\\times C)=(A\\times B)\\times C$单位矩阵：在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的1,我们称这种矩阵为单位矩阵．它是个方阵，一般用 $I$ 或者 $E$ 表示，本讲义都用 $I$ 代表单位矩阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1以外全都为0。如：$A{ {A}^{-1} }={ {A}^{-1} }A=I$对于单位矩阵，有$AI=IA=A$ 逆、转置矩阵的逆：如矩阵$A$是一个$m\\times m$矩阵（方阵），如果有逆矩阵，则：$A{ {A}^{-1} }={ {A}^{-1} }A=I$我们一般在OCTAVE或者MATLAB中进行计算矩阵的逆矩阵。矩阵的转置：设$A$为$m\\times n$阶矩阵（即$m$行$n$列），第$i $行$j $列的元素是$a(i,j)$，即：$A=a(i,j)$定义$A$的转置为这样一个$n\\times m$阶矩阵$B$，满足$B=a(j,i)$，即 $b (i,j)=a(j,i)$（$B$的第$i$行第$j$列元素是$A$的第$j$行第$i$列元素），记${ {A}^{T} }=B$。(有些书记为A’=B）直观来看，将$A$的所有元素绕着一条从第1行第1列元素出发的右下方45度的射线作镜面反转，即得到$A$的转置。例：${ {\\left| \\begin{matrix} a&amp; b \\ c&amp; d \\ e&amp; f \\\\end{matrix} \\right|}^{T} }=\\left|\\begin{matrix} a&amp; c &amp; e \\ b&amp; d &amp; f \\\\end{matrix} \\right|$矩阵的转置基本性质:$ { {\\left( A\\pm B \\right)}^{T} }={ {A}^{T} }\\pm { {B}^{T} } $${ {\\left( A\\times B \\right)}^{T} }={ {B}^{T} }\\times { {A}^{T} }$${ {\\left( { {A}^{T} } \\right)}^{T} }=A $${ {\\left( KA \\right)}^{T} }=K{ {A}^{T} } $matlab中矩阵转置：直接打一撇，x=y'。","link":"/2018/11/30/2018-11-30-线性代数回顾/"},{"title":"函数程序设计实验十一：词频统计","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126{-给定一个文本文件，构建文件中所有单词及其出现次数的词频表，并将词频表按照格式要求写到一个文件中。词频表按照单词出现次数从高到低次序排列，出现次数相同的按照字典序排列。第十四周上课提交。输入文件样例（见text0.txt ）：Mind-controlled MouseThe three study participants are part of a clinical trial to test a brain-computer interface (BCI) called BrainGate. BrainGate translates participant’s brain activity into commands that a computer can understand. In the new study, researchers first implanted microelectrode arrays into the area of the brain that governs hand movement. The participants trained the system by thinking about moving their hands, something the BCI learned to translate into actions on the screen.输出文件样例（见text0Fre.txt ）：the:8a:3into:3bci:2brain:2braingate:2of:2participants:2study:2that:2to:2about:1actions:1activity:1are:1area:1arrays:1brain-computer:1by:1called:1can:1clinical:1commands:1computer:1first:1governs:1hand:1hands:1implanted:1in:1interface:1learned:1microelectrode:1mind-controlled:1mouse:1movement:1moving:1new:1on:1part:1participant:1researchers:1screen:1something:1system:1test:1their:1thinking:1three:1trained:1translate:1translates:1trial:1understand:1建议：main ::IO main = do ls &lt;- readFile inputfile let result = string2listofpairs ls let formatedResult = formatting result writeFile formatedResult其中string2listofpairs :: String -&gt;[(String, Int)] -- 计算输入串中所有单词及其频率，并排序formatting :: [(String, Int)] -&gt;String -- 按照要求将词频列表转换为输出格式串几点注意事项：1. 大小写不敏感，所有结果用小写字母；2. It's 视为单词 it；3. brain-computer 视为一个单词。-}import System.IOimport Text.Printfimport Data.Charinputfile=\"text0.txt\"outputfile=\"text0Fre.txt\"main::IO()main=do ls&lt;-readFile inputfile let result = string2listofpairs ls let formatedResult=formatting result writeFile outputfile formatedResultstring2listofpairs::String-&gt;[(String,Int)]string2listofpairs s=sortG(cal(group(sortS(words(tolow s)))))sortS::[String]-&gt;[String]sortS []=[]sortS (x:xs)=(sortS[y|y&lt;-xs,y&lt;x])++[x]++(sortS[y|y&lt;-xs,x&lt;=y])cmp::(String,Int)-&gt;(String,Int)-&gt;Boolcmp (a,b) (c,d)= if b/=d then b&gt;d else a&lt;csortG::[(String,Int)]-&gt;[(String,Int)]sortG []=[]sortG (x:xs)=(sortG[y|y&lt;-xs,cmp y x])++[x]++(sortG[y|y&lt;-xs,cmp y x==False])group::[String]-&gt;[[String]]group []=[]group (x:xs)=[[x]++[y|y&lt;-xs,y==x]]++(group[y|y&lt;-xs,y/=x])tolow::String-&gt;Stringtolow []=[]tolow (x:xs)= if (isSpace x)||(isAlphaNum x)||(x=='-') then ((toLower x):(tolow xs)) else tolow xscal::[[String]]-&gt;[(String,Int)]cal []=[]cal (x:xs)=((x!!0,length x):(cal xs))formatting :: [(String, Int)] -&gt;String -- 按照要求将词频列表转换为输出格式串formatting []=[]formatting ((a,b):xs)=(printf \"%s:%d\\n\" a b)++(formatting xs)","link":"/2018/12/03/2018-12-03-词频统计/"},{"title":"函数程序设计实验十二：带变量的布尔表达式","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141module Lab3 whereimport Data.List{-一个布尔表达式就像一个算术表达式，只是这里的值都是布尔值True和False，其中的变量也只能代入布尔值，各种运算用运算表给出。布尔表达式的另一种解读是表示命题，如文件lab3.pdf所讲。如果不理解命题，就看作布尔表达式好了。本作业要求判断一个布尔表达式是不是永真式：即无论将变量代入什么值，其结果总是True。一、定义命题类型及其Show特例命题的集合可以如下定义-真命题(记作T)和假命题(记作F)是命题；-由一个字母表示的命题变元是一个命题；-如果P是命题,则它的否定是一个命题,记作~P；\"~\"称为否定联结词；-如果p,q是命题,则它们的合取是一个命题,记作p&amp;&amp;q; \"&amp;&amp;\"称为合取联结词；-如果p,q是命题,则它们的析取是一个命题,记作p||q; \"||\"称为析取联结词；-如果p,q是命题,则它们的蕴含是一个命题,记作p=&gt;q; \"=&gt;\"称为蕴含联结词；-所有的命题由以上规则经过有限步生成。所以,命题的集合是一个归纳定义的集合,可以用代数类型描述：-}data Prop=Const Bool | Var Char | Not Prop | And Prop Prop | Or Prop Prop | Imply Prop Prop deriving Eq{-习题1试将类型Prop定义成类Show的特例,使得Prop中元素能够显示成定义中我们习惯的表示。例如,Var 'A',And (Var 'P') (Var 'Q')分别显示成A和P&amp;&amp;Q等。-}instance Show Prop where show (Const True)=\"True\" show (Const False)=\"False\" show (Var x)=[x] show (Not x)=\"~\"++show x show (And x y)=(show x)++\"&amp;&amp;\"++(show y) show (Or x y)=(show x)++\"||\"++(show y) show (Imply x y)=(show x)++\"=&gt;\"++(show y){-习题2定义下列值p1,p2,p3::Prop使得它们个表示下列命题:A&amp;&amp;~AA||~AA=&gt;(A&amp;&amp;B)-}p1=And (Var 'A') (Not (Var 'A'))p2=Or (Var 'A') (Not (Var 'A'))p3=Imply (Var 'A') (And (Var 'A') (Var 'B')){-二、命题真值表一个命题或者真,或者假。例如,不包含变元的命题T表示真命题,命 题F表示假命题。包含变元的命题的真假依赖于变元表示命题的真假,所以,一个命题可以看作它包含的变元的函数,称为真值函数,其中每个变元的取 值为真或者假,分别用TVue和False表示。每个命题的取值和其中变元的关系可以用一个表来表示,称之为命题函数的真值表。以下是命题联结词的真值表：对应任意的命题函数，给定变元的一个代换，根据上述真值表可计算相应的真值。例如,命题p3:A=&gt;(A &amp;&amp; B)在代换[('A',True),('B',False)]的真值是False。我们可以用下列类型表示代换：-}type Subst=[(Char,Bool)]{-习题3试根据以上解释定义函数:-}eval::Subst-&gt;Prop-&gt;Bool{-例如&gt;eval [('A',True),('B',False)] p3False-}eval sub (Const p)=peval sub (Var p)=(getBool sub p) where getBool sub x= if length xs &gt;1 then error \"Variable has more than 2 values.\" else head xs where xs=[k|(y,k)&lt;-sub,x==y]eval sub (Not p)=not (eval sub p)eval sub (And p q)=(eval sub p)&amp;&amp;(eval sub q)eval sub (Or p q)=(eval sub p)||(eval sub q)eval sub (Imply p q)=((eval sub p)&amp;&amp;(eval sub q))||(not (eval sub p)){-习题4试定义下列函数：-}vars::Prop-&gt;[Char]substs::Prop-&gt;[Subst]{-其中vars p给出命题p中出现的所有不同变元,substs p给出命题p中变元的所有可能代换。例如vars p3=['A','B']substs p3= [ [('A',True),('B',True)], [('A',True),('B',False)], [('A',False),('B',True)], [('A',False),('B',False)] ]-}vars (Const x)=[]vars (Var x)=[x]vars (Not p)=vars pvars (And p q)=nub((vars p)++(vars q))vars (Or p q)=nub((vars p)++(vars q))vars (Imply p q)=nub((vars p)++(vars q))substs p=getsub (vars p) where getsub []=[] getsub [x]=[[(x,True)]]++[[(x,False)]] getsub (x:xs)=[(x,True):a|a&lt;-getsub(xs)]++[(x,False):a|a&lt;-getsub(xs)]{-三、定义一个判断命题是否永真的函数如果一个命题函数在变元的任意代换下真值是True,则称之为永真式。例如,命题p2是永真式。试定义判定一个命题是否永真式的函数,并说明你的函 数定义的正确性：习题5-}isTaut::Prop-&gt;Bool{-例如&gt;isTaut p1False&gt;isTaut p2True-}isTaut p=testisTaut p (substs p) where testisTaut p [x]=(eval x p) testisTaut p (x:xs)=if (eval x p) then testisTaut p xs else False","link":"/2018/12/11/2018-12-11-带变量的布尔表达式/"},{"title":"The Shortest Statement","text":"题目链接数据结构课上机碰到的题目，也太硬核了……题面上的特别条件m-n&lt;21是关键，要怎么用呢？先随便选一个点作为根建一棵树，那么分以下两种情况来讨论： 若s到t的最短路径不经过非树边，直接求出LCA就可以轻松得出答案。 若s到t的最短路径经过非树边，就可以直接用非树边的端点作为s到t的中转点来更新答案。由于非树边最多有21条，这样的特殊点最多有42个，直接预处理出这42个点到其它点的最短路就可以了。 这里建树直接写了一个树剖，方便后面求LCA。稀疏图上SPFA快的一比…… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF = 1e18;struct Graph{ struct Vertex { vector&lt;int&gt; o, i; int siz, dep, top, dfn; }; struct Edge : pair&lt;int, int&gt; { ll len; Edge(int x, int y, ll z) : pair&lt;int, int&gt;(x, y), len(z) {} }; vector&lt;Vertex&gt; v; vector&lt;Edge&gt; e; Graph(int n) : v(n) {} void add(const Edge &amp;ed) { v[ed.first].o.push_back(e.size()); v[ed.second].i.push_back(e.size()); e.push_back(ed); } int ch(int u, int i = 0) { return e[v[u].o[i]].second; } int fa(int u, int i = 0) { return e[v[u].i[i]].first; }};struct BellmanFord : Graph{ BellmanFord(int n) : Graph(n) {} void ask(int s, vector&lt;ll&gt; &amp;d) { d.assign(v.size(), INF); vector&lt;int&gt; flag(v.size(), d[s] = 0); for (deque&lt;int&gt; q(flag[s] = 1, s); !q.empty(); q.pop_front()) for (int u = q.front(), i = flag[u] = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, d[to] &gt; d[u] + e[k].len) { d[to] = d[u] + e[k].len; if (!flag[to]) flag[to] = 1, q.push_back(to); } }};struct TreeDiagram : BellmanFord{ TreeDiagram(const Graph &amp;g, int root) : BellmanFord(g.v.size()) { build(root, g); int cnt = v[root].dfn = v[root].dep = 1; dfs(v[root].top = root, cnt); } void build(int u, const Graph &amp;g) { v[u].siz = 1; for (int i = 0, k, to; i &lt; g.v[u].o.size(); ++i) if (k = g.v[u].o[i], to = g.e[k].second, !v[to].siz) { build(to, g); v[u].siz += v[to].siz; Graph::add(g.e[k]); if (v[ch(u)].siz &lt; v[to].siz) swap(v[u].o.front(), v[u].o.back()); } } void dfs(int u, int &amp;cnt) { for (int i = 0, to; i &lt; v[u].o.size(); ++i) { v[to = ch(u, i)].dfn = ++cnt; v[to].top = i ? to : v[u].top; v[to].dep = v[u].dep + 1; dfs(to, cnt); } } int lca(int x, int y) { for (; v[x].top != v[y].top; x = fa(v[x].top)) if (v[v[x].top].dep &lt; v[v[y].top].dep) swap(x, y); if (v[x].dep &lt; v[y].dep) swap(x, y); return y; }};int main(){ int n, m; scanf(\"%d%d\", &amp;n, &amp;m); BellmanFord g(n + 1); for (int i = 0, x, y, z; i &lt; m; ++i) { scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); g.add({x, y, z}); g.add({y, x, z}); } TreeDiagram t(g, 1); vector&lt;ll&gt; d[63]; for (int i = m = 0; i &lt; n; ++i) if (t.v[i].o.size() + t.v[i].i.size() &lt; g.v[i].o.size()) g.ask(i, d[m++]); t.ask(1, d[m]); scanf(\"%d\", &amp;n); for (int i = 0, x, y; i &lt; n; ++i) { scanf(\"%d%d\", &amp;x, &amp;y); ll ans = d[m][x] + d[m][y] - 2 * d[m][t.lca(x, y)]; for (int j = 0; j &lt; m; ++j) ans = min(ans, d[j][x] + d[j][y]); printf(\"%lld\\n\", ans); }}","link":"/2018/12/12/2018-12-12-CodeForces-1051F/"},{"title":"Windows Subsystem for Linux入门：安装+配置图形界面+中文环境+vscode","text":"什么是WSL Windows Subsystem for Linux（简称WSL）是一个为在Windows 10上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，目标是使纯正的Ubuntu 14.04 “Trusty Tahr”映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。 以上来自百度百科。简单来说，WSL是以软件的形式运行在Windows下的子系统。先来看一下我的最终完成效果吧，其实和真正的Linux已经很接近了。 相对于虚拟机的优势相比于VMware等虚拟机，WSL占用内存和CPU资源更少，在WSL上运行软件的消耗和直接在Windows上差不多。而且，Windows下可以直接访问WSL的环境。 相对于多系统的优势省事呀。假如需要重启Linux系统，WSL只需要把软件关掉重开即可。同时，相较于多系统，文件交互也更为简单。 安装官方教程地址，可以看到还是很简单的。 本文大部分内容写于18/12/14，所用的机器是VAIO Z Flip 2016，处理器i7-6567U，内存8G，操作系统版本号Windows 10.0.17763.134 x64。可以看到即使是以轻薄本的配置也足够流畅完成下述环节。 开启WSL可选特性在控制面板的“启动或关闭Windows功能”中勾选“适用于Linux的Windows子系统”。或在PowerShell 中运行下述代码： 1Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 修改完毕后，重启使选项生效。 下载安装打开Microsoft Store，搜索Linux，就会显示Ubuntu、suse等几个发行版，点击进行安装即可。这里选择了Ubuntu。下载之后启动菜单里就会出现Ubuntu的图标了。让我们启动它，按照上面的提示等待几分钟，就可以进入初次登陆设置账号的界面。好像用户名不可以有大写字母…不管怎样，到这里就算安装成功了。 配置图形界面WSL没有原生支持GUI的。这里通过XServer实现可视化操作，用到的软件是VcXsrv。 实现原理 VcXsrv启动Xserver服务用于监听； WSL启动程序后把界面数据发送给Xserver； Xserver接收到数据进行绘制，于是在Win下看到图形界面。 这里给出了另外一种通过VNC远程控制的解决方案，可能会比XServer流畅一些。 下载并安装VcXsrv点这里下载安装包，一路next即可。第一步是选择组件，默认是全部安装；第二步是安装路径。 启动VcXsrv开始菜单里现在出现了一个文件夹VcXsrv，选择里面的XLaunch，一路选择下一步即可。然后这个软件就后台运行了。之后如果有需要使用Linux的图形界面的，都需要提前打开XLaunch。提一下打开Xlaunch后第一页的四个选项设置，我个人是喜欢选择全屏的，最接近原生系统的体验。假如你不需要打开完整的桌面环境而只需要图形化某些软件，那么就用默认的Multiple windows也不错。 配置DISPLAY为了方便，打开Ubuntu bash，运行如下代码： 1echo \"export DISPLAY=:0.0\" &gt;&gt; ~/.bashrc 这样，每次打开图形界面程序就不需要额外指定DISPLAY了。 切换源默认源速度缓慢，这里切换到阿里源。 1sudo vim /etc/apt/sources.list 使用vim打开，参考这里。在vim中输入如下的控制代码（需要先熟悉上古神器vim的操作）： 12:%s/security.ubuntu/mirrors.aliyun/g:%s/archive.ubuntu/mirrors.aliyun/g 保存并退出。执行一下以下代码更新软件包到最新状态。 Remark:在sudo apt upgrade之前要先sudo apt update 感谢@在评论区指出 12sudo apt updatesudo apt upgrade 检验运行下述代码，安装firefox检验效果： 1sudo apt install firefox 随后直接运行下述代码即可查看效果。 1firefox 可以看到，这里虽然能正常打开网页，但是中文显示是乱码的。 解决中文乱码问题运行下述代码，成功解决。现在可以正常显示中文了。 1sudo apt install fonts-noto-cjk 修改默认语言环境为中文（可选）安装中文语言包 1sudo apt install language-pack-zh-hans language-pack-zh-hans-base 设置本地化环境变量 1echo \"LANG=zh_CN.UTF-8\" &gt;&gt; ~/.profile 安装桌面这里选择xfce4桌面，它的优点是轻量、美观、占用系统资源少。 1sudo apt install xfce4 dbus-x11 完成后，执行下面这段代码就可以看到桌面的图形界面了。 1xfce4-session 中文输入法12sudo apt install fcitx fcitx-pinyinecho -e \"export XMODIFIERS=@im=fcitx\\nexport GTK_IM_MODULE=fcitx\\nexport QT_IM_MODULE=fcitx\\n\" &gt;&gt; .profile 软件包已装，在应用程序 - 设置 - 会话与启动 - 应用程序自启动，添加 /usr/bin/fcitx。 配置工作环境这里以安装、配置vscode为例。vscode宇宙第一！ 安装umake123sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-makesudo apt updatesudo apt install ubuntu-make 安装vscode1sudo umake ide visual-studio-code 执行后分别会让你选择安装地址，然后输入a确认。稍等片刻就安装好啦。重启bash，重新进入xfce桌面，在应用程序-开发里就可以找到安装好的vscode啦。安装Setting Sync来同步别的平台的设置吧。设置好自己用于同步vscode设置的GitHub Token和GitHub Gist，一起来喝上一杯咖啡吧。现在你可以把很多事迁到WSL内来做了（折腾才是最好玩的），丢开虚拟机和双系统吧。完结撒花~","link":"/2019/04/11/2018-12-14-Windows Subsystem for Linux/"},{"title":"2018-2019 ICPC, NEERC, Southern Subregional Contest","text":"Find a NumberBFS搜索并保存路径，维护两维数据：走到当前位置时的余数和总和。 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 511, M = 5111;int d, s, vis[N][M], prex[N][M], prey[N][M], val[N][M];void print(int x, int y){ if (x == 0 &amp;&amp; y == 0) return; print(prex[x][y], prey[x][y]); printf(\"%d\", val[x][y]);}int main(){ scanf(\"%d%d\", &amp;d, &amp;s); val[0][s] = -1; for (deque&lt;pair&lt;int, int&gt;&gt; q(vis[0][0] = 1); !q.empty(); q.pop_front()) for (int x = q.front().first, y = q.front().second, i = 0; i &lt;= 9; ++i) { int xx = (10 * x + i) % d, yy = y + i; if (vis[xx][yy] || yy &gt; s) continue; vis[xx][yy] = 1; val[xx][yy] = i; prex[xx][yy] = x; prey[xx][yy] = y; q.push_back(make_pair(xx, yy)); } print(0, s);} Cloud Computing线段树，现场被奇奇怪怪的思路搞到自闭了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 9;struct Node{ int c, p;} a[N];struct Tree{ ll x, size;} t[N * 4];int v[N], w[N], nex[N], g[N], tot;void add(int x, int y, int z){ v[++tot] = y; w[tot] = z; nex[tot] = g[x]; g[x] = tot;}void ins(int x, int l, int r, int p, int q){ if (l == r) { t[x].size += q; t[x].x += q * 1ll * l; return; } int mid = (l + r) &gt;&gt; 1; if (p &lt;= mid) ins(x &lt;&lt; 1, l, mid, p, q); else ins(x &lt;&lt; 1 | 1, mid + 1, r, p, q); t[x].size = t[x &lt;&lt; 1].size + t[x &lt;&lt; 1 | 1].size; t[x].x = t[x &lt;&lt; 1].x + t[x &lt;&lt; 1 | 1].x;}ll get(int x, int l, int r, int p){ if (t[x].size &lt;= p) return t[x].x; if (l == r) return l * 1ll * p; int mid = (l + r) &gt;&gt; 1; if (t[x &lt;&lt; 1].size &gt;= p) return get(x &lt;&lt; 1, l, mid, p); else return get(x &lt;&lt; 1, l, mid, t[x &lt;&lt; 1].size) + get(x &lt;&lt; 1 | 1, mid + 1, r, p - t[x &lt;&lt; 1].size);}int main(){ int n, m, k; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1, x, y; i &lt;= k; i++) { scanf(\"%d%d%d%d\", &amp;x, &amp;y, &amp;a[i].c, &amp;a[i].p); add(x, i, 1); add(y + 1, i, -1); } ll ans = 0, last = 0; for (int i = 1; i &lt;= n; i++) { bool p = 1; for (int j = g[i]; j; j = nex[j]) { p = 0; ins(1, 1, 1e6, a[v[j]].p, a[v[j]].c * w[j]); } if (p) ans += last; else { last = get(1, 1, 1e6, m); ans += last; } } printf(\"%lld\", ans);} Garbage Disposal123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n, k, ans;int main(){ scanf(\"%lld%lld\", &amp;n, &amp;k); for (ll i = 0, a, pre = 0; i &lt; n; ++i) { scanf(\"%lld\", &amp;a); ans += pre / k; pre %= k; if (pre &gt; 0) pre -= k, ++ans; pre += a; if (pre &lt; 0) pre = 0; ans += pre / k; pre %= k; if (i == n - 1 &amp;&amp; pre &gt; 0) ++ans; } printf(\"%lld\", ans);} Debate1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e5 + 9;int n, ans, t[4], a[N], b[N], c[N * 2];int main(){ scanf(\"%d\", &amp;n); for (int i = 1, x, y; i &lt;= n; ++i) { scanf(\"%d%d\", &amp;x, &amp;y); if (x == 11) ++t[3], ans += y; if (x == 10) a[++t[2]] = y; if (x == 1) b[++t[1]] = y; if (x == 0) c[++t[0]] = y; } sort(a + 1, a + 1 + t[2], greater&lt;int&gt;()); sort(b + 1, b + 1 + t[1], greater&lt;int&gt;()); int mi = min(t[2], t[1]); for (int i = 1; i &lt;= mi; ++i) ans += a[i] + b[i]; if (t[2] &gt; t[1]) for (int i = mi + 1; i &lt;= t[2]; ++i) c[++t[0]] = a[i]; else if (t[2] &lt; t[1]) for (int i = mi + 1; i &lt;= t[1]; ++i) c[++t[0]] = b[i]; sort(c + 1, c + 1 + t[0], greater&lt;int&gt;()); for (int i = 1; i &lt;= t[3]; ++i) ans += c[i]; printf(\"%d\", ans);} BerOS File Suggestion12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;unordered_map&lt;string, pair&lt;int, string&gt;&gt; mp;string s;int n;int main(){ for (cin &gt;&gt; n; n--;) { cin &gt;&gt; s; unordered_set&lt;string&gt; st; for (int i = 0; i &lt; s.size(); ++i) for (int j = i; j &lt; s.size(); ++j) st.insert(s.substr(i, j - i + 1)); for (auto it : st) { pair&lt;int, string&gt; &amp;pis = mp[it]; if (++mp[it].first == 1) mp[it].second = s; } } for (cin &gt;&gt; n; n--;) { cin &gt;&gt; s; pair&lt;int, string&gt; &amp;pis = mp[s]; cout &lt;&lt; pis.first &lt;&lt; ' ' &lt;&lt; (!pis.second.empty() ? pis.second : \"-\") &lt;&lt; '\\n'; }} Video Posts12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 9;int n, k, s, m, a[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;a[i]), s += a[i]; if (s % k) return printf(\"No\"), 0; m = s / k; vector&lt;int&gt; v; for (int i = s = 0, pre = -1; i &lt; n; ++i) { s += a[i]; if (s &gt; m) return printf(\"No\"), 0; if (s == m) v.push_back(i - pre), pre = i, s = 0; } printf(\"Yes\\n\"); for (int i = 0; i &lt; v.size(); ++i) printf(\"%d \", v[i]);}","link":"/2019/01/20/2019-01-20-2018-2019 ICPC, NEERC, Southern Subregional Contest/"},{"title":"ZOJ Monthly, January 2019","text":"只做了AEI三题，还是太菜了… Little Sub and Pascal’s Triangle打表快乐找规律……发现的规律是，对于答案序列中每连续的1&lt;&lt;n个数，后一半序列是由前一半的序列乘二得到的。于是可以直接根据k的二进制得到答案。 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;long long t, k, a;int main(){ for (scanf(\"%lld\", &amp;t); t--; printf(\"%lld\\n\", a)) { scanf(\"%lld\", &amp;k); for (k -= a = 1; k; k &gt;&gt;= 1) if (k &amp; 1) a &lt;&lt;= 1; }} Little Sub and his Geometry Problem容易发现，对于某个固定的询问C，符合要求的点一定是随着X增加Y减少，于是使用X、Y方向的双指针维护答案。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 7;int t, n, k, q, ans;int main(){ for (scanf(\"%d\", &amp;t); t--;) { scanf(\"%d%d\", &amp;n, &amp;k); vector&lt;vector&lt;int&gt;&gt; e(n + 1); for (int i = 0, x, y; i &lt; k; ++i) scanf(\"%d%d\", &amp;x, &amp;y), e[x].push_back(y); for (scanf(\"%d\", &amp;q); q--; printf(\"%d%c\", ans, q ? ' ' : '\\n')) { ll c, x = 1, y = n, cnt = ans = 0, sum = 0; vector&lt;int&gt; cnty(n + 1), sumy(n + 1); for (scanf(\"%lld\", &amp;c); x &lt;= n; ++x) { for (auto u : e[x]) if (u &lt;= y) ++cnt, ++cnty[u], sum += x + u, sumy[u] += x + u; for (; (x + y) * cnt - sum &gt; c; --y) cnt -= cnty[y], sum -= sumy[y]; if ((x + y) * cnt - sum == c) ++ans; } } }} Little Sub and Mr.Potato’s Math Problem十分不熟悉的数位DP，现场做了很久……以后要多多练习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct POW : vector&lt;ll&gt;{ POW(int x, int n) : vector&lt;ll&gt;(n, 1) { for (int i = 1; i &lt; size(); ++i) at(i) = at(i - 1) * x; }} POW10(10, 19);struct DP{ vector&lt;ll&gt; f; ll sum; DP(const vector&lt;ll&gt; &amp;d) : f(d.size()), sum(0) { for (int i = 0; i &lt; d.size(); ++i) { for (int j = f[i] = 0; j &lt;= i; ++j) f[i] += (d[j] - (j == 0)) * POW10[i - j]; sum += f[i] + 1; } }};ll cal(ll n, ll k, ll s, ll len){ if (n &gt; s * POW10[len]) return cal(n - s * POW10[len], k, s, len + 1); return (n / POW10[len] + POW10[ll(log10(k))]) * POW10[len] + n % POW10[len] - 1;}int main(){ ll t, k, m; for (scanf(\"%lld\", &amp;t); t--;) { scanf(\"%lld%lld\", &amp;k, &amp;m); vector&lt;ll&gt; d; for (ll n = k; n; n /= 10) d.push_back(n % 10); reverse(d.begin(), d.end()); DP dp(d); printf(\"%lld\\n\", m == dp.sum ? k : m &lt; dp.sum || k == *lower_bound(POW10.begin(), POW10.end(), k) ? 0 : cal(m - dp.sum, k, dp.f.back(), 1)); }} Little Sub and Isomorphism Sequences容易看出求最大的k就是求两个相同元素下标差的最大值，用一个set维护即可。为了求稳使用了离散化处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define MP(i) make_pair(vs[i].size() &lt; 2 ? -1 : *vs[i].rbegin() - *vs[i].begin(), i)using namespace std;typedef int ll;struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }};ll getll(FILE *in = stdin){ ll val = 0, sgn = 1, ch = getc(in); for (; !isdigit(ch) &amp;&amp; ch != EOF; ch = getc(in)) if (ch == '-') sgn = -sgn; for (; isdigit(ch); ch = getc(in)) val = val * 10 + ch - '0'; return ungetc(ch, in), sgn * val;}int main(){ for (ll t = getll(); t--;) { ll n = getll(), m = getll(); Ranker input; for (int i = 0; i &lt; n; ++i) input.push_back(getll()); for (int i = 0; i &lt; m; ++i) { input.push_back(getll()); if (input.back() == 1) { input.push_back(getll()); input.push_back(getll()); } } Ranker::iterator it = input.begin(); Ranker rk(input), a; rk.init(); vector&lt;set&lt;int&gt;&gt; vs(rk.size()); for (int i = 0; i &lt; n; ++i) { a.push_back(rk.ask(*(it++))); vs[a.back()].insert(i); } set&lt;pair&lt;int, int&gt;&gt; q; for (int i = 0; i &lt; vs.size(); ++i) q.insert(MP(i)); for (int i = 0; i &lt; m; ++i) { if (*(it++) == 1) { ll x = *(it++) - 1; q.erase(MP(a[x])); vs[a[x]].erase(x); q.insert(MP(a[x])); a[x] = rk.ask(*(it++)); q.erase(MP(a[x])); vs[a[x]].insert(x); q.insert(MP(a[x])); } else printf(\"%d\\n\", q.rbegin()-&gt;first); } }}","link":"/2019/01/19/2019-01-19-ZOJ Monthly, January 2019/"},{"title":"C++语言相关","text":"GCC内置位运算12345int __builtin_clz(unsigned int x); //求前缀0的个数int __builtin_ctz(unsigned int x); //求后缀0的个数int __builtin_ffs(unsigned int x); //x的二进制末尾最后一个1的位置，从1开始int __builtin_popcount(unsigned int x); //x二进制中1的个数，相当于bitset::count()int __builtin_parity(unsigned int x); //判断x的二进制中1的个数的奇（1）偶（0）性，这些函数都有相应的usigned long和usigned long long版本，只需要在函数名后面加上l或ll就可以了，比如__builtin_clzll 开栈For C++1#pragma comment(linker, \"/STACK:102400000,102400000\") //For C++ For G++123456int main() //For G++{ int size = 256 &lt;&lt; 20; //256MB char *p = (char *)malloc(size) + size; __asm__ __volatile__(\"movq %0, %%rsp\\n\" ::\"r\"(p)); //64bit，一定要最后写一句`exit(0);`退出程序，否则会得到非零退出的错误，可能RE。} 读入优化C文件指针版12345678910111213141516171819ll getll(FILE *in = stdin){ ll val = 0, sgn = 1, ch = getc(in); for (; !isdigit(ch) &amp;&amp; ch != EOF; ch = getc(in)) if (ch == '-') sgn = -sgn; for (; isdigit(ch); ch = getc(in)) val = val * 10 + ch - '0'; return ungetc(ch, in), sgn * val;}lf getlf(FILE *in = stdin){ lf val = getll(in), p = val &lt; 0 ? -1 : 1; ll ch = getc(in); if (ch == '.') for (ch = getc(in); isdigit(ch); ch = getc(in)) val += (p /= 10) * (ch - '0'); return ungetc(ch, in), val;} 仿C++IO流沙雕版使用前 使用后 12345678910111213141516171819202122232425262728293031323334#define cin kinstruct Istream{ char b[20 &lt;&lt; 20], *i, *e; //20MB Istream(FILE *in) : i(b), e(b + fread(b, sizeof(*b), sizeof(b) - 1, in)) {} bool eof() const { return i == e; } Istream &amp;operator&gt;&gt;(long long &amp;val) { return val = strtoll(i, &amp;i, 10 /*进制，取值2~36*/), *this; } Istream &amp;operator&gt;&gt;(ll &amp;val) //极限快 { while (*i &lt; '0') ++i; //无符号 for (val = 0; *i &gt;= '0'; ++i) val = (val &lt;&lt; 3) + (val &lt;&lt; 1) + *i - '0'; return *this; } Istream &amp;operator&gt;&gt;(double &amp;val) { return val = strtod(i, &amp;i), *this; } Istream &amp;operator&gt;&gt;(string &amp;s) { while (!eof() &amp;&amp; isspace(*i)) ++i; for (s.clear(); !eof() &amp;&amp; !isspace(*i); ++i) s += *i; return *this; }} kin(stdin);","link":"/2019/02/03/2019-02-03-C++语言相关/"},{"title":"2018-2019 Russia Open High School Programming Contest","text":"Company Merging12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n, ma, ans, t;int main(){ scanf(\"%lld\", &amp;n); for (ll i = 0, z; i &lt; n; ++i) { scanf(\"%lld\", &amp;z); ll ma2 = 0; for (ll j = 0, x; j &lt; z; ++j) { scanf(\"%lld\", &amp;x); ma2 = max(ma2, x); } if (ma &lt; ma2) ans += t * (ma2 - ma); else if (ma &gt; ma2) ans += z * (ma - ma2); ma = max(ma, ma2); t += z; } printf(\"%lld\", ans);} LaTeX Expert坑题，下面的引用可能会有多行。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const string BEGIN(\"\\\\begin{thebibliography}{99}\"), END(\"\\\\end{thebibliography}\");unordered_map&lt;string, string&gt; mp;vector&lt;string&gt; text, bibitem;int main(){ for (string s; cin &gt;&gt; s, s != BEGIN;) if (s.find(\"\\\\cite{\") != s.npos) { s = s.substr(s.find('{') + 1); s.erase(s.find('}')); text.push_back(s); } for (string s, t, *p = &amp;t; getline(cin, s), s != END;) { if (s.find(\"\\\\bibitem{\") != s.npos) { s = s.substr(s.find('{') + 1); t = s.substr(s.find('}') + 1); s.erase(s.find('}')); bibitem.push_back(s); p = &amp;mp[s]; *p = t; } else *p += '\\n' + s; } if (text == bibitem) return cout &lt;&lt; \"Correct\", 0; cout &lt;&lt; \"Incorrect\\n\" &lt;&lt; BEGIN &lt;&lt; '\\n'; for (int i = 0; i &lt; text.size(); ++i) cout &lt;&lt; \"\\\\bibitem{\" &lt;&lt; text[i] &lt;&lt; \"}\" &lt;&lt; mp[text[i]] &lt;&lt; \"\\n\"; cout &lt;&lt; END;} Similar Arrays1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 9;int a[N], v[N * 2], nex[N * 2], g[N], d[N], tot, n, m, p[N];void add(int x, int y){ v[++tot] = y, nex[tot] = g[x], g[x] = tot, ++d[x];}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); if (n == 1 || n == 2 &amp;&amp; m) return printf(\"NO\"), 0; for (int i = 0, x, y; i &lt; m; ++i) { scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); } int t1 = 0, t2 = 0; for (int i = 1; i &lt;= n; ++i) if (d[i] != n - 1) { t1 = i; for (int j = 1; j &lt;= n; ++j) p[j] = 0; p[i] = 1; for (int j = g[i]; j; j = nex[j]) p[v[j]] = 1; for (int j = 1; j &lt;= n; ++j) if (!p[j]) { t2 = j; break; } break; } if (!t1) return printf(\"NO\\n\"), 0; printf(\"YES\\n\"); a[t1] = n; a[t2] = n - 1; for (int i = 1, t = 0; i &lt;= n; ++i) if (!a[i]) a[i] = ++t; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]); printf(\"\\n\"); a[t1] = n - 1; for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]);} Minimal Product现场调到自闭的一题，该用unsigned的地方不能用long long代替。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF = 5e18, N = 1e7 + 7;ll l, r, a[N];unsigned t, n, x, y, z, b[N];int main(){ for (scanf(\"%u\", &amp;t); t--;) { scanf(\"%u%lld%lld%u%u%u%u%u\", &amp;n, &amp;l, &amp;r, &amp;x, &amp;y, &amp;z, &amp;b[1], &amp;b[2]); ll ans = INF, mi = INF, ma = -INF; for (ll i = 1; i &lt;= n; ++i) { if (i &gt; 2) b[i] = b[i - 2] * x + b[i - 1] * y + z; a[i] = b[i] % (r - l + 1) + l; if (mi &lt; a[i]) ans = min(ans, mi * a[i]); else mi = a[i]; } for (ll i = n; i; --i) { if (ma &gt; a[i]) ans = min(ans, ma * a[i]); else ma = a[i]; } if (ans &lt; INF) printf(\"%lld\\n\", ans); else printf(\"IMPOSSIBLE\\n\"); }} Right Expansion Of The Mind感兴趣具有传递性。两个人感兴趣，当仅当： 两人的t串具有相同的字符集 对于两个人的s串，分别删去能够包含在t串字符集的最长后缀后相等。 按照a~z是否出现分别对应二进制串中的每一位给t串的字符集编码，按这个编码给所有人分类，然后在每个分类里讨论分组情况即可。map套map套vector实现。疯了呀。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 9;unordered_map&lt;int, unordered_map&lt;string, vector&lt;int&gt;&gt;&gt; mp;char s[N], t[N];int n, m, ans;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(\"%s%s\", s, t); for (int i = m = 0; t[i]; ++i) m |= 1 &lt;&lt; t[i] - 'a'; for (int i = strlen(s) - 1; ~i; --i) { if (m &amp; 1 &lt;&lt; s[i] - 'a') s[i] = 0; else break; } mp[m][s].push_back(i); } for (auto mpi : mp) ans += mpi.second.size(); printf(\"%d\\n\", ans); for (auto mpi : mp) for (auto mpii : mpi.second) { printf(\"%d\", mpii.second.size()); for (auto mpiii : mpii.second) printf(\" %d\", mpiii); printf(\"\\n\"); }} Berland University1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool check(ll x, ll t1, ll t2, ll a, ll b, ll k){ if (a &gt; x) a = x; if (b &gt; x) b = x; ll tt1 = t1 * a / x + t2 * b / x, tt2 = t1 * a % x + t2 * b % x; if (tt2 &gt;= x) tt1++; return tt1 &gt;= k;}int main(){ ll t, n, a, b, k; scanf(\"%lld%lld%lld%lld%lld\", &amp;t, &amp;n, &amp;a, &amp;b, &amp;k); ll t1 = (n + 1) / 2, t2 = n / 2, l = 1, r = t, ans = 0; while (l &lt;= r) { ll mid = (l + r) &gt;&gt; 1; if (check(mid, t1, t2, a, b, k)) { ans = mid; l = mid + 1; } else r = mid - 1; } printf(\"%lld\", ans);} The Pleasant Walk1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 7;int n, m, ans, a[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = 1, t = 0; i &lt;= n; ++i) { if (t &amp;&amp; a[i] == a[i - 1]) t = 0; ans = max(ans, ++t); } printf(\"%d\", ans);}","link":"/2019/01/22/2019-01-22-2018-2019 Russia Open High School Programming Contest/"},{"title":"2018 ICPC Asia Jakarta Regional Contest","text":"# [Edit Distance](https://vjudge.net/problem/Gym-102001A) undefined # [Icy Land](https://vjudge.net/problem/Gym-102001D) undefined # [Popping Balloons](https://vjudge.net/problem/Gym-102001F) undefined # [Go Make It Complete](https://vjudge.net/problem/Gym-102001G) 二分+贪心大暴力居然苟过去了… undefined # [Lexical Sign Sequence](https://vjudge.net/problem/Gym-102001H) undefined # [Lie Detector](https://vjudge.net/problem/Gym-102001I) undefined # [Future Generation](https://vjudge.net/problem/Gym-102001J) undefined # [Binary String](https://vjudge.net/problem/Gym-102001L) undefined","link":"/2019/01/24/2019-01-24-2018 ICPC Asia Jakarta Regional Contest/"},{"title":"线性代数","text":"矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Matrix{ static int n; //方阵代替矩阵 ll a[N][N]; Matrix(ll k = 0) { for (int i = 0; i &lt; n; ++i) fill(a[i], a[i] + n, 0), a[i][i] = k; } friend Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) { Matrix r(0); for (int i = 0; i &lt; r.n; ++i) for (int j = 0; j &lt; r.n; ++j) for (int k = 0; k &lt; r.n; ++k) r.a[i][j] = M.add(r.a[i][j], M.mul(a.a[i][k], b.a[k][j])); return r; } friend Matrix pow(Matrix a, ll b) { Matrix r(1); for (; b; b &gt;&gt;= 1, a = a * a) if (b &amp; 1) r = r * a; return r; } friend ll det(Matrix a) //矩阵a的n阶行列式 { ll ans = 1; for (int i = 0; i &lt; a.n; ++i) { for (int j = i + 1; j &lt; a.n; ++j) while (fabs(a[j][i]) &gt; EPS) { ll t = a[i][i] / a[j][i]; for (int k = i; k &lt; n; ++k) a[i][k] -= t * a[j][k], swap(a[i][k], a[j][k]); } if (fabs(ans *= a[i][i]) &lt; EPS) return 0; } return ans; }};//int Matrix::n=N; 高斯消元1234567891011121314151617181920212223struct GaussElimination : Matrix{ void ask() //a为增广矩阵，要求n*n的系数矩阵可逆，运行结束后a[i][n]为第i个未知数的值 { for (int i = 0, r; i &lt; n; ++i) { for (int j = r = i; j &lt; n; ++j) if (fabs(a[r][i]) &lt; fabs(a[j][i])) r = j; if (r != i) swap_ranges(a[r], a[r] + n + 1, a[i]); for (int j = n; j &gt;= i; --j) for (int k = i + 1; k &lt; n; ++k) a[k][j] -= a[k][i] * a[i][j] / a[i][i]; } for (int i = n - 1; ~i; --i) { for (int j = i + 1; j &lt; n; ++j) a[i][n] -= a[j][n] * a[i][j]; a[i][n] /= a[i][i]; } }}; 线性基向量线性基add返回要插入的向量z是否与已插入的线性无关。 123456789101112131415161718struct Base{ vector&lt;vector&lt;double&gt;&gt; v; Base(int N) : v(N, vector&lt;double&gt;(N, 0)) {} //R^N的子空间 bool add(vector&lt;double&gt; x) { for (int i = 0; i &lt; x.size(); ++i) if (fabs(x[i]) &gt; EPS) { if (fabs(v[i][i]) &lt; EPS) return v[i] = x, 1; double t = x[i] / v[i][i]; for (int j = 0; j &lt; x.size(); ++j) x[j] -= t * v[i][j]; } return 0; }}; 异或线性基若要查询第k小子集异或和，则把k写成二进制，对于是1的第i位，把从低位到高位第i个不为0的数异或进答案。若要判断是否有非空子集的异或和为0，如果不存在自由基，那么说明只有空集的异或值为0，需要高斯消元来判断。 1234567891011121314151617181920212223242526272829303132struct BaseXOR{ vector&lt;ll&gt; a; BaseXOR() : a(64, 0) {} ll ask() //查询最大子集异或和 { ll t = 0; for (int i = a.size() - 1; ~i; --i) t = max(t, t ^ a[i]); return t; } bool add(ll x) { for (int i = a.size() - 1; ~i; --i) if (x &gt;&gt; i &amp; 1) { if (a[i]) x ^= a[i]; else return a[i] = x, 1; } return 0; } bool check(ll x) //判断一个数是否能够被异或出，0根据需要特判 { for (int i = a.size() - 1; ~i; --i) if (x &gt;&gt; i &amp; 1) if (x ^= a[i], !x) return 1; return 0; }};","link":"/2019/02/03/2019-02-03-线性代数/"},{"title":"组合数学","text":"组合数取模使用示例 为方便，记$C(n,m)=C_n^m=\\binom{n}{m}$。 12345678910111213141516171819202122struct Factorial : Mod{ vector&lt;ll&gt; fac, ifac; Factorial(int N, ll M) : fac(N, 1), ifac(N, 1), Mod(M) { for (int i = 2; i &lt; N; ++i) fac[i] = mul(fac[i - 1], i), ifac[i] = mul(M - M / i, ifac[M % i]); for (int i = 2; i &lt; N; ++i) ifac[i] = mul(ifac[i], ifac[i - 1]); } ll c(int n, int m) { return mul(mul(fac[n], ifac[m]), ifac[n - m]); } ll lucas(ll n, ll m) //卢卡斯定理求C(n,m)%M，适用于模数M小于N的情况，或者m较小的时候也可以暴力求 { if (!m) return 1; if (n &lt; m || n % M &lt; m % M) return 0; if (n &lt; M &amp;&amp; m &lt; M) return c(n, m); return mul(lucas(n / M, m / M), lucas(n % M, m % M)); }}; 组合数LCM$(n + 1)lcm(C(n,0),C(n,1),\\ldots,C(n,k))=lcm(n+1,n,n−1,n−2,\\ldots,n−k+1)$ 区间lcm的维护：对于一个数，将其分解质因数，若有因子$p^k$，那么拆分出k个数 $p^1,p^2,\\ldots,p^k$，权值都为p，那么区间$[l,r]$内所有数的lcm的答案=所有在该区间中出现过的数的权值之积，可持久化线段树维护之。 Stirling数第一类斯特林数第一类斯特林数$S(p,k)$的一个的组合学解释是：将p个物体排成k个非空循环排列的方法数。 递推公式：$S(p,k)=(p−1)S(p−1,k)+S(p−1,k−1),1\\leq k\\leq p−1;S(p,0)=0,p\\ge1;S(p,p)=1,p\\ge0$ 第二类斯特林数第二类斯特林数$S(p,k)$的一个的组合学解释是：将p个物体划分成k个非空不可辨别的（可以理解为盒子没有编号）集合的方法数。 递推公式：$S(p,k)=kS(p−1,k)+S(p−1,k−1),1\\leq k\\leq p−1;S(p,0)=0,p\\ge 1;S(p,p)=1,p\\ge0$ 卷积形式：$S(n,m)=\\frac{1}{m!}\\sum_{k=0}^m(-1)^kC(m,k)(m-k)^n=\\sum_{k=0}^m\\frac{(-1)^k}{k!}\\frac{(m-k)^n}{(m-k)!}$ 同时有转化：$x^k=\\sum_{i=1}^ki!C(x,i)S(k,i)$ 斯特林近似公式$n!\\approx\\sqrt{2\\pi n}(\\frac{n}{e})^n$ 小球入盒模型通解 k个球 m个盒子 空盒子 方案数 各不相同 各不相同 允许 $m^k$ 各不相同 各不相同 无 $m!Stirling2(k,m)$ 各不相同 完全相同 允许 $\\sum_{i=1}^mStirling2(k,i)$ 各不相同 完全相同 无 $Stirling2(k,m)$ 完全相同 各不相同 允许 $C(m+k−1,k)$ 完全相同 各不相同 无 $C(k−1,m−1)$ 完全相同 完全相同 允许 $\\frac{1}{(1−x)(1−x^2)…(1−x^m)}的x^k项的系数$ 完全相同 完全相同 无 $\\frac{x^m}{(1−x)(1−x^2)…(1−x^m)}的x^k项的系数$ 置换使用示例 12345678910111213141516171819202122232425262728293031struct Permutation : vector&lt;int&gt;{ Permutation(int n = 0) : vector&lt;int&gt;(n) {} friend Permutation operator*(const Permutation &amp;f, const Permutation &amp;g) { Permutation ans(f.size()); for (int i = 0; i &lt; f.size(); ++i) ans[i] = g[f[i]]; return ans; } friend Permutation inv(const Permutation &amp;f) { Permutation ans(f.size()); for (int i = 0; i &lt; f.size(); ++i) ans[f[i]] = i; return ans; } friend vector&lt;vector&lt;int&gt;&gt; cycle(const Permutation &amp;f) { vector&lt;int&gt; vis(f.size(), 0); vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; f.size(); ++i) if (!vis[i]) { ans.push_back(vector&lt;int&gt;()); for (int j = i; !vis[j]; j = f[j]) vis[j] = 1, ans.back().push_back(j); } return ans; }}; 生成字典序下一排列对给定的排列$a_1a_2\\ldots a_n$，找到$a_j$使得$a_j&lt;a_{j+1},a_{j+1}&gt;a_{j+2}&gt;\\ldots&gt;a_n$即这列数中最后一个相邻递增数对，然后把$a_{j+1},a_{j+2},\\ldots,a_n$中大于$a_j$的最小数放到位置j，然后$a_j\\ldots a_n$中剩余的数从小到大排序放到$[j+1,n]$中。 1234567891011bool nextPermutation(ll *b, ll *e) //标准库有这个函数next_permutation{ ll *i = e - 1, *j = e - 2; while (j &gt;= b &amp;&amp; *j &gt;= *(j + 1)) --j; if (j &lt; b) return 0; while (*i &lt;= *j) --i; return swap(*i, *j), reverse(j + 1, e), 1;} 二项式反演$f(n)=\\sum_{k=0}^nC(n,k)g(k),g(n)=\\sum_{k=0}^n(−1)^{n−k}C(n,k)f(k)$ 第k小期望$f(n,k)$表示有n个变量，和为1，第k小的期望。 $f(n,k)=\\frac{1}{n^2}+(1-\\frac{1}{n})f(n-1,k-1),f(n,0)=0$ 错排数考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数$D_n$满足递推公式：$D_1=0,D_2=1,D_n=(n−1)(D_{n−2}+D_{n−1})$ 通项：$D(n)=n![\\frac{(-1)^2}{2!}+\\ldots+\\frac{(-1)^{n-1} }{(n-1)!}+\\frac{(-1)^n}{n!}]=\\lfloor\\frac{n!}{e}+\\frac{1}{2}\\rfloor$ Bonuli数使用示例 $B_n = -\\frac{1}{C(n+1,n)}(C(n+1,0)B_0+C(n+1,1)B_1+\\ldots+C(n+1,n-1)B_{n-1})=-\\frac{1}{n+1}(C(n+1,0)B_0+C(n+1,1)B_1+\\ldots+C(n+1,n-1)B_{n-1})$ 可用于计算任意正整数次数的幂和：$\\sum_{i=1}^ni^k=\\frac{1}{k+1}\\sum_{j=0}^kC(k+1,j)B_jn^{k+1-j}$ 1234567891011121314151617181920struct Bonuli : Factorial{ vector&lt;ll&gt; b; Bonuli(int N, ll M) : Factorial(N, M), b(N, 0) { for (int i = b[0] = 1; i &lt; N; ++i) { for (int j = 0; j &lt; i; ++j) b[i] = (b[i] + mul(b[j], c(i + 1, j), M)) % M; b[i] = (M - mul(mul(fac[i], ifac[i + 1], M), b[i], M)) % M; } } ll ask(ll n, int k) //return $\\sum_{i=1}^ni^k\\mod M$ { ll r = 0, w = 1, u = (n + 1) % M; for (int i = 1; i &lt;= k + 1; ++i) r = (r + mul(mul(b[k + 1 - i], c(k + 1, i), M), w = mul(w, u, M), M)) % M; return mul(mul(fac[k], ifac[k + 1], M), r, M); }}; Catalan数$h_1=1,h_n=\\frac{4n−2}{n+1}h_{n−1}=\\frac{C(2n,n)}{n+1}=C(2n,n)−C(2n,n−1)$。 在一个格点阵列中，从$(0,0)$点走到$(n,m)$点且不经过对角线$x=y$的方法数：$C(n+m−1,m)−C(n+m−1,m−1),x&gt;y;C(n+m,m)−C(n+m,m−1),x\\ge y$。 常见的Catalan数：括号序的个数、凸多边形三角剖分的方案数等。 Bell数把n个带标号的物品划分为若干不相交集合的方案数称为贝尔数，其递推公式：$B_n=\\sum_{i=0}^{N-1}C_{n-1}^iB_i$ 前几项贝尔数： 11,2,5,15,52,203,877,4140,21147,115975,678570,4213597,27644437,190899322,1382958545,... 下为$O(P^2\\log P)$求$B_n$对P取模。 1234567891011121314151617181920212223242526272829303132struct Bell{ static const int P=999999598,N=7284; int a[4],f[N],s[2][N],i,j,x; Bell() { a[0]=2,a[1]=13,a[2]=5281,a[3]=7283;//P的质因数分解 f[0]=f[1]=s[0][0]=1,s[0][1]=2; for(i=2,x=1; i&lt;N; i++,x^=1) for(f[i]=s[x][0]=s[x^1][i-1],j=1; j&lt;=i; ++j) s[x][j]=(s[x^1][j-1]+s[x][j-1])%P; } int cal(int x,ll n) { int i,j,k,m=0,b[N],c[N],d[70]; for(i=0; i&lt;=x; i++)b[i]=f[i]%x; while(n)d[m++]=n%x,n/=x; for(i=1; i&lt;m; i++)for(j=1; j&lt;=d[i]; j++) { for(k=0; k&lt;x; k++)c[k]=(b[k]*i+b[k+1])%x; c[x]=(c[0]+c[1])%x; for(k=0; k&lt;=x; k++)b[k]=c[k]; } return c[d[0]]; } ll ask(ll n) { if(n&lt;N)return f[n]; ll t=0; for(int i=0; i&lt;4; ++i)t=(t+(P/a[i])*pow(P/a[i],a[i]-2,a[i])%P*cal(a[i],n)%P)%P; return t; }}; 等价类容斥考虑容斥，Bell(p)枚举所有等价情况。对于一种情况，强制了一个等价类里面的数都要相同，其它的可以相同也可以不同。 容斥系数为：$(−1)^{p−等价类个数}(每个等价类大小−1)!之积$。 Grey码格雷序列第i个是i^(i&gt;&gt;1)。长为n的01序列共$2^n$个，下标从$0\\ldots 2^n-1$。 扩展Cayley公式对于n个点，m个连通块的图，假设每个连通块有a[i]个点，那么用s−1条边把它连通的方案数为$n^{s−2}a[1]a[2]\\ldots a[m]$。 超立方体n维超立方体有$2^{n−i}C(n,i)$个i维元素。 枚举位集I的非空子集J1for(J=I; J; J=I&amp;J−1) {}","link":"/2019/02/03/2019-02-03-组合数学/"},{"title":"离散数学","text":"归并排序求逆序对12345678910111213141516171819ll merge_sort(ll *b, ll *e) //int存答案可能会爆{ if (e - b &lt; 2) return 0; ll i = 0, j = 0, *m = b + (e - b) / 2, ans = merge_sort(b, m) + merge_sort(m, e); vector&lt;ll&gt; l(b, m), r(m, e); while (i &lt; l.size() &amp;&amp; j &lt; r.size()) { if (r[j] &lt; l[i]) *(b++) = r[j++], ans += l.size() - i; else *(b++) = l[i++]; } while (i &lt; l.size()) *(b++) = l[i++]; while (j &lt; r.size()) *(b++) = r[j++]; return ans;} 约瑟夫问题123456789ll josephus(ll n, ll k) //编号0~n-1，每k个出列，时间复杂度O(min(n,k)){ if (n &lt; 3) return k % n; if (n &lt; k) return (Josephus(n - 1, k) + k) % n; ll ret = Josephus(n - n / k, k) - n % k; return ret &lt; 0 ? ret + n : ret + ret / (k - 1);} 蔡勒公式$w=(\\lfloor\\frac{c}{4}\\rfloor-2c+y+\\lfloor\\frac{y}{4}\\rfloor+\\lfloor\\frac{13(m+1)}{5}\\rfloor+d-1)\\mod7$ w：$0,1,\\ldots,6$对应周日，周一，$\\ldots$，周六 c：世纪减1（即年份前两位数）。 y：年份后两位数。 m：月（$3\\leq m\\leq14$，即在蔡勒公式中，1、2月要看作上一年的13、14 月来计算）。 d：日。 曼哈顿距离的变换$\\mid x_1−x_2\\mid +\\mid y_1−y_2\\mid=\\max (\\mid (x_1 + y_1)−(x_2 + y_2)\\mid ,\\mid (x_1 −y_1)−(x_2 −y_2)\\mid )$ 皮克定理顶点坐标均是整点（或说正方形格点）的简单多边形中，面积S和内部格点数目n、边上格点数目m的满足关系$S=n+\\frac{m}{2}-1$。 矩形面积并、矩形面积交、矩形周长并（线段树、扫描线总结）详见这篇博文。","link":"/2019/02/03/2019-02-03-离散数学/"},{"title":"一个基于MINST数据集的神经网络实验","text":"照着官方文档按图索骥…算是熟悉一下TF的用法吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960python3 fully_connected_feed.py/home/wuk/anaconda3/envs/tensorflow/lib/python3.7/importlib/_bootstrap.py:219: RuntimeWarning: compiletime version 3.6 of module &apos;tensorflow.python.framework.fast_tensor_util&apos; does notmatch runtime version 3.7 return f(*args, **kwds)WARNING:tensorflow:From fully_connected_feed.py:120: read_data_sets (fromtensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.Instructions for updating:Please use alternatives such as official/mnist/dataset.py from tensorflow/models.WARNING:tensorflow:From /home/wuk/anaconda3/envs/tensorflow/lib/python3.7/site-packages/tensorflow/contrib/learn/python/learn/datasets/mnist.py:260: maybe_download (from tensorflow.contrib.learn.python.learn.datasets.base) is deprecated and will be removed in a future version.Instructions for updating:Please write your own downloading logic.WARNING:tensorflow:From /home/wuk/anaconda3/envs/tensorflow/lib/python3.7/site-packages/tensorflow/contrib/learn/python/learn/datasets/mnist.py:262: extract_images (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.Instructions for updating:Please use tf.data to implement thisfunctionality.Extracting /tmp/tensorflow/mnist/input_data/train-images-idx3-ubyte.gzWARNING:tensorflow:From /home/wuk/anaconda3/envs/tensorflow/lib/python3.7/site-packages/tensorflow/contrib/learn/python/learn/datasets/mnist.py:267: extract_labels (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.Instructions for updating:Please use tf.data to implement thisfunctionality.Extracting /tmp/tensorflow/mnist/input_data/train-labels-idx1-ubyte.gzExtracting /tmp/tensorflow/mnist/input_data/t10k-images-idx3-ubyte.gzExtracting /tmp/tensorflow/mnist/input_data/t10k-labels-idx1-ubyte.gzWARNING:tensorflow:From /home/wuk/anaconda3/envs/tensorflow/lib/python3.7/site-packages/tensorflow/contrib/learn/python/learn/datasets/mnist.py:290: DataSet.__init__ (from tensorflow.contrib.learn.python.learn.datasets.mnist) is deprecated and will be removed in a future version.Instructions for updating:Please use alternatives such as official/mnist/dataset.py from tensorflow/models.2019-02-06 19:33:58.080074: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was notcompiled to use: AVX2 FMAStep 0: loss = 2.31 (0.568 sec)Step 100: loss = 2.15 (0.003 sec)Step 200: loss = 1.93 (0.003 sec)Step 300: loss = 1.51 (0.004 sec)Step 400: loss = 1.28 (0.002 sec)Step 500: loss = 1.01 (0.003 sec)Step 600: loss = 0.77 (0.002 sec)Step 700: loss = 0.67 (0.002 sec)Step 800: loss = 0.69 (0.004 sec)Step 900: loss = 0.43 (0.003 sec)Training Data Eval:Num examples: 55000 Num correct: 47163 Precision @ 1: 0.8575Validation Data Eval:Num examples: 5000 Num correct: 4319 Precision @ 1: 0.8638Test Data Eval:Num examples: 10000 Num correct: 8663 Precision @ 1: 0.8663Step 1000: loss = 0.54 (0.044 sec)Step 1100: loss = 0.47 (0.552 sec)Step 1200: loss = 0.51 (0.003 sec)Step 1300: loss = 0.39 (0.003 sec)Step 1400: loss = 0.46 (0.003 sec)Step 1500: loss = 0.26 (0.003 sec)Step 1600: loss = 0.46 (0.003 sec)Step 1700: loss = 0.29 (0.003 sec)Step 1800: loss = 0.45 (0.003 sec)Step 1900: loss = 0.49 (0.003 sec)Training Data Eval:Num examples: 55000 Num correct: 49275 Precision @ 1: 0.8959Validation Data Eval:Num examples: 5000 Num correct: 4508 Precision @ 1: 0.9016Test Data Eval:Num examples: 10000 Num correct: 9014 Precision @ 1: 0.9014","link":"/2019/02/06/2019-02-06-一个基于MINST数据集的神经网络实验/"},{"title":"配置TensorFlow","text":"该补上的文章🕊了太久了… 工具准备jupyter notebookAnacondaAnaconda集成了很多 Python的第三方库。 安装它之后就可以不用再去一个一个地下载这些库并解决它们之间的依赖关系了，是十分方便的。在Anaconda Distribution上下载。运行下述脚本 1bash Anaconda3-2018.12-Linux-x86_64.sh 运行下述命令检查 1conda list 报错：conda:未找到命令修改环境变量 1vim ~/.bashrc 在最后添加： 1export PATH=~/anaconda3/bin:$PATH 重启环境变量： 1source ~/.bashrc TensorFlow 坑 建立TensorFlow的运行环境，并将其激活，执行： 12conda create -n tensorflow python=3.7source activate tensorflow 这样就激活了虚拟环境。执行以下代码进行 TensorFlow 的安装： 12345678pip3 install tensorflow``` 执行以下代码测试 TensorFlow 是否安装成功，运行一个 Hello TensorFlow```pythonimport tensorflow as tfhello = tf.constant(&apos;Hello, TensorFlow!&apos;)sess = tf.Session()print sess.run(hello) 1Hello, TensorFlow!","link":"/2019/02/06/2019-02-06-配置TensorFlow/"},{"title":"卷积网络做图片分类","text":"一个用CNN做图片分类的例子，是把 CNN 应用于 CIFAR-10 上的 一个实验过程 123\"\"\"挖坑待填…\"\"\"","link":"/2019/02/08/2019-02-08-卷积网络做图片分类/"},{"title":"Just $h$-index","text":"题目链接 很久之前就做过这个题，但是当时只会简单套模板。打算重新学一下可持久化数据结构。 现在我对可持久化数据结构的理解是每次修改时保留原信息，只在修改的地方增加新的修改节点。 undefined 一年前敲得还是二分… undefined","link":"/2019/02/09/2019-02-09-HDU-6278/"},{"title":"To the moon","text":"题目链接 继续学习可持久化数据结构… 这次学习区间更新的可持久化线段树。具体来说，就是每次操作都复制一下根节点，down操作的时候创建子结点即可。 undefined 网上常见的解法是区间更新时不把标记下传而是直接带入返回结果，可以减少空间消耗（然而这里偷懒直接用`vector`，还直接把左右端点维护在线段树节点内…）。 undefined","link":"/2019/02/09/2019-02-09-HDU-4348/"},{"title":"Bubble Cup 11 - Finals","text":"题不错，以后补… Space Isaac如果一个数不能被表示那么它减去$a_i$仍然在$a$中。 假设这个数是$a_0+a_i$​ ，不难发现需要满足$a_0 + a_i = a_1 + a_{i-1} = a_2 + a_{i-2}\\cdots$。差分之后相当于判两部分是不是回文。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;struct Manacher : vector&lt;int&gt;{ Manacher(vector&lt;int&gt; a) : vector&lt;int&gt;((a.size() &lt;&lt; 1) - 1, 0) { vector&lt;int&gt; b(size(), -1); for (int i = 0; i &lt; a.size(); ++i) b[i &lt;&lt; 1] = a[i]; for (int i = 1, x = 0; i &lt; size(); ++i) { if (i &lt;= x + at(x)) at(i) = min(at((x &lt;&lt; 1) - i), x + at(x) - i); while (i - at(i) - 1 &gt;= 0 &amp;&amp; i + at(i) + 1 &lt; size() &amp;&amp; b[i - at(i) - 1] == b[i + at(i) + 1]) ++at(i); if (i + at(i) &gt;= x + at(x)) x = i; } for (int i = 0; i &lt; size(); ++i) if (i - at(i) == 0 || i + at(i) == size() - 1) ++at(i); for (int i = 0; i &lt; size(); ++i) at(i) &gt;&gt;= 1; } bool isPalindrome(int l, int r) { return l == r || at(l + r - 1) &gt;= r - l &gt;&gt; 1; }};int main(){ int n, m; scanf(\"%d %d\", &amp;n, &amp;m); vector&lt;int&gt; a(n), b(n), ans; for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = 0; i &lt; n - 1; ++i) b[i] = a[i + 1] - a[i]; b[n - 1] = (a[0] + m - a[n - 1]) % m; Manacher p(b); for (int i = 0; i &lt; n; ++i) if (p.isPalindrome(0, i) &amp;&amp; p.isPalindrome(i, n)) ans.push_back((a[0] + a[i]) % m); sort(ans.begin(), ans.end()); printf(\"%d\\n\", ans.size()); for (auto i : ans) printf(\"%d \", i);} Interstellar battle12 AI robots将输入按照r从大到小排序，这样对于排序后的每个机器人，只要它能看到前面的机器，前面的机器一定也可以看到他。 对每个q建立一棵线段树，需要动态建点以节省空间。 undefined 一开始的奇思妙想把Fenwick建在map上，这样离散化也省了。可惜还是MLE了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 7;struct Node{ int x, r, q; bool operator&lt;(const Node &amp;rhs) const { return r &gt; rhs.r; }} v[N];struct Fenwick{ map&lt;int, ll&gt; v; void add(int x, ll val, int M = 1e9 + 7) { for (; x &lt; M; x += x &amp; -x) v[x] += val; } ll ask(int x) { ll r = 0; for (; x; x -= x &amp; -x) r += v[x]; return r; } ll ask(int l, int r) { return ask(r) - ask(l - 1); }};unordered_map&lt;ll, Fenwick&gt; mp;int n, k;int main(){ scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i &lt; n; ++i) scanf(\"%d%d%d\", &amp;v[i].x, &amp;v[i].r, &amp;v[i].q); sort(v, v + n); ll ans = 0; for (int i = 0; i &lt; n; ++i) { for (int j = v[i].q - k; j &lt;= v[i].q + k; ++j) if (mp.count(j)) ans += mp[j].ask(max(v[i].x - v[i].r, 0) + 1, min(v[i].x + v[i].r, int(1e9)) + 1); mp[v[i].q].add(v[i].x + 1, 1); } printf(\"%lld\", ans);} Self-exploration12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 7;struct Mod{ const ll M; Mod(ll M) : M(M) {} ll mul(ll a, ll b) const { return a * b % M; }};struct Factorial : Mod{ vector&lt;ll&gt; fac, ifac; Factorial(int N, ll M) : fac(N, 1), ifac(N, 1), Mod(M) { for (int i = 2; i &lt; N; ++i) fac[i] = mul(fac[i - 1], i), ifac[i] = mul(M - M / i, ifac[M % i]); for (int i = 2; i &lt; N; ++i) ifac[i] = mul(ifac[i], ifac[i - 1]); } ll c(int n, int m) { return m &lt; 0 ? n == m : mul(mul(fac[n], ifac[m]), ifac[n - m]); }} f(N &lt;&lt; 1, 1e9 + 7);ll cal(char a[], vector&lt;int&gt; c){ int l = strlen(a), sum = c[0] + c[1] + c[2] + c[3]; if (c[2] &gt; c[1] + 1 || c[2] &lt; c[1] || l &lt; sum + 1) return 0; if (l &gt; sum + 1) return f.mul(f.c(c[1] + c[3], c[1]), f.c(c[0] + c[2] - 1, c[2] - 1)); ll ans = 0; for (int i = 1; a[i]; ++i) { int now = (a[i - 1] - '0' &lt;&lt; 1) + a[i] - '0'; if (a[i] != '0' &amp;&amp; c[now - 1]) { --c[now - 1]; ans = (ans + f.mul(f.c(c[1] + c[3] - 1, c[1] - 1), f.c(c[0] + c[2], c[2]))) % f.M; ++c[now - 1]; } if (--c[now] &lt; 0) break; } return ans;}ll check(char a[], vector&lt;int&gt; c){ int l = strlen(a), sum = c[0] + c[1] + c[2] + c[3]; if (c[2] &gt; c[1] + 1 || c[2] &lt; c[1] || l != sum + 1) return 0; for (int i = 1; a[i]; ++i) if (--c[(a[i - 1] - '0' &lt;&lt; 1) + a[i] - '0'] &lt; 0) return 0; return 1;}char s[2][N];vector&lt;int&gt; c(4);int main(){ scanf(\"%s%s%d%d%d%d\", s[0], s[1], &amp;c[0], &amp;c[1], &amp;c[2], &amp;c[3]); printf(\"%lld\", ((cal(s[1], c) - cal(s[0], c) + check(s[1], c)) % f.M + f.M) % f.M);} Palindrome Pairs12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;unordered_map&lt;ll, ll&gt; mp;char s[1000009];ll m, n;int main(){ for (scanf(\"%lld\", &amp;n); n--;) { scanf(\"%s\", s); for (int i = m = 0; s[i]; ++i) m ^= 1 &lt;&lt; s[i] - 'a'; ++mp[m]; } m = 0; for (auto it : mp) { m += it.second * (it.second - 1); for (int i = 1 &lt;&lt; 25; i; i &gt;&gt;= 1) if (mp.count(it.first ^ i)) m += it.second * mp[it.first ^ i]; } printf(\"%lld\", m &gt;&gt; 1);}","link":"/2019/02/16/2019-02-16-Bubble Cup 11 - Finals/"},{"title":"Mail.Ru Cup 2018 Round 3","text":"Determine Line签到题还WA了一发… bitset初始化的时候是0扩展而不是符号扩展。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;bitset&lt;127&gt; ans(string(127, '1'));int n;int main(){ scanf(\"%d\", &amp;n); for (int i = 0, r, k; i &lt; n; ++i) { bitset&lt;127&gt; bs; for (scanf(\"%d\", &amp;r); r--; bs.set(k)) scanf(\"%d\", &amp;k); ans &amp;= bs; } for (int i = 0; i &lt; ans.size(); ++i) if (ans[i]) printf(\"%d \", i);} Divide Candies12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n, m, ans, a[1023];int main(){ scanf(\"%lld%lld\", &amp;n, &amp;m); fill(a, a + m, n / m); for (ll i = n / m * m + 1; i &lt;= n; ++i) ++a[i % m]; for (ll i = 0; i &lt; m; ++i) for (ll j = 0; j &lt; m; ++j) if ((i * i + j * j) % m == 0) ans += a[i] * a[j]; printf(\"%lld\", ans);} Pick Heroes难得一见的交互题，题目本身不难，无脑贪心即可。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2047;int n, m, p[N], a[N], q[N], vis[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= 2 * n; ++i) scanf(\"%d\", &amp;p[q[i] = i]); for (int i = 0, x, y; i &lt; m; ++i) scanf(\"%d%d\", &amp;x, &amp;y), a[a[x] = y] = x; sort(q + 1, q + 2 * n + 1, [](int x, int y) -&gt; bool { return a[x] &amp;&amp; !a[y] ? 1 : !a[x] &amp;&amp; a[y] ? 0 : p[x] &gt; p[y]; }); scanf(\"%d\", &amp;m); if (m == 1) printf(\"%d\\n\", vis[q[1]] = q[1]), fflush(stdout); for (int t = 1;;) { scanf(\"%d\", &amp;m); for (vis[m] = m; vis[q[t]];) ++t; if (t &gt; 2 * n) break; m = a[m] &amp;&amp; !vis[a[m]] ? a[m] : q[t]; printf(\"%d\\n\", vis[m] = m), fflush(stdout); }} Decorate Apple Tree就是求叶结点第k小的子树上有多少叶结点。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 9;vector&lt;int&gt; g[N];int n, a[N];void dfs(int u){ if (g[u].empty()) a[u] = 1; for (auto v : g[u]) dfs(v), a[u] += a[v];}int main(){ scanf(\"%d\", &amp;n); for (int i = 2, p; i &lt;= n; ++i) scanf(\"%d\", &amp;p), g[p].push_back(i); dfs(1); sort(a + 1, a + n + 1); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", a[i]);} Check Transcription字符串哈希，卡模数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct Mod{ const ll M; Mod(ll M) : M(M) {} ll add(ll a, ll b) const { return ((a + b) % M + M) % M; } ll mul(ll a, ll b) const { return a * b % M; }};struct HashString : Mod{ vector&lt;ll&gt; f, p; HashString(const string &amp;s, ll M = 1e9 + 7, ll P = 131) : Mod(M), f(s.size() + 1), p(s.size() + 1, 1) { for (int i = 0; i &lt; s.size(); ++i) { f[i + 1] = add(mul(f[i], P), s[i]); p[i + 1] = mul(p[i], P); } } ll ask(int pos, int len) { return add(f[pos + len], -mul(f[pos], p[len])); }};string s, t;int c[2], ans;int main(){ cin &gt;&gt; s &gt;&gt; t; HashString h(t); for (int i = 0; i &lt; s.size(); ++i) ++c[s[i] - '0']; for (int len[2] = {1}; len[0] * c[0] &lt; t.size(); ++len[0]) { len[1] = (t.size() - len[0] * c[0]) / c[1]; if (len[1] == 0) break; if (len[0] * c[0] + len[1] * c[1] == t.size()) { ll r[2] = {-1, -2}; for (int i = 0, j = 0; r[0] != r[1] &amp;&amp; i &lt; s.size(); ++i) { if (r[s[i] - '0'] &lt; 0) r[s[i] - '0'] = h.ask(j, len[s[i] - '0']); if (r[s[i] - '0'] == h.ask(j, len[s[i] - '0'])) j += len[s[i] - '0']; else r[0] = r[1]; } if (r[1] != r[0]) ++ans; } } cout &lt;&lt; ans;} Write The Contest1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 127, C = 10, INF = 1e9;pair&lt;double, int&gt; a[N];double c, t, f[N][N * C];int n, kase;int main(){ for (scanf(\"%d\", &amp;kase); kase--;) { scanf(\"%d%lf%lf\", &amp;n, &amp;c, &amp;t); int m = 0, ans = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%lf%d\", &amp;a[i].first, &amp;a[i].second), m += a[i].second; sort(a + 1, a + n + 1, greater&lt;pair&lt;double, int&gt;&gt;()); for (int i = 0; i &lt;= n; ++i) fill(f[i], f[i] + m + 1, INF); f[0][0] = 0; for (int i = 1; i &lt;= n; ++i) for (int j = i; j; --j) for (int k = m - a[i].second; ~k; --k) f[j][k + a[i].second] = min(f[j][k + a[i].second], f[j - 1][k] + a[i].first / pow(0.9, j)); for (int j = m; !ans &amp;&amp; j; --j) for (int i = 0; !ans &amp;&amp; i &lt;= n; ++i) { double x = max(sqrt(c * f[i][j]) - 1, .0) + 1; if (x + c * f[i][j] / x - 1 + c * i * 10 &lt;= t * c) ans = j; } printf(\"%d\\n\", ans); }}","link":"/2019/02/17/2019-02-17-Mail.Ru Cup 2018 Round 3/"},{"title":"Primitive Roots","text":"题目链接 把一个数的所有比它小的原根求出来。这里有一篇博客（Fenghr）说的挺好，先转过来： 所谓原根就是说，对于一个数$n$，$x^k\\equiv 1\\pmod n$的最小正整数k是$\\phi (n)$，即n的欧拉函数，那么就称$x$是$n$的原根。原根有很多美丽的性质。比如说： 有原根的数只有$2,4,p^n,2p^n$（$p$为质数，$n$为正整数）。 一个数的最小原根的大小是$O(n^{\\frac{1}{4}})$的。 如果$g$为$n$的原根，则$g^d$为$n$的原根的充要条件是$\\gcd (d,\\phi (n))=1$； 如果$n$有原根，它的原根个数为$\\phi (\\phi (n))$。 那么来看一下这道题： 首先根据性质1，我们可以通过预处理质数，把不存在的情况判掉。 然后根据性质3，找到一个原根后枚举次方判$\\gcd$就可以了。 怎么找到一个原根呢？按照性质2傻傻去跑在这种多组数据的题目里是肯定不行的。 那么有一个喜大普奔的结论来帮助我们： 因为$g^{\\phi (n)}\\equiv 1\\pmod n$，而对于比φ(n)小的数都不成立。 枚举$\\phi (n)$的质因子p，看$g^{\\phi (n)/p}$在模意义下是否是1。 是1的话$g$就不是原根。 证明起来有点麻烦，这里就不写了。 所以找原根大概是$O(n^{\\frac{1}{8}})$的。 找到之后枚举次方就可以了，因为是充分条件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;const int N = 1000009;struct EulerSieve{ vector&lt;int&gt; p, m, phi; EulerSieve(int N) : m(N, 0), phi(N, 0) { phi[1] = 1; for (long long i = 2, k; i &lt; N; ++i) { if (!m[i]) p.push_back(m[i] = i), phi[i] = i - 1; for (int j = 0; j &lt; p.size() &amp;&amp; (k = i * p[j]) &lt; N; ++j) { phi[k] = phi[i] * p[j]; if ((m[k] = p[j]) == m[i]) break; phi[k] -= phi[i]; } } } vector&lt;int&gt; fac(int nPhi) { vector&lt;int&gt; pt; for (int i = 0; p[i] * p[i] &lt;= nPhi; ++i) if (nPhi % p[i] == 0) for (pt.push_back(p[i]); nPhi % p[i] == 0;) nPhi /= p[i]; if (nPhi &gt; 1) pt.push_back(nPhi); return pt; }} e(N);struct Mod{ const ll M; Mod(ll M) : M(M) {} ll mul(ll a, ll b) const { return a * b % M; } ll pow(ll a, ll b) const { ll r = 1; for (a %= M; b; b &gt;&gt;= 1, a = mul(a, a)) if (b &amp; 1) r = mul(r, a); return r; }};struct PrimitiveRoots : vector&lt;int&gt;, Mod{ PrimitiveRoots(int n, int nPhi) : Mod(n) { if (!check(n)) return; vector&lt;int&gt; pt(e.fac(nPhi)); for (int i = 2, flag; i &lt;= n; ++i) if (pow(i, nPhi) == 1) { for (int j = flag = 0; !flag &amp;&amp; j &lt; pt.size(); ++j) if (pow(i, nPhi / pt[j]) == 1) flag = 1; if (!flag) { for (int j = 1, k = i; j &lt; nPhi; ++j, k = mul(k, i)) if (__gcd(j, nPhi) == 1) push_back(k); break; } } } bool check(int x) //模m有原根的充要条件是m=2,4,p^n,2(p^n),(p为奇质数，n为任意数） { if (x &lt; 5) return push_back(x - 1), 0; if (x % 2 == 0) x &gt;&gt;= 1; if (x % 2 == 0) return 0; for (int i = 1; e.p[i] * e.p[i] &lt;= x; ++i) if (x % e.p[i] == 0) { while (x % e.p[i] == 0) x /= e.p[i]; return x == 1; } return 1; }};int main(){ for (int n; ~scanf(\"%d\", &amp;n);) { PrimitiveRoots ans(n, e.phi[n]); sort(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); ++i) printf(\"%d%c\", ans[i], i + 1 == ans.size() ? '\\n' : ' '); if (ans.empty()) printf(\"-1\\n\"); }}","link":"/2019/02/18/2019-02-18-HDU-4992/"},{"title":"前馈神经网络","text":"节日快乐（并不）… “机器学习”顾名思义就是机器通过对观测到的事物进行归纳，进而总结出它们之间的规律、关系一类。 各神经元从输入层开始，接收前一级输入，并输入到下一级，直至输出层。整个网络中无反馈，可用一个DAG（有向无环图）表示。 在这么多神经元更新的时候，让它们每个值都往一个方向变，什么方向呢？就是刚刚我们说的使得损失函数向不断降低的方向变，降低模型预测结果和给定的目标值之间的差距， 这点记住了就足够了。更为复杂的神经网络构建方式，从本质来讲都一样，是通过不断调整各个神经元中的待定系数使得损失函数向不断降低的方向移动。 通过凸优化的方式能够顺利求出损失函数的极值。然而我们在真正的生产环境遇到的各种神经网络中包含着非常多的线性和非线性分类器函数组合，这也就意味着，在这种复杂的网络环境中，损失函数极有可能，甚至可以说几乎 一定不是凸函数一一在这个函数的空间中会呈现出“层峦叠幢”、 “坑坑洼洼”的不规则形 状，而非前面我们画出来的一个大碗。 因此，在真正的商用框架中——比如 Tensor Flow 会用很多技巧来寻找在整个向量空间中拥有极小值点的参数向量。对于这种不规则形状的非凸函数来说，当然也是可以通过遗传算法、随机梯度下降等多种方式相结合的方法来不断试探找到极小值点位置的。当然，这些过程对于一个普通的 TensorFlow 的使用者来说是透明的，它们已经由那些数据科学家们实现并封装在框架中了。 下面整理一些学习笔记。 网络结构BP（前馈神经）网络是所有的神经网络中结构最为单纯的一种，如下图。分成输入层、隐藏层、输出层。节点数目可以不一样而且不对称。神经网络本身就有很多种设计模式，并且会在不同的模式下 产生不同的训练效果和运用特点。 损失函数管这种函数叫Cost或者Loss。深度学习中的损失函数其实是不一而足的，每种损失函数在当初诞生的时候都是有－些客观环境和理由的。但不管是哪种损失函数，都有这样几个特点。 恒非负。都说是损失了，最圆满的情况就是没损失，或者说损失为 0，但凡有一点拟合的偏差那 就会让损失增加。 所以损失函数都是恒非负的，否则也无法出现合理的解释了。 误差越小函数值越小。这个性质也是非常重要的，如果函数定义的不好，优化起来没有方向或者逻辑过于复 杂，那对于问题处理显然是不利的。 收敛快。指在我们优化这个损失函数Loss的迭代过程中需要让它比较快地逼近极小值，逼近函数值的低点。同等情况下一个钟头能得到解那绝对没必要花三个钟头，好的损失函数的定义会让这个训练时间在一定程度上缩短的。这个条件不能算是必要条件，因为它只要不影响正确性，慢一点其实也不能算作“错误”。 训练过程回过头来再看我们初始化$(w_0,b_0,Loss_0)$后下一步怎么做。$w_1=w_0-\\eta\\frac{\\partial Loss}{\\partial w},b_1=b_0-\\eta\\frac{\\partial Loss}{\\partial b}$再次强调一下，不求梯度（偏导数）的情况下，通过改变$w$或$b$的值是一定能够比较 出来移动的方向的，但是问题是不知道移动多少比较适宜。 而有了偏导数与学习率$\\eta$的乘积后，当这个点逐步接近“碗底”的时候，偏导数也随之降低，移动的步伐也会慢慢减小，收敛更为平缓，不会轻易出现“步子太大”而越过最低点的情况。一轮一轮进行迭代，直到每次更新的值非常小，损失值不再明显减少就可以判断为训 练结束。此时得到的$w,b$值就是我们要求的模型。","link":"/2019/02/14/2019-02-14-前馈神经网络/"},{"title":"Divide by Zero 2018","text":"Check the string123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;char s[8195];int c[3];int main(){ scanf(\"%s\", s); for (int i = 0; s[i]; ++i) { ++c[s[i] - 'a']; if (i &amp;&amp; s[i] &lt; s[i - 1]) return printf(\"NO\"), 0; } printf(c[0] &amp;&amp; c[1] &amp;&amp; (c[2] == c[0] || c[2] == c[1]) ? \"YES\" : \"NO\");} Minimize the error1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;priority_queue&lt;ll&gt; q;ll n, k, t, a[1023];int main(){ scanf(\"%lld%lld%lld\", &amp;n, &amp;k, &amp;t); k += t; for (ll i = 0; i &lt; n; ++i) scanf(\"%lld\", &amp;a[i]); for (ll i = 0; i &lt; n; ++i) { scanf(\"%lld\", &amp;t); q.push(abs(a[i] - t)); } while (k--) { t = q.top(); q.pop(); q.push(t ? t - 1 : t + 1); } for (t = 0; !q.empty(); q.pop()) t += q.top() * q.top(); printf(\"%lld\", t);} Subsequence Counting123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;vector&lt;ll&gt; v;ll x, d;int main(){ scanf(\"%lld%lld\", &amp;x, &amp;d); for (ll a = 1; x; a += d) for (ll i = 1; i &lt;= x; i &lt;&lt;= 1) v.push_back(a), x -= i; printf(\"%d\\n\", v.size()); for (auto i : v) printf(\"%lld \", i);} Alternating Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 2e5 + 7;struct Mod{ const ll M; Mod(ll M) : M(M) {} ll add(ll a, ll b) const { return ((a + b) % M + M) % M; } ll mul(ll a, ll b) const { return a * b % M; }} M(1e9 + 7);vector&lt;ll&gt; e[N];ll n, ans, v[N], f[N][2], g[N][2];void dfs(ll u, ll fa = N){ for (auto to : e[u]) if (to != fa) { dfs(to, u); f[u][0] = M.add(f[u][0] + f[to][1], -M.mul(g[to][1], v[u])); f[u][1] = M.add(f[u][1] + f[to][0], M.mul(g[to][0], v[u])); g[u][0] = M.add(g[u][0], g[to][1]); g[u][1] = M.add(g[u][1], g[to][0]); } for (auto to : e[u]) if (to != fa) { if (g[to][0]) ans = M.add(ans, M.mul(g[u][1] - g[to][0], f[to][0] * 2 + g[to][0] * v[u])); if (g[to][1]) ans = M.add(ans, M.mul(g[u][0] - g[to][1], f[to][1] * 2 - g[to][1] * v[u])); } ans = M.add(ans, f[u][1] * 2 + v[u]); f[u][1] = M.add(f[u][1], v[u]); g[u][1] = M.add(g[u][1], 1);}int main(){ scanf(\"%lld\", &amp;n); for (ll i = 1; i &lt;= n; ++i) scanf(\"%lld\", &amp;v[i]); for (ll i = 1, x, y; i &lt; n; ++i) { scanf(\"%lld%lld\", &amp;x, &amp;y); e[x].push_back(y); e[y].push_back(x); } dfs(1); printf(\"%lld\", ans);}","link":"/2019/02/20/2019-02-20-Divide by Zero 2018/"},{"title":"Mail.Ru Cup 2018 Round 1","text":"# [Elevator or Stairs?](https://vjudge.net/problem/CodeForces-1054A) undefined # [Appending Mex](https://vjudge.net/problem/CodeForces-1054B) 每一步能得到的值是`0,1,...,m+1`，其中`m`是前几步得到的最大的数。 undefined # [Candies Distribution](https://vjudge.net/problem/CodeForces-1054C) `l[i]+r[i]`之后在所有数里的排名就是原来的排名，回代检验即可。 undefined # [Changing Array](https://vjudge.net/problem/CodeForces-1054C) undefined","link":"/2019/02/18/2019-02-18-Mail.Ru Cup 2018 Round 1/"},{"title":"Hello 2019","text":"Gennady and a Card Game12345678910#include &lt;bits/stdc++.h&gt;using namespace std;char t[9], s[9];int main(){ for (scanf(\"%s\", t); ~scanf(\"%s\", s);) if (s[0] == t[0] || s[1] == t[1]) return printf(\"YES\"), 0; printf(\"NO\");} Petr and a Combination Lock1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int n, a[15];int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = (1 &lt;&lt; n) - 1, sum; ~i; --i) { for (int j = sum = 0; j &lt; n; ++j) sum += (i &amp; 1 &lt;&lt; j) ? -a[j] : a[j]; if (sum % 360 == 0) return printf(\"YES\"), 0; } printf(\"NO\");} Yuhao and a Parenthesis12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 5;char s[N], t[N];int n, cnt[N &lt;&lt; 1];int main(){ scanf(\"%d\", &amp;n); for (int i = 0, c[2]; i &lt; n; ++i) { scanf(\"%s\", s); for (int i = c[0] = c[1] = 0, siz = 0; s[i]; ++i) { if (siz &amp;&amp; t[siz - 1] == '(' &amp;&amp; s[i] == ')') --c[0], --siz; else ++c[s[i] == ')'], t[siz++] = s[i]; } if (!c[0] || !c[1]) ++cnt[N - c[0] + c[1]]; } for (int i = n = 0; i &lt; N; ++i) n += min(cnt[N - i], cnt[N + i]); printf(\"%d\", n + cnt[N] / 2 - cnt[N]);} Makoto and a Blackboard1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define FI first#define SE secondusing namespace std;typedef long long ll;struct Mod{ const ll M; Mod(ll M) : M(M) {} ll add(ll a, ll b) const { return ((a + b) % M + M) % M; } ll mul(ll a, ll b) const { return a * b % M; } ll pow(ll a, ll b) const { ll r = 1; for (a %= M; b; b &gt;&gt;= 1, a = mul(a, a)) if (b &amp; 1) r = mul(r, a); return r; } ll inv(ll a) const { return pow(a, M - 2); }} M(1e9 + 7);ll n, k, ans;int main(){ scanf(\"%lld%lld\", &amp;n, &amp;k); vector&lt;pair&lt;ll, ll&gt;&gt; v; ans = n; for (ll i = 2; i * i &lt;= n; ++i) if (ans % i == 0) for (v.push_back({i, 0}); ans % i == 0; ans /= i) ++v.back().SE; if (ans &gt; 1) v.push_back({ans, 1}), ans = 1; for (auto it : v) { vector&lt;ll&gt; sum(it.SE + 1, 0); sum[it.SE] = 1; for (ll j = 0; j &lt; k; ++j) { vector&lt;ll&gt; f(it.SE + 1, 0); for (ll i = 1; i &lt;= it.SE; ++i) f[0] = M.add(f[0], f[i] = M.mul(sum[i - 1], M.inv(i))); sum[0] = M.add(f[0], M.mul(sum[it.SE], M.inv(it.SE + 1))); for (ll i = 1; i &lt;= it.SE; ++i) sum[i] = M.add(sum[i - 1], -f[i]); } ll res = sum[0]; for (ll i = 1, p = 1; i &lt;= it.SE; ++i) res = M.add(res, M.mul(p = M.mul(p, it.FI), sum[i])); ans = M.mul(ans, res); } printf(\"%lld\", ans);}","link":"/2019/02/22/2019-02-22-Hello 2019/"},{"title":"Manthan, Codefest 18","text":"Packets123456789#include &lt;bits/stdc++.h&gt;using namespace std;int n, ans;int main(){ for (scanf(\"%d\", &amp;n); n; n &gt;&gt;= 1) ++ans; printf(\"%d\", ans);} 这个为啥错了？12345678#include &lt;bits/stdc++.h&gt;using namespace std;int n;int main(){ scanf(\"%d\", &amp;n); printf(\"%.0f\", floor(log(n) / log(2)) + 1);} Reach Median1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 2e5 + 7;ll n, s, m, ans, a[N];int main(){ scanf(\"%lld%lld\", &amp;n, &amp;s); for (ll i = 0; i &lt; n; ++i) scanf(\"%lld\", &amp;a[i]); sort(a, a + n); m = n / 2; if (a[m] &lt; s) while (a[m] &lt; s &amp;&amp; m &lt; n) ans += s - a[m++]; else while (a[m] &gt; s &amp;&amp; m &gt;= 0) ans += a[m--] - s; printf(\"%lld\", ans);} Equalizel[i]+r[i]之后在所有数里的排名就是原来的排名，回代检验即可。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 9;char a[N], b[N];int n;int main(){ scanf(\"%d%s%s\", &amp;n, a, b); for (int i = n = 0; a[i]; ++i) if (a[i] != b[i]) { ++n; if (a[i + 1] != b[i + 1] &amp;&amp; a[i] == b[i + 1]) ++i; } printf(\"%d\", n);} Valid BFS?瞎跑大暴力直接过了…正解应该是用BFS的两个性质： BFS序是关于深度的一个非减序列 BFS序是关于父节点深度的一个非减序列 别忘了起点嘚是1…太坑了吧 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 9;unordered_set&lt;int&gt; g[N];int n, m = 1, a[N];int main(){ scanf(\"%d\", &amp;n); for (int i = 1, x, y; i &lt; n; ++i) { scanf(\"%d%d\", &amp;x, &amp;y); g[x].insert(y); g[y].insert(x); } for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = 0; i &lt; n; ++i) while (g[a[i]].count(a[m])) ++m; printf(m == n &amp;&amp; a[0] == 1 ? \"Yes\" : \"No\");} Trips倒着处理一波。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 9;unordered_set&lt;int&gt; se, g[N];pair&lt;int, int&gt; e[N];int n, m, k, vis[N], ans[N], cnt[N];void del(int x){ if (g[x].size() &lt; k &amp;&amp; se.erase(x)) for (auto y : g[x]) g[y].erase(x), del(y);}int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; ++i) { int &amp;x = e[i].first, &amp;y = e[i].second; scanf(\"%d%d\", &amp;x, &amp;y); g[x].insert(y); g[y].insert(x); } for (int i = 1; i &lt;= n; ++i) se.insert(i); for (int i = 1; i &lt;= n; ++i) del(i); for (int i = m - 1; ~i; --i) { ans[i] = se.size(); if (se.empty()) break; int &amp;x = e[i].first, &amp;y = e[i].second; g[x].erase(y); g[y].erase(x); del(x); del(y); } for (int i = 0; i &lt; m; ++i) printf(\"%d\\n\", ans[i]);}","link":"/2019/02/19/2019-02-19-Manthan, Codefest 18/"},{"title":"Little Artem and Time Machine","text":"题目链接 这个人居然也可以在这个沙雕问题RE一晚上以下是问题简化。 123vector&lt;int&gt; v(1);int push(int val) { return v.push_back(val), v.back(); }v[0] = push(1); 假如有上面这段代码，在push时改变了v.size()，就可能会导致容器在内存里移动，但是左边v[0]的引用先于push被构造，结果真正赋值的时候期望的地址可能已经发生移动，就导致了RE。 道理我都懂，但是问题发生的地方也太隐密了…想想平时的代码习惯不禁冒出冷汗。以后还是要多多注意。 正文在16号那场集训曾经产生了把树状数组建在map上的想法…所以今天来实践一下。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct Fenwick{ map&lt;int, ll&gt; v; void add(int x, ll val, int M = 1e9 + 7) { for (; x &lt; M; x += x &amp; -x) v[x] += val; } ll ask(int x) { ll r = 0; for (; x; x -= x &amp; -x) r += v[x]; return r; }};map&lt;int, Fenwick&gt; mp;int n, a, t, x;int main(){ for (scanf(\"%d\", &amp;n); n--;) { scanf(\"%d%d%d\", &amp;a, &amp;t, &amp;x); if (a == 3) printf(\"%d\\n\", mp[x].ask(t)); else mp[x].add(t, a == 2 ? -1 : 1); }} 时空最优解当然是动态开点线段树啦，比上面的代码快了正好一倍（171ms:342ms），空间也小了一些（45344kB:52676kB）。 启示是，假如题目空间给的足够大的话，可以用建在map上的树状数组来偷懒代替线段树来维护区间和。（并没有什么卵用？） 以下是正常的动态下传线段树，只快一丢丢。 undefined 以下是特殊优化的线段树，快了一倍。 undefined","link":"/2019/02/24/2019-02-24-CodeForces-641E/"},{"title":"","text":"参考了C++中文手册\\具名要求，感谢社区内的志愿者。 STL的全称是Standard Template Library，即标准模板库。STL是C++标准程序库的核心，深刻影响了标准程序库的整体结构，STL内的所有组件都由模板（template）构成，旨在为问题提供最通用的容器和解决算法。 算法大部分算法都定义在算法库algorithm中，另外还在&lt;numberic&gt;中定义了一些数值泛型算法。标准库中提供了上百种算法，然而，死记硬背是不需要的，算法库有一致的结构。除了少数特例之外，标准库都对一个迭代器范围内的元素进行操作，我们将这个元素范围称为“输入范围”。接受输入范围的元素总是是用左闭合区间来表示这个范围。 迭代器STL中大量使用迭代器（iterator）这一通用概念在一些数据结构内访问数据，下面先进行简要介绍。 表示一个元素序列的几种方法例如，有如下十个数线性排列，下标地址从0开始： 140,41,42,43,44,45,46,47,48,49 全闭合区间数学上的表示是$[left,right]$或$[first,last]$，用这个序列第一个和最后一个元素的地址表示一个区间内的所有元素，则$[2,9]$表示了序列 142,43,44,45,46,47,48,49 在全闭合区间中，$first&gt;last$时表示一个空区间。 左闭合区间数学上的表示是$[begin,end)$，用这个序列第一个和最后一个元素后一个的地址来表示一个区间内的左右元素，相当于全闭合区间里的$[begin,end-1]$。end可以指向一个不存在元素的地址，例如$[2,10)$同样表示了上面这个序列。 在左闭合区间中，$first=last$时表示一个空区间。 子串区间数学上的表示是$[position,position+length)$，表示了从给定元素开始的若干元素。例如，$[2,2+8)$同样表示了上面这个序列。 C标准库的很多函数都是使用这一方法表示一个区间，例如qsort、memset等。 在子串区间中，length=0表示一个空区间。 左闭合区间表示的优越性访问方便，且对迭代器的要求较低123for (it=begin; it!=end; ++it) {} // 使用左闭合区间for (it=left; it&lt;=right; ++it) {} // 使用全闭合区间for (int i=0; i!=length; ++i) {} // 使用子串区间 在遍历一个元素序列时，三种表示法通常像上面这样遍历。这时，全闭合区间使用了&lt;=运算，要求高于!=（通常，一个元素可以比较大小时一定可以判断相等与否；但反之不然）；子串区间需要额外维护一个计数器，对于很多不能按下标访问的数据结构来说显得不够方便。 查找方便查找target，返回的位置==end，说明在范围内没有找到target。 便于二分当需要取中间元素的时候，mid=begin+end/2的定位问题。如果区间元素的个数是奇数个，那么mid永远是指向中间的元素；如果区间元素是偶数个，那么mid永远指向后半段区间的首元素。这样做在二分查找等一些算法的实现上特别有优势。 mid的规范写法是mid=begin+(end-begin)/2。 快速统计区间内元素$end-begin=length$。推论是，如果$begin==end$那么表示的是一个空区间。 五类迭代器 在C++17中，定义了第6类迭代器：相接迭代器（contiguous iterator），其所指向的逻辑相邻元素也在内存中物理上相邻。指向数组元素的指针满足相接迭代器的所有要求，但容器deque不满足。 在C++20中，定义了第7类迭代器：常表达式迭代器（constexpr iterator）是能在常量表达式求值中使用的迭代器。 C++20 引入基于概念的新迭代器系统，它异于 C++17 及之前的迭代器。虽然基础分配法保持类似，但单独的迭代器类别的要求有些区别。 在C++中，一图解释五类迭代器之间的继承关系： 12345graph LR输入迭代器--&gt;前向迭代器输出迭代器--&gt;前向迭代器前向迭代器--&gt;双向迭代器双向迭代器--&gt;随机访问迭代器 输入迭代器（input iterator）只读，不写；单遍扫描，只能递增。 输入迭代器只支持顺序访问，通常用于读取序列中的元素。对于一个输入迭代器it，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不保证其状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描的算法。支持如下操作： 相等（==）、不等（!=）比较。 用于推进迭代器的前置和后置递增（++）。 解引用（*），只能出现在赋值运算的右侧；箭头运算符（-&gt;），it-&gt;member等价于(*it)-&gt;member。 算法find要求输入迭代器；而类型istream_iterator是一种输入迭代器。 输出迭代器（output iterator）只写，不读；单遍扫描，只能递增。可以看作输入迭代器功能上的补集。 只能向解引用的输出迭代器赋值一次，类似输入迭代器，输出迭代器也只能用于单遍扫描的算法，通常用作算法的目标位置。支持如下操作： 用于推进迭代器的前置和后置递增（++）。 解引用（*），只能出现在赋值运算的左侧。 算法fill要求输出迭代器；而类型ostream_iterator是一种输出迭代器。 前向迭代器（forward iterator）可读写；多遍扫描，只能递增。 可以读写元素，只能在序列中沿着一个方向移动，支持所有输入迭代器和输出迭代器的操作，而且可以多次读写同一个元素。因此，可以保存前向迭代器的状态，使用前向迭代器的算法可以进行多遍扫描。 算法replace要求前向迭代器；容器forward_list上的迭代器是前向迭代器。 双向迭代器（bidrectional iterator）可读写；多遍扫描，能递增递减。 可正向/反向读写序列中的元素。除支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减（--）。 算法reverse要求双向迭代器；除了forward_list之外，其他标准库容器上的迭代器都是双向迭代器。 随机访问迭代器（random-access iterator）可读写；多遍扫描，支持全部迭代器运算。 提供在常数时间内访问序列中任意元素的能力，除支持双向迭代器的所有操作外，还支持： 用于比较两个迭代器的相对位置（&gt;、&lt;、&gt;=、&lt;=）。 迭代器和一个整数值的加减运算（+、+=、-、-=），计算结果迭代器在序列中前进或后退给定整数后的迭代器。 迭代器之间的减法（-），得到两个迭代器之间的距离。 下标运算符（[]），it[n]与*(it[n])等价。 算法sort要求随机访问迭代器；容器vector上的迭代器和用于访问内置数组的指针是随机访问迭代器。 算法概览定制算法谓词有单参数，且不修改它，返回值可转换为 bool 的函数对象。 二元谓词有双参数，且不修改它，返回值可转换为 bool 的函数对象。 比较建立顺序关系的二元谓词 (BinaryPredicate) 。应用到满足比较 (Compare) 类型对象的函数调用运算的返回值，在按语境转换成 bool 时，若此类型所引入的严格弱序关系中调用的第一参数先出现于第二参数，则生成 true ，否则生成 false 。 容器容器（Container）是用于存储其他对象，并管理其所容纳的对象所用的内存的对象。","link":"/2019/04/11/2019-02-27-STL简单整理/"},{"title":"K大数查询","text":"题目链接 看到巨佬们在群里膜CDQ，于是来学习CDQ分治… 要避免树状数组重复初始化，每次操作完之后要将树状数组恢复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 5e4 + 9;struct Fenwick{ struct BaseFenwick { vector&lt;ll&gt; v; BaseFenwick(int n) : v(n) {} void add(int x, ll w) { for (; x &lt; v.size(); x += x &amp; -x) v[x] += w; } ll ask(int x) { ll ans = 0; for (; x; x -= x &amp; -x) ans += v[x]; return ans; } }; pair&lt;BaseFenwick, BaseFenwick&gt; p; Fenwick(int n) : p(n, n) {} void add(int x, ll w) { p.first.add(x, w), p.second.add(x, x * w); } void add(int l, int r, ll w) { add(l, w), add(r + 1, -w); } ll ask(int x) { return (x + 1) * p.first.ask(x) - p.second.ask(x); } ll ask(int l, int r) { return ask(r) - ask(l - 1); }} t(N);struct Query{ int o, a, b, ans; ll c;} q[N];void ask(int l, int r, const vector&lt;int&gt; &amp;id){ if (l == r) { for (int i = 0; i &lt; id.size(); ++i) if (q[id[i]].o != 1) q[id[i]].ans = l; return; } ll m = l + r &gt;&gt; 1; vector&lt;int&gt; t1, t2; for (int i = 0; i &lt; id.size(); ++i) { if (q[id[i]].o == 1) { if (q[id[i]].c &lt;= m) t1.push_back(id[i]); else t2.push_back(id[i]), t.add(q[id[i]].a, q[id[i]].b, 1); } else { ll sum = t.ask(q[id[i]].a, q[id[i]].b); if (q[id[i]].c &gt; sum) t1.push_back(id[i]), q[id[i]].c -= sum; else t2.push_back(id[i]); } } for (int i = 0; i &lt; t2.size(); ++i) if (q[t2[i]].o == 1) t.add(q[t2[i]].a, q[t2[i]].b, -1); ask(l, m, t1), ask(m + 1, r, t2);}int main(){ int n, m; vector&lt;int&gt; id; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) { id.push_back(i); scanf(\"%d%d%d%lld\", &amp;q[i].o, &amp;q[i].a, &amp;q[i].b, &amp;q[i].c); } ask(1, n, id); for (int i = 0; i &lt; m; ++i) if (q[i].o != 1) printf(\"%d\\n\", q[i].ans);} 动态开点线段树自然也是行的，不过慢了六七倍（2400ms:15744ms）… undefined 在线的做法是树套树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 5e4 + 9, M = 2e7 + 9;struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }} rk;struct Query{ int o, a, b, c;} q[N];struct Node{ int lc, rc, add; ll sum;} t[M];int n, m, tot, root[N &lt;&lt; 2];void upd(int u, int v, int &amp;rt, int l, int r, ll add);void down(int rt, int l, int r){ if (!t[rt].add) return; int m = l + r &gt;&gt; 1; upd(l, m, t[rt].lc, l, m, t[rt].add); upd(m + 1, r, t[rt].rc, m + 1, r, t[rt].add); t[rt].add = 0;}void upd(int u, int v, int &amp;rt, int l, int r, ll add){ if (!rt) rt = ++tot; if (u == l &amp;&amp; v == r) { t[rt].add += add, t[rt].sum += (r - l + 1) * add; return; } down(rt, l, r); int m = l + r &gt;&gt; 1; if (v &lt;= m) upd(u, v, t[rt].lc, l, m, add); else if (u &gt; m) upd(u, v, t[rt].rc, m + 1, r, add); else upd(u, m, t[rt].lc, l, m, add), upd(m + 1, v, t[rt].rc, m + 1, r, add); t[rt].sum = t[t[rt].lc].sum + t[t[rt].rc].sum;}ll ask(int u, int v, int rt, int l, int r){ if (!rt) return 0; if (u == l &amp;&amp; v == r) return t[rt].sum; down(rt, l, r); int m = l + r &gt;&gt; 1; if (v &lt;= m) return ask(u, v, t[rt].lc, l, m); if (u &gt; m) return ask(u, v, t[rt].rc, m + 1, r); return ask(u, m, t[rt].lc, l, m) + ask(m + 1, v, t[rt].rc, m + 1, r);}int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) { scanf(\"%d%d%d%d\", &amp;q[i].o, &amp;q[i].a, &amp;q[i].b, &amp;q[i].c); if (q[i].o == 1) rk.push_back(q[i].c); } rk.init(); for (int i = 0; i &lt; m; ++i) { if (q[i].o == 1) for (int c = rk.size() - rk.ask(q[i].c), k = 1, l = 1, r = rk.size();;) { int m = l + r &gt;&gt; 1; upd(q[i].a, q[i].b, root[k], 1, n, 1); if (l == r) break; if (c &lt;= m) r = m, k &lt;&lt;= 1; else l = m + 1, k = k &lt;&lt; 1 | 1; } else { int k = 1, l = 1, r = rk.size(); while (l &lt; r) { ll m = l + r &gt;&gt; 1, sum = ask(q[i].a, q[i].b, root[k &lt;&lt; 1], 1, n); if (sum &gt;= q[i].c) r = m, k &lt;&lt;= 1; else l = m + 1, k = k &lt;&lt; 1 | 1, q[i].c -= sum; } printf(\"%d\\n\", rk[rk.size() - l]); } }}","link":"/2019/02/28/2019-02-28-HYSBZ-3110/"},{"title":"Pixel Shuffle","text":"题目链接 题意：对一张像素图可以执行旋转、翻转、div、mix等操作，现在给出一个操作序列，问重复进行多少次这个操作序列，可以使得任意n*n的像素图变回原样。 转换一下就是：设操作序列为置换$A$，则求m使得$A^m$为全等置换（所有元素都映射到自己） 对于每个长度为$L$的循环$B$，当$m$为$B$的整数倍时，$B^m$为全等置换，所以只需要把操作序列对应的置换拆解成多个循环，求所有循环长度的LCM即可，然后题目就变成了模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define ID(x, y) ((x)*n + (y))using namespace std;struct Permutation : vector&lt;int&gt;{ Permutation(int n = 0) : vector&lt;int&gt;(n) {} friend Permutation operator*(const Permutation &amp;f, const Permutation &amp;g) { Permutation ans(f.size()); for (int i = 0; i &lt; f.size(); ++i) ans[i] = g[f[i]]; return ans; } friend Permutation inv(const Permutation &amp;f) { Permutation ans(f.size()); for (int i = 0; i &lt; f.size(); ++i) ans[f[i]] = i; return ans; } friend vector&lt;vector&lt;int&gt;&gt; cycle(const Permutation &amp;f) { vector&lt;int&gt; vis(f.size(), 0); vector&lt;vector&lt;int&gt;&gt; ans; for (int i = 0; i &lt; f.size(); ++i) if (!vis[i]) { ans.push_back(vector&lt;int&gt;()); for (int j = i; !vis[j]; j = f[j]) vis[j] = 1, ans.back().push_back(j); } return ans; }};int main(){ int t, n; char s[255] = \" \"; for (scanf(\"%d\", &amp;t); t--;) { scanf(\"%d\", &amp;n), gets(s + 1), gets(s + 1); Permutation f(n * n), g(n * n); for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) f[ID(i, j)] = ID(i, j); int b = strlen(s); for (s[b] = ' '; b; --b) if (s[b] == ' ' &amp;&amp; s[b - 1] != ' ') { int flag = s[b--] = 0; if (s[b] == '-') flag = 1, s[b--] = 0; while (s[b - 1] != ' ') --b; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) g[ID(i, j)] = s[b] == 'r' ? ID(n - j - 1, i) : s[b] == 's' ? ID(i, n - j - 1) : s[b + 1] == 'h' ? ID(i, i * 2 &lt; n ? j : n - j - 1) : s[b + 1] == 'v' ? ID(i * 2 &lt; n ? i : n + n / 2 - i - 1, j) : s[b] == 'd' ? ID(i % 2 ? i / 2 + n / 2 : i / 2, j) : s[b] == 'm' ? ID(i / 2 * 2 + j / (n / 2), j % (n / 2) * 2 + i % 2) : ID(i, j); f = flag ? f * inv(g) : f * g; } n = 1; vector&lt;vector&lt;int&gt;&gt; c = cycle(f); for (int i = 0; i &lt; c.size(); ++i) n *= c[i].size() / __gcd((int)c[i].size(), n); printf(\"%d\\n\", n); if (t) printf(\"\\n\"); }}","link":"/2019/02/28/2019-02-28-UVALive-3510/"},{"title":"","text":"什么是计算机网络？ 计算机网络(computer network)是自主计算机的互连集合。（ANDREW S. TANENBAUM） 计算机网络是利用通信设备和线路将地理位置不同的、功 能独立的多个计算机系统***连接***起来，以功能完善的网络软件实现网络的硬件、软件及资源共享和信息传递的系统。 简单来说就是连接两台或多台计算机进行通信的系统。（维基百科） 直接连接的网络12graph LRA--链路（link），专用介质（dedicated medium）---B,节点(node)或主机(host) 点到点网络 (point-to-point network) 单向(simplex) 半双工(half duplex) 全双工(full duplex) 12graph LR共享介质(shared medium), 广播, 碰撞(collision) 多路访问网络 (multiple access network) 单播(unicast) 多播(multicast) 广播(broadcast) 间接连接的网络 中间节点、路由器(router) 包(packet) 存储转发(store-and-forward) 路由选择(routing) 路由(route) 目的地(destination),下一跳(next hop) 路由表(routing table) 网络互连用路由器(或网关)连接起来构成的网络称为互连网络(internetwork 或internet)。因特网 (Internet) 是一种互连网络。 1234graph TB路由器---网络1路由器---网络2路由器---网络3 系统域网(System Area Network, SAN) 局域网(Local Area Network, LAN) 城域网(Metropolitan Area Network, MAN) 广域网(Wide Area Network, WAN) 局域网（LAN）：一般限定在较小的区域内（小于10km的范围），通常采用有线的方法连接起来。城域网（MAN）：规模局限在一座城市的范围内。广域网（WAN）：网络跨越国界、洲界，甚至遍及全球范围。个人区域网（PAN）：一般指家庭一台或多台电脑所使用的网络无线局域网（WLAN）：是指通过无线设备建立的，给支持无线通信的设备使用的，比如无线网卡，或手机上的WIFI。 什么是因特网？ISP ( Internet Service Provider) – 因特网服务提供商 终端系统(end system)：主机 运行网络应用程序 (例如，浏览器) 通信链路(communication link) 光纤, 铜线, 无线电, 卫星 传输速率=带宽 路由器(router) 因特网体系结构网络提供的服务数据链路层一般都提供3种基本服务，即无确认的无连接服务、有确认的无连接服务、有确认 的面向连接的服务。 （1）无确认的无连接服务 无确认的无连接服务是源机器向目的机器发送独立的帧，而目的机器对收到的帧不作确认。如果由于线路上的噪声而造成帧丢失，数据链路层不作努力去恢复它，恢复工作留给上层去完成。这类服务适用于误码率很低的情况，也适用于像语音之类的实时传输，实时传输情况下有时数据延误比数据损坏影响更严重。大多数局域网在数据链路层都使用无确认的无连接服务。 （2）有确认的无连接服务 这种服务仍然不建立连接，但是所发送的每一帧都进行单独确认。以这种方式，发送方就会知道帧是否正确地到达。如果在某个确定的时间间隔内，帧没有到达，就必须重新发此帧。 （3）有确认的面向连接的服务 采用这种服务，源机器和目的机器在传递任何数据之前，先建立一条连接。在这条连接上所发送的每一帧都被编上号，数据链路层保证所发送的每一帧都确实已收到。而且，它保证每帧只收到一次，所有的帧都是按正确顺序收到的。面向连接的服务为网络进程间提供了可靠地传送比特流的服务。 开放系统互连参考模型网络性能分析","link":"/2019/04/11/2019-03-06-计算机网络 第一章 概述/"},{"title":"","text":"课后作业 Write an essay describing a research problem in your major that would benefit from the use of parallel computing. Provide a rough outline of how parallelism would be used. Would you use task- or data-parallelism? 一组数据是否适合使用并行计算，主要有三条判断标准： 能否将工作分解成为方便同时处理的离散成分； 能否随时并且及时的执行多个程序指令； 多处理单元解决该问题的耗时小于单处理单元。 满足上述三个条件，就可以使用并行计算，也就是说，在并行计算系统中，需要将一个应用分解成多个子任务，分配给不同的处理单元，各个处理单元之间相互协同，并行地执行子任务，从而达到加速的目的。 我想到的是在图像处理领域的应用。有个日本技术宅在GitHub上开源了一个项目nagadomi/waifu2x，获得了13k+的Stars；它使用卷积神经网络对动漫风格的图片进行放大操作（也支持照片），可以在官方网站进行简单的体验，对于二次元图片来说，扩图降噪一次搞定，效果非常之好，可谓是神器了。原理是基于人工智能神经网络运算，作者将一堆 gal 的图片缩小再把他们的原图放到一起，让 waifu 去学习如何放大拉伸，所以一般 waifu 下来都有一个 model 文件夹，这东西就是他的训练集，相当于人的大脑。 每一幅图像，都可以理解为是一个或多个矩阵，而矩阵数据元素之间，从存储和处理上来看，本身就十分整齐，有很高的相关性，非常方便线程模型对其进行批量存取和处理；图像处理算法对于其中的像素点来说往往有较强的规律性，如果算法本身不是有很强的先后时序或逻辑上的先后依赖性，大多易于拆解为能够并行处理的若干单元，处理方法相同而只是像素数据不同；当要处理的点很多时，多处理单元的耗时往往远远小于单处理单元。 因此，图像数据几乎天生就适合使用并行计算来进行处理；使用并行计算来处理图像，最大的优势在于运算速度快。以上面举例的waifu2x算法为例，它同时有针对NVIDIA CUDA并行优化的版本和针对CPU的串行版本。理想情况下，假设现在CPU处理一个点的平均时间是1ms，而GPU每个线程处理一个点平均需要100ms。对于一个大小为$10\\times 10$个点的任务，CPU依次处理完这些点需要100ms，GPU同时处理这100个点也需要100ms的时间，这时候，两者的区别不大。而当我们把任务换成$100\\times 100$大小的时候，CPU需要10000ms来处理，而GPU依然是100ms，此时，GPU的优势就体现出来了。如果是大小为$1000\\times 1000$的点，GPU的运算速度将比CPU快若干个数量级。实际情况下也是如此，我在自己的机器上测试，使用waifu2x的并行算法将一张图片拉到4k只需要几秒，而CPU跑了快五分钟。 当然，这并不是说所有图像并行计算速度都比串行计算快，由于受到处理器核心速度、缓存大小和单元间通信等条件影响，串行计算硬件的运算速度，往往要快于并行计算单个处理单元或处理线程的平均速度。对于要进行相同计算的点数量较少的图像，串行计算的速度或许具有一定优势，但是，当图像中需要处理的点超过一定数量时，并行计算的优势就体现出来了。可以说，要处理的点越多，并行计算的速度优势就越明显。 需要注意的是，这里所说的“点”并不一定是特指图像中的像素，也有可能是同样一套图像处理算法在某个位置的运算过程和结果。通常，在图像处理领域中更多使用的是数据并行。 Assume that you have the followiog mix of instructions with average CPIs: % of Mix Average CPI ALU 47% 6.7 Load 19% 7.9 Branch 20% 5.0 Store 14% 7.1 The dock rate for this machine is 1 GHz. You want to improve the performance of this machine, and are considering redesigning your multiplier to reduce the average CPI of multiply instructions. (Digress - why do multiplies take longer than adds?) If you make this change, the CPI of multiply instructions would drop to 6 (from 8). The percentage of ALU instructions that are multiply instructions is 23%. How much will perlormance improve by? 乘法器慢于加法器，是因为乘法电路是由更基本加法电路组成的。 ALU除了乘法之外部分的平均CPI：$(6.7-8\\times 23%)/77%\\approx 6.3$ 优化乘法之后ALU的平均CPI：$6.3\\times 77%+6\\times 23%\\approx 6.24$ 原先的平均CPI：$6.7\\times 47%+7.9\\times 19%+5.0\\times 20%+7.1\\times 14%=6.644$ 优化乘法之后的平均CPI：$6.24\\times 47%+7.9\\times 19%+5.0\\times 20%+7.1\\times 14%=6.4278$ 因此性能被优化了$(6.644-6.4278)/6.644\\approx 3.25%$","link":"/2019/04/11/2019-03-04-并行与分布式计算（1）/"},{"title":"计算机网络 第二章 物理层","text":"通信系统(Communication System)Information(信息) can be interpreted as a message(data), recorded as signs(符号), transmitted as signals(信号), measured as the entropy(熵)。 信号(signal) : optical signal, electronic signal, radio signal 模拟信号(analog signal)：连续取值的信号 数字信号(digitial signal)：用离散值表示的信号（跳变信号） 模拟传输(analog transmission): 模拟信号(analog signal), 放大器(amplifier) 数字传输( digital transmission): 数字信号(digital signal), 中继器(repeater) 正弦波信号 $\\omega_c$ ：角频率。$\\omega_c=2\\pi f$ f：频率 (frequency) $f=1/T$ T:周期 (period) A:振幅 (amplitude) $\\phi$: 相位 (phase) ( 初 相 ) 。 频移键控 (Frequency-Shift Keying, FSK)幅移键控 (Amplitude-Shift Keying, ASK)相移键控 (Phase-Shift Keying, PSK)正交调幅 (QAM –quadrature amplitude modulation)编码单极编码(unipolar encoding)不归零编码 (Non-Return-to-Zero,NRZ或NRZ-L)不归零编码是一种双极编码(bipolar encoding)。双极编码的波形就是二 进制符号，0、1分别与正、负电位相对应。它的电脉冲之间也无间隔。 RS-232C的接口电压就是采用双极编码 曼彻斯特编码(Manchester Encoding)曼彻斯特码的编码规则(以太网)是：0 → 10， 1 → 01 差分曼彻斯特编码 (Differential Manchester Encoding)差分曼彻斯特码是一种差分双相码，先把输入的NRZ波形变换成差分波形 ，再用绝对双相码(第一个规则)编码，即，”1”起始不跳变，”0”起始跳变， 再用Manchester编码第一规则按当前电平进行编码。简单描述：起始是否 跳变确定是否0或1，中间一定跳变。 4B/5B编码用5比特表示4比特。 每个编码没有多于1个的前导零和多于2个的末端 零。如果结合NRZI编码，就可以既防止跳变过多，又消除基线漂移和 时钟漂移。其它编码用于控制，如，11111表示空闲。 物理介质(Physical Media)有线介质非屏蔽双绞线(Unshielded Twisted Pair) 四对线: 绿 绿白，橙 橙白，蓝 蓝白，棕棕白 每对线先逆时针绞在一起，然后所有线对再逆时针绞在一起。 标准568A：绿白 1，绿 2，橙白 3，蓝 4，蓝白 5，橙 6，棕白 7，棕 8 标准568B：橙白 1，橙 2，绿白 3，蓝 4，蓝白 5，绿 6，棕白 7，棕 8 屏蔽双绞线 (Shielded Twisted Pair)光导纤维 (Optical Fiber) 在玻璃纤维传输光脉冲, 每个脉冲一比特 全反射条件: 入射角大于临界角 单模光纤和多模光纤阶跃光纤渐变光纤无线介质(大气) 地面微波 45 Mbps channels WiFI 54 Mbps(802.11g),600Mbps(802.11n) 3G网络 ~ 1 Mbps 卫星 1 Kbps ~ 45Mbps 270 msec 延迟 电磁谱多路复用和电路交换 时分多路复用(Time Division Multiplexing) (STDM–Synchronous TDM) 频分多路复用(Frequency Division Multiplexing) 波分多路复用(Wavelength Division Multiplexing) 码分多路复用(Code Division Multiplexing)：3G中使用的CDMA通过编码的方式 波分多路复用和统计多路复用","link":"/2019/03/06/2019-03-06-计算机网络 第二章 物理层/"},{"title":"","text":"习题1.1 为求全局总和例子中的my_first_i和my_last_i推导一个公式。需要注意的是：在循环中，应该给各个核分配数目大致相同的计算元素。 （ 提示： 先考虑n 能被 p 整除的情况）。 123456&gt; for (my_i = my_first_i my_i &lt; my_last_i; ++my_i)&gt; {&gt; my_x = Compute_next_value(...);&gt; my_sum += my_x;&gt; }&gt; 可以看出对于每个核心$i$，其对应累加的范围是左闭合区间$[my_first_i,my_last_i)$。 假设所有$p$个核心的编号是$0,1,\\ldots,p-1$，显然对于除了最后一个核心之外，其余核心的区间长度都应当是$\\lceil\\frac{n}{p}\\rceil$，其中$\\lceil\\rceil$表示向上取整。 因此，可以得到结果： 对于每个核心$i$，显然有$my_first_i=(i-1)\\times\\lceil\\frac{n}{p}\\rceil$； 对于最后一个核心$i=p$，显然有$my_last_i=n-1$ 对于除了最后一个核心之外的每个核心$i$，有$my_last_i=my_first_(i+1)=i\\times\\lceil\\frac{n}{p}\\rceil$ 1.6在下列情况中，推到公式求出 0 号核执行接受与加法操作的次数。 最初的求全局总和的伪代码 0号核接受其余$p-1$个核的结果并把它们加起来，因此执行了$p-1$次接受操作和$p-1$次加法操作。 树形结构求全局总和 在树形结构除了根节点那一层的每一层里，0号核心都接受相邻节点的结果并把它和自己的结果相加，而树形结构有$\\lceil\\log_2n\\rceil+1$层，因此进行了$\\lceil\\log_2n\\rceil$次护额受操作和加法操作。 制作一张表来比较这两种算法在总核数是$2,4,8,\\ldots,1024$时，0 号核执行的接收与加法操作的次数 总核数 最初的分块法 树形求和法 2 1 1 4 3 2 8 7 3 16 15 4 32 31 5 64 63 6 128 127 7 256 255 8 512 511 9 1024 1023 10 2.2 请解释在 CPU 硬件里实现的一个队列，怎么使用可以提高写直达高速缓存（write-through cache）的性能。 队列的特点是队尾插入队首删除。要提高写直达高速缓存的性能，就要尽量避免频繁操作主存区。因此，可以只将队首和队尾元素放进缓存区，仅在插入删除时更新缓存区。 2.3 回顾之前一个从缓存读取二维数组的示例。请问一个更大矩阵和一个更大的缓存是如何影响两对嵌套循环的性能的？如果 MAX = 8，缓存可以存储 4 个缓存行，情况又会是怎样的？在第一对嵌套循环中对 A 的读操作，会导致发生多少次失效？第二对嵌套循环中的失效次数又是多少？ 12345678910&gt; double A[MAX][MAX], x[MAX], y[MAX];&gt; /* First pair of loops */&gt; for (i = 0; i &lt; MAX; ++i)&gt; for (j = 0; j &lt; MAX; ++j)&gt; y[i] += A[i][j] * x[j];&gt; /* Second pair of loops */&gt; for (j = 0; j &lt; MAX; ++j)&gt; for (i = 0; i &lt; MAX; ++i)&gt; y[i] += A[i][j] * x[j];&gt; Cache Line Elements of A 0 A[0][0] A[0][1] A[0][2] A[0][3] 1 A[1][0] A[1][1] A[1][2] A[1][3] 2 A[2][0] A[2][1] A[2][2] A[2][3] 3 A[3][0] A[3][1] A[3][2] A[3][3] 更大的缓存会增加两个循环的性能，其中第一个循环性能增加更多，因为第一个循环是操作的内存地址都是相邻的，缓存增加后从主存中读取元素的次数减少了。同理，更大的矩阵会显著降低第一个循环的性能，而对第二个循环的影响较小。 MAX=8时，第一对循环的读操作一行有两次缺失的发生，会发生$2\\times 8=16$次失效。第二对循环一列有八次缺失的发生，会发生$8\\times 8=64$次失效。 2.16 假定一个串行程序的运行时间为$𝑇{串行} = 𝑛^2$，运行时间的单位为毫秒。并行程序的运行时间为$𝑇{并行} = 𝑛^2/𝑝 + \\log_2𝑝$。对于n 和p 的不同值，请写出一个程序并找出这个程序的加速比和效率。在 𝑛 = 10 、 20 、 40 、 …、 320 和𝑝 = 1 、 2 、 4 、 …、 128 等不同情况下运行该程序。当 𝑝 增加、 n 保持恒定时，加速比和效率的情况分别如何？当p 保持恒定而n 增加呢？ 如下这段c语言矩阵加法的程序，随着n的增加，运行时间成二次增长，其对应的并行版本的时间$𝑇{并行} = 𝑛^2/𝑝 + T{开销}$。 12345678#define N 320#define double lfvoid addMatrix(lf a[N][N], lf b[N][N]){ for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; N; ++j) a[i][j] += b[i][j];} p增加，n保持恒定的时候，加速比先增后降，效率降低。 p保持恒定，n增加的时候，加速比增加，效率增加。 假设$𝑇{并行}=𝑇{串行}/𝑝+𝑇_{开销}$，我们固定p 的大小，并增加问题的规模。 请解释如果$𝑇{开销}$比$𝑇{串行}$增长得慢，随着问题规模的增加，并行效率也将增加。 请解释如果$𝑇{开销}$比$𝑇{串行}$增长得快，随着问题规模的增加，并行效率将降低。 $E=\\frac{T_{串行}}{pT_{并行}}=\\frac{T_{串行}}{p(𝑇{串行}/𝑝+𝑇{开销})}=\\frac{1}{1+p\\frac{T_{开销}}{T_{串行}}}$,显然$\\frac{T_{开销}}{T_{串行}}$越大,效率E越小,反之亦然.因此: 如果$𝑇{开销}$比$𝑇{串行}$增长得慢，随着问题规模的增加，$\\frac{T_{开销}}{T_{串行}}$减小,并行效率E增加。 如果$𝑇{开销}$比$𝑇{串行}$增长得快，随着问题规模的增加，$\\frac{T_{开销}}{T_{串行}}$增加,并行效率将降低。 2.17 如果一个并行程序所获得的加速比可以超过 𝑝（进程或线程的个数），则我们有时称该并行程序拥有超线性加速比（superlinear speedup）。然而，许多作者并不将能够克服“资源限制”的程序视为是拥有超线性加速比。例如，当一个程序运行在一个单处理器系统上时，它必须使用二级存储，当它运行在一个大的分布式内存系统上时，它可以将所有数据都放置在主存上。请给出另外一个例子，说明程序是如何克服资源限制，并获得大于𝑝的加速比的。 当一个程序串行运行的时候，某些资源可能会在程序的不同阶段被重复加载。并行运行的时候，这些资源可以只加载一次，然后进程/线程可以共享，避免重复加载。 2.19 假定$𝑇{串行}=𝑛,𝑇{并行}=𝑛/𝑝+\\log_2𝑝$， 时间单位为毫秒。如果以倍率 𝑘 增加 𝑝，那么为了保持效率值得恒定，需要如何增加 𝑛？请给出公式。如果我们将进程数从 8 加倍到 16，则 𝑛 的增加又是多少？该并行程序是可扩展的吗？ $E=\\frac{T_{串行}}{pT_{并行}}=\\frac{n}{p(n/p+\\log_2p)}=\\frac{n}{n+plog_2p}=\\frac{1}{1+\\frac{p}{n}\\log_2p}$恒定，则$\\frac{p}{n}\\log_2p\\equiv c$，其中c为常数。以kp代替p，$n’$代替$n$到左式，有$\\frac{p}{n}\\log_2p=\\frac{kp}{n’}\\log_2kp$，即$n’=nk\\frac{\\log_2kp}{\\log_2p}$，因此需要以$k\\frac{\\log_2k+log_2p}{\\log_2p}$的倍率增加n。 p从8到16时，即k=2，代入得n增加的倍率为$2\\times\\frac{1+3}{3}=\\frac{8}{3}$。 该并行程序是可扩展的，因为对于任意一个n都可以找到一个对应的相等规模的p解决问题。 2.20 一个可以获得线性加速比的程序是强可扩展的吗？请解释。 是。如果一个程序获得了线性加速比，那么问题规模就可以认为是一个常数，且这个常数不随着p的变化而变化，我们只需要线性增加进程/线程数量，就能使线性加速后的程序以相同的效率解决不断增加的问题，无需同时增加问题大小。所以这样的程序是强可扩展的程序。","link":"/2019/04/11/2019-03-06-超级计算机原理与操作（1）/"},{"title":"计算机网络 第三章 数据链路层","text":"概述 数据链路层负责把数据包从一个节点通过链路（直连网络或物理网络）传给相邻的另一个节点。 主机和路由器是节点(nodes) 连接相邻节点的通道是链路(links) 有线链路(wired links) 无线链路(wireless links) 局域网(LANs) 第2层的数据包(packet)是帧(frame) 功能 形成帧 (framing) 差错检测(error detect)：比特错，纠错 差错控制(error control)：丢包、重复、错序。流控制(flow control) 介质访问控制(medium access control): 多路访问，碰撞(collision) 差错检测1234567graph LR数据报--&gt;数据报|校验码数据报|校验码--链路--&gt;可能发生比特错可能发生比特错--&gt;数据报&apos;|校验码&apos;数据报&apos;|校验码&apos;--&gt;有错？有错？--有--&gt;纠错或丢弃有错？--无--&gt;数据报 奇偶校验检验和(Checksum)由于需要使用加法器实现算法，校验和一般不用于数据链路层 ，而是更高层，例如 ，IP层和传输层。 循环冗余校验码(Cyclic Redundancy Check, CRC)如果传输过程中没有出现比特错，接 收方用相同的除数去除数据加CRC校 验码，余数应该为0。(Cyclic Redundancy Check, CRC) 采用模2除法：做减法时没有借位，类似于按位异或。 链路层常用CRC检验，因为容易用硬件实现，速度快，检错率很高。 CRC-CCITT(x16+x12+x5+1)的错误检测能力：可以检出所 有随机奇数位错误和双位错，可以检出所有长度小于等 于16位的突发错；对于长度等于17位的突发错误，检错 率为99.9969%；长度大于等于18位的突发错误，检错率 为99.9985%。 可靠数据传输停等协议滑动窗口协议PPP协议","link":"/2019/03/08/2019-03-08-计算机网络 第三章 数据链路层/"},{"title":"2015-2016 Petrozavodsk Winter Training Camp, SPb SU + SPb AU Contest","text":"Greedy Game12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define A first#define B secondusing namespace std;const int N = 1e5 + 7;pair&lt;int, int&gt; p[N];priority_queue&lt;int&gt; q;int n;int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;p[i].A); for (int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;p[i].B); sort(p, p + n); long long ans = 0; for (int i = n - 2; i &gt;= 0; i -= 2) { ans += p[i].B, q.push(-p[i].B); if (i &amp;&amp; p[i - 1].B &gt; -q.top()) ans += p[i - 1].B + q.top(), q.pop(), q.push(-p[i - 1].B); } printf(\"%lld\", ans);} Colored Path1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;long long, long long&gt; pii;const long long N=4e2+10;vector&lt;pii&gt; ans;long long n, k, W;long long w[N][N], c[N][N], dp[N][N];pii last[N][N];long long a[1200];long long count(long long a) { long long ret=0; while(a) a-=(a&amp;(-a)), ret++; return ret;}bool cmp(long long a, long long b) { return count(a)&lt;=count(b);}void print(long long x, long long y) { ans.push_back(pii(x, y)); if (x==1&amp;&amp;y==1) return; print(last[x][y].first, last[x][y].second);}int main() { //freopen(\"in.txt\", \"r\", stdin); scanf(\"%lld %lld %lld\", &amp;n, &amp;k, &amp;W); for(long long i=1; i&lt;=n; i++) { for(long long j=1; j&lt;=n; j++) { scanf(\"%lld\", &amp;w[i][j]); } } for(long long i=1; i&lt;=n; i++) { for(long long j=1; j&lt;=n; j++) { scanf(\"%lld\", &amp;c[i][j]); c[i][j]--; } } for(long long i=0; i&lt;(1&lt;&lt;k); i++) { a[i]=i; } sort(a, a+(1&lt;&lt;k), cmp); for(long long t=0; t&lt;(1&lt;&lt;k); t++) { long long s=a[t]; memset(dp, 0x3f, sizeof(dp)); if (!((1&lt;&lt;c[1][1])&amp;s)) continue; if (!((1&lt;&lt;c[n][n])&amp;s)) continue; dp[1][1]=w[1][1]; for(long long i=1; i&lt;=n; i++) { for(long long j=1; j&lt;=n; j++) { if (!((1&lt;&lt;c[i][j])&amp;s)) continue; if (i&gt;1) { if (dp[i-1][j]+w[i][j]&lt;dp[i][j]) { last[i][j]=pii(i-1, j); dp[i][j]=dp[i-1][j]+w[i][j]; } } if (j&gt;1) { if (dp[i][j-1]+w[i][j]&lt;dp[i][j]) { last[i][j]=pii(i, j-1); dp[i][j]=dp[i][j-1]+w[i][j]; } } } } if (dp[n][n]&lt;=W) { print(n, n); cout&lt;&lt;count(s)&lt;&lt;endl; reverse(ans.begin(), ans.end()); for(long long i=0; i&lt;ans.size(); i++) { printf(\"%lld %lld\", ans[i].first, ans[i].second); if (i==((long long)ans.size()-1)) cout&lt;&lt;endl; else cout&lt;&lt;' '; } return 0; } } cout&lt;&lt;-1&lt;&lt;endl; return 0;} Set Intersection大暴力就能苟过去…网上正解是随机化。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 12e3 + 7;bitset&lt;N&gt; a[N];char s[N];int n;int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt;= n; ++i) { scanf(\"%s\", s); for (int k = 0; s[k]; ++k) { s[k] -= 33; for (int j = 0; j &lt; 6; ++j) a[i][k * 6 + j] = s[k] &amp; 1, s[k] &gt;&gt;= 1; } for (int j = 0; j &lt; i; ++j) if ((a[i] &amp; a[j]).count() &gt;= n / 2) return printf(\"%d %d\", i + 1, j + 1), 0; }} Sort It!树状数组求完逆序对之后容斥一下就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll N = 2e3 + 7;struct Mod{ const ll M; Mod(ll M) : M(M) {} ll add(ll a, ll b) const { return ((a + b) % M + M) % M; } ll mul(ll a, ll b) const { return a * b % M; } ll pow(ll a, ll b) const { ll r = 1; for (a %= M; b; b &gt;&gt;= 1, a = mul(a, a)) if (b &amp; 1) r = mul(r, a); return r; }};struct Factorial : Mod{ vector&lt;ll&gt; fac, ifac; Factorial(int N, ll M) : fac(N, 1), ifac(N, 1), Mod(M) { for (int i = 2; i &lt; N; ++i) fac[i] = mul(fac[i - 1], i), ifac[i] = mul(M - M / i, ifac[M % i]); for (int i = 2; i &lt; N; ++i) ifac[i] = mul(ifac[i], ifac[i - 1]); } ll c(int n, int m) { return mul(mul(fac[n], ifac[m]), ifac[n - m]); }} F(N, 1e9 + 7);struct BaseFenwick{ vector&lt;ll&gt; v; BaseFenwick(int n) : v(n, 0) {} void add(int x, ll w) { for (; x &lt; v.size(); x += x &amp; -x) v[x] = F.add(v[x], w); } ll ask(int x) { ll ans = 0; for (; x; x -= x &amp; -x) ans = F.add(ans, v[x]); return ans; }};int n, p[N], b[N], ans;int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;p[i]), b[i] = 1; for (int i = 2; i &lt;= n; ++i) { int cnt = 0; BaseFenwick t(N); for (int j = 1; j &lt;= n; ++j) { t.add(p[j], b[j]); cnt = F.add(cnt, b[j] = t.ask(p[j] - 1)); } ans = F.add(ans, cnt * F.pow(i, n)); for (int j = i - 1; j; --j) { cnt = F.mul(cnt, F.M - 1); ans = F.add(ans, F.mul(cnt, F.mul(F.c(i, j), F.pow(j, n)))); } } printf(\"%d\", F.add(ans, n));}","link":"/2019/03/09/2019-03-09-2015-2016 Petrozavodsk Winter Training Camp, SPb SU + SPb AU Contest/"},{"title":"2018-2019 ACM-ICPC Southeastern European Regional Programming Contest (SEERC 2018)","text":"Broken Watch假如三根指针等长，答案是$C_n^3-3*C_{\\lfloor\\frac{n-1}{2}\\rfloor}$。 两根指针等长，在上述答案上乘2；三根指针不等长，在上述答案上乘6。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ll;ll a, b, c, n;int main(){ scanf(\"%llu%llu%llu%llu\", &amp;a, &amp;b, &amp;c, &amp;n); ll tmp[3] = {n, n - 1, n - 2}; for (ll i = 2; i &lt; 4; ++i) for (int j = 0; j &lt; 3; ++j) if (tmp[j] % i == 0) { tmp[j] /= i; break; } ll ans = tmp[0] * tmp[1] * tmp[2]; tmp[0] = n - 1 &gt;&gt; 1; tmp[1] = tmp[0] - 1; tmp[2] = n; for (int j = 0, i = 2; j &lt; 3; ++j) if (tmp[j] % i == 0) { tmp[j] /= i; break; } ans -= tmp[0] * tmp[1] * tmp[2]; if (a != b &amp;&amp; b != c &amp;&amp; c != a) ans *= 6; else if (a != b || b != c || c != a) ans *= 3; printf(\"%llu\", ans);} Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 127, INF = 1e9;vector&lt;int&gt; g[N];int n, m, ans = INF, p[N], a[N][N];int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) { fill(a[i], a[i] + n, INF); a[i][i] = 0; scanf(\"%d\", &amp;p[i]); } for (int i = 1, u, v; i &lt; n; ++i) { scanf(\"%d%d\", &amp;u, &amp;v); g[--u].push_back(--v); g[v].push_back(u); a[u][v] = a[v][u] = 1; } for (int k = 0; k &lt; n; ++k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) a[i][j] = min(a[i][j], a[i][k] + a[k][j]); for (int i = 0; i &lt; n; ++i) { vector&lt;int&gt; vis(n, 0), v; for (deque&lt;int&gt; q(vis[i] = 1, i);; q.pop_front()) { if (p[q.front()]) v.push_back(q.front()); if (v.size() &gt;= m) break; for (auto to : g[q.front()]) if (!vis[to]) q.push_back(to), vis[to] = 1; } int tmp = 0; for (auto j : v) for (auto k : v) tmp = max(tmp, a[j][k]); ans = min(ans, tmp); } printf(\"%d\", ans);} Fishermen理解这个题的意思之后提出一种新的方案：计算每条🐟对答案的贡献。因为懒的离散化，这里用风骚的动态开点线段树做掉。 undefined 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 9;typedef int ll;struct BaseFenwick{ vector&lt;ll&gt; v; BaseFenwick(int n) : v(n, 0) {} void add(int x, ll w) { for (; x &lt; v.size(); x += x &amp; -x) v[x] += w; } ll ask(int x) { ll ans = 0; for (; x; x -= x &amp; -x) ans += v[x]; return ans; }};struct Point{ int x, y, id; bool operator&lt;(const Point &amp;rhs) const { if (x != rhs.x) return x &lt; rhs.x; if (y != rhs.y) y &lt; rhs.y; return id &lt; rhs.id; }};struct Ranker : vector&lt;int&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(int y) { return lower_bound(begin(), end(), y) - begin(); }} rk;int n, m, l, ans[N];int main(){ vector&lt;Point&gt; p; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;l); for (int i = 0, x, y; i &lt; n; ++i) { scanf(\"%d%d\", &amp;x, &amp;y); p.push_back({y + x, y - x, -1}); } for (int i = 0, x; i &lt; m; ++i) { scanf(\"%d\", &amp;x); p.push_back({l + x, l - x, i}); } sort(p.begin(), p.end()); for (int i = 0; i &lt; p.size(); ++i) rk.push_back(p[i].y); rk.init(); BaseFenwick t(rk.size() + 9); for (int i = 0, j = 0; i &lt; p.size(); ++i) { for (; p[j].x &lt; p[i].x - l * 2; ++j) if (p[j].id &lt; 0) t.add(rk.ask(p[j].y) + 1, -1); if (p[i].id &lt; 0) t.add(rk.ask(p[i].y) + 1, 1); else ans[p[i].id] = t.ask(rk.ask(p[i].y) + 1) - t.ask(rk.ask(p[i].y - l * 2)); } for (int i = 0; i &lt; m; ++i) printf(\"%d\\n\", ans[i]);} Inversion首先，我们要把原序列还原，根据逆序对的性质，还原出原序列。接着，根据题意两个对集合的定义，可以知道选出的那个点集是从左到右升序的，且点集中最小的点在序列中左边没有比它更小的点，最大的点在序列中右边没有比它更大的点，所以我们可以进行dp，dp[i]表示以i为点集最后一个点的答案的数量。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 127;ll f[N];int n, m, d[N], p[N], vis[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0, x, y; i &lt; m; ++i) { scanf(\"%d%d\", &amp;x, &amp;y); ++d[min(--x, --y)]; } for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (!vis[j]) { if (d[i]) --d[i]; else { p[i] = j; vis[j] = 1; break; } } p[n] = n; for (int i = 0; i &lt;= n; ++i) { for (int j = i - 1, mx = -1; ~j; --j) if (mx &lt; p[j] &amp;&amp; p[j] &lt; p[i]) mx = p[j], f[i] += f[j]; f[i] = max(1LL, f[i]); } printf(\"%lld\", f[n]);}","link":"/2019/04/11/2019-03-20-2018-2019 ACM-ICPC Southeastern European Regional Programming Contest (SEERC 2018)/"},{"title":"ACM-ICPC World Finals 2018","text":"Comma Sprinkler1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 9;struct ID : unordered_map&lt;string, int&gt;{ vector&lt;string&gt; v; int ask(const string &amp;s) { if (count(s)) return at(s); return insert({s, v.size()}), v.push_back(s), v.size() - 1; }} id;deque&lt;pair&lt;int, int&gt;&gt; q;vector&lt;int&gt; v[N];char s[N], t[N], vis[N][2];int n, a[N];int main(){ for (; ~scanf(\"%s\", s); ++n) { int len = strlen(s); if (s[len - 1] == ',' || s[len - 1] == '.') t[n] = s[--len], s[len] = 0; v[a[n] = id.ask(s)].push_back(n); if (t[n] == ',') q.push_back({n, 1}), q.push_back({n + 1, 0}); } for (; !q.empty(); q.pop_front()) { int an = a[q.front().first], type = q.front().second; if (vis[an][type] || q.front().first &gt;= n) continue; else vis[an][type] = 1; if (type) { for (auto i : v[an]) if (!t[i]) t[i] = ',', q.push_back({i + 1, 0}); } else { for (auto i : v[an]) if (i &gt; 0 &amp;&amp; !t[i - 1]) t[i - 1] = ',', q.push_back({i - 1, 1}); } } for (int i = 0; i &lt; n; ++i) { cout &lt;&lt; id.v[a[i]]; if (t[i]) cout &lt;&lt; t[i]; cout &lt;&lt; \" \"; }} Go with the Flow12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4095;char s[99];int n, a[N], ans0, ans1;int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) scanf(\"%s\", s), a[i] = strlen(s); for (int len = *max_element(a, a + n), i = len; i &lt; n * len + n; ++i) { vector&lt;pair&lt;int, int&gt;&gt; mp, mmp; for (int j = 0, now = 0, p = 0; j &lt; n; ++j) { now += a[j] + 1; if (j + 1 &gt;= n || now + a[j + 1] &gt; i) { now = p = 0; swap(mp, mmp); mp.clear(); continue; } mp.push_back({now, 1}); while (p &lt; mmp.size() &amp;&amp; mmp[p].first &lt; now - 1) ++p; for (int k = p; k &lt; mmp.size() &amp;&amp; mmp[k].first &lt; now + 2; ++k) mp.back().second = max(mp.back().second, mmp[k].second + 1); if (ans1 &lt; mp.back().second) ans0 = i, ans1 = mp.back().second; } } printf(\"%d %d\", ans0, ans1);} Wireless is the New Fiber123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 9;set&lt;pair&lt;int, int&gt;&gt; p, q;int n, m, d[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0, u, v; i &lt; m; ++i) scanf(\"%d%d\", &amp;u, &amp;v), ++d[u], ++d[v]; for (int i = 0; i &lt; n; ++i) p.insert({d[i], i}); int t = (m = n) - 1; for (auto it : p) { if (t &gt; it.first - 1) t -= it.first - 1, q.insert(it), --m; else q.insert({t, it.second}), t = 1; } printf(\"%d\\n%d %d\\n\", m, n, n - 1); while (!q.empty()) { auto ch = *q.begin(), fa = *q.rbegin(); printf(\"%d %d\\n\", ch.second, fa.second); q.erase(ch), q.erase(fa); if (--fa.first) q.insert(fa); }}","link":"/2019/04/11/2019-03-23-ACM-ICPC World Finals 2018/"},{"title":"计算机网络 第四章 介质控制子层","text":"生成树协议(Spanning Tree Protocol) 网桥只在根端口和指定端口之间转发帧 指定端口：指定网桥上与网段连接的端口 指定网桥：网段上离根最近的网桥 如果到根网桥的最短路径有多条，可以采用最短路径上的下一网桥ID和下一个端口ID用于打破平衡（取更小的） 虚拟局域网（Virtual LAN,VLAN）如果网桥只在具有相同颜色的端口(Port) 之间转发帧，就会把原来的局域网分割成多个相互隔离的局域网，称为虚拟局域网(Virtual LAN,VLAN)。所谓的颜色其实就是VLAN ID，是由管理员为每个端口配置的，具有相同的VLAN ID的端口处于同一个VLAN，端口的默认VLAN为VLAN 1。 一个VLAN的帧只能转发到属于同一个VLAN的端口或者干道端口。只有发往干道端口的帧才需要加上VLAN ID。从干道收到的帧中如果没有VLAN ID，则认为是本征VLAN(Native VLAN)，默认为VLAN 1。发往干道的Native VLAN的帧不加VLAN ID。 CST, PVST+ and MSTP IEEE 802.1Q中定义了由所有VLAN共享一棵树的公共生成树 (Common Spanning Tree，CST) 。 具有思科专利的PVST(Per-VLAN Spanning Tree)协议为每个VLAN配置一 颗生成树。由于 PVST 只能用于ISL，思科又定义了同时可用于IEEE 802.1Q的PVST+标准。思科的设备现在默认使用PVST+。 多生成树MSTP (Multiple Spanning Tree Protocol)起初单独由IEEE 802.1s定义，后来并入IEEE 802.1Q-2005。它是RSTP的一个扩展，并可 以把VLAN分组，每个VLAN组使用一颗生成树。 BID：PRIORITY(4b)+VLAN ID(12b)+MAC addr(6B) PRIORITY(4b):0,4096,… ,32768(default),…, 61440","link":"/2019/04/11/2019-03-29-计算机网络第四章 介质控制子层/"},{"title":"Deepin中安装配置ChromeDriver","text":"查看当前的Chrome版本信息在谷歌浏览器地址栏中输入chrome://version/可以查看当前的Chrome信息： 1234567891011Google Chrome： 62.0.3202.62 (正式版本) （64 位）修订版本： 9da914b118cb0d10d715ccc4ad20575a0305a304-refs/branch-heads/3202@{#700}操作系统： LinuxJavaScript： V8 6.2.414.32Flash： 29.0.0.113 /home/wenbin/.config/google-chrome/PepperFlash/29.0.0.113/libpepflashplayer.so用户代理： Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.62 Safari/537.36命令行： /usr/bin/google-chrome-stable --flag-switches-begin --flag-switches-end可执行文件路径： /opt/google/chrome/google-chrome个人资料路径： /home/wenbin/.config/google-chrome/Default其他变体： c134752e-b8b72c88 .............. chromedriver版本 支持的Chrome版本 v2.34 v61-63 v2.33 v60-62 v2.32 v59-61 v2.31 v58-60 v2.30 v58-60 v2.29 v56-58 v2.28 v55-57 v2.27 v54-56 v2.26 v53-55 v2.25 v53-55 v2.24 v52-54 v2.23 v51-53 v2.22 v49-52 v2.21 v46-50 v2.20 v43-48 v2.19 v43-47 v2.18 v43-46 v2.17 v42-43 v2.13 v42-45 v2.15 v40-43 v2.14 v39-42 v2.13 v38-41 v2.12 v36-40 v2.11 v36-40 v2.10 v33-36 v2.9 v31-34 v2.8 v30-33 v2.7 v30-33 v2.6 v29-32 v2.5 v29-32 v2.4 v29-32 下载对应的Chromedriver版本下载地址： 1http://npm.taobao.org/mirrors/chromedriver/ 配置将下载来的ChromeDriver解压，得到一个ChromeDriver文件我们只需要将ChromeDriver文件放到/uer/bin/路径下 1sudo cp chromedriver /usr/bin/ 测试安装是否成功编写py文件写入以下代码： 1234from selenium import webdriverdriver = webdriver.Chrome()driver.get(&quot;https://www.baidu.com&quot;) 运行之后，如果能过弹出Chrome页面，就说明安装成功：","link":"/2018/06/22/Deepin中安装配置ChromeDriver/"},{"title":"Python解释器的安装与配置","text":"下载python解释器 如下图所示，在浏览器中打开python官方网站：https://www.python.org/ 点击Downloads进入下载页面 如下图所示： 注：关于Python解释器版本的选择补充说明 附官方文档截图说明： 下载完成后选择软件包安装路径 注：路径最好不要出现中文 因为我的电脑只有一个C盘，所以为了方便管理安装的软件，我创建了一个software文件夹，然后再在software文件夹里创建对应安装包的安装文件夹 如下图：C:\\software\\python3.7 进行安装 ​ 出现如下安装界面 ​ ​ 添加python解释器的环境变量 ​ 这里我们可以选择安装到自己指定的安装目录 ​ ​ 点击进入指定目录安装，勾选的选项默认就好，不需修改 ​ 勾选的选项默认就好，不需修改 ​ 点击Browse修改Python解释器的默认安装路径 ​ 修改后的安装路径显示 ​ 点击Install进行安装 ​ ​ ​ ​ 如图所示即安装成功 ​ 测试是否安装成功 按下 win+R 组合键打开windows系统的命令终端 ​ 命令终端如下图所示 ​ 至此Python解释器即安装成功啦由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。","link":"/2018/05/15/Python解释器的安装与配置/"},{"title":"Ubuntu安装chrome浏览器和chromedriver","text":"安装chrome步骤 一. 下载chrome安装包 使⽤ubuntu上的⽕狐浏览器打开如下地址：http://www.google.cn/intl/zhCN/chrome/browser/desktop/index.html 选择安装版本，接受并安装a. 选择64bit.deb(适⽤于Deblan/Ubuntu) 点击接受并安装后，选择保存到本地a. ‘Save file’或者‘保存到本地’ 下载下来后，会保存在Dowdload⽂件中cd ~/Dowdload 切换到下载⽂件⽬录中ls 进⾏查看 二. 安装chrome浏览器 打开终端，切换到root⽤户，进⼊下载⽂件夹a. cd ~/Dowdloadb. sudo dpkg -i google-chrome-stable_current_amd64.deb 初次安装如果出现 Errors where encountered whileprocessing:google-chrome-stable 这个错误，就需要安装googlechrome-stablea. apt-get install google-chrome-stable 如果安装了google-chrome-stable后，还报错，错误信息为： Unmetdependencies. “Try apt-get -f install” with no packages (orspecify ….)a. 这个时候按照提示执⾏apt-get -f install 如果中间提示”是否继续安装” 输⼊ y v. 安装完毕后，重新执⾏第⼀步的命令 sudo dpkg -i google-chromestable_current_amd64.deb 如果此时没有报错就说明已经安装成功 三.安装chromedriver 通过百度，搜索“淘宝NPM” 寻找chromedriver下载地址，点击进⼊ 通过百度，搜索“chrome和chromedriver的对照表”，选择⾃⼰的合适的chromedriver 返回第⼀步打开的chromedriver版本⽹⻚，下载适合⾃⼰浏览器的chromedriver 下载之后，在下载⽂件夹中找到，点击右键，选择解压到当前⽬录 打开终端，将解压后的chromedriver执⾏程序，拷⻉到 /usr/bin ⽬录下cd~/Downloadsudo cp chromedriver /usr/bin 运⾏程序如果没有报错，说明选择的chromedriver的版本是正确的，如果还报错说明版本没有选对，删除下载⽂件夹中的chromedriver⽂件和 /usr/bin 中的chromedriver，重复上述步骤，选在适合⾃⼰浏览器的chromedriver下载安装","link":"/2018/07/22/Ubuntu安装chrome浏览器和chromedriver/"},{"title":"Ubuntu系统安装MySQL数据库","text":"UBuntu16.04安装MySQL 一.安装MySQl 安装前先更新软件包列表： 12在终端执行如下命令：sudo apt-get update 在Ubuntu16.04上安装MySQL： 12在终端执行如下命令：sudo apt-get install mysql-server mysql-client 在安装过程中需要你输入MySQL管理员用户（root）密码，如下图 如上即代表安装完成 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。","link":"/2018/07/22/Ubuntu系统安装MySQL数据库/"},{"title":"Ubuntu系统搭建配置Python虚拟开发环境","text":"我们知道使用Python的过程中会安装各种库、包，甚至有时候还需要Python2和Python3两种环境混合使用，慢慢的你的Python运行环境会越来越臃肿，这倒还是其次，最可怕的是，有些应用会使用到某个Python包的特定版本，我们知道同一个Python运行环境里面是不能存在同一个包的不同版本的。所有这些都是你为什么要使用Virtualenv的理由。 Virtualenv给你一个干净的Python运行环境，并能让你不同的应用,使用不同版本的包文件提供了可能，甚至使 用它可以让Python2和Python3和谐地共存。对于我们来说，我们用它的原因主要有以下几点： 12341.我们需要一个干净的Python环境，这个环境只针对我目前开发的应用；2.我们不希望多安装一个和项目无关的包，也不希望出现和其它应用有包版本冲突的问题；3.我们还需要生成一个requirements.txt用来告诉其他人我项目的依赖；4.我们不希望使用pyinstaller打包发布的过程中，给我加进来一堆没有用处的文件。 1231.搭建虚拟环境主要是为了保证环境得统一性，对于不同得应用建立专属得python环境，比如针对后台开发得django可以建立一个虚拟环境，针对爬虫开发得应用可以在建立一个虚拟环境，避免环境之间产生冲突。2.可以避免一个环境造成得安装包过的多，导致环境加载缓慢. 搭建寻开发环境详细步骤 首先检查系统是否有安装pip 123456在终端输入如下命令：pip # 查看是否安装有pippip --version# 查看安装的pip版本___________________________________pip3 # 查看是否安装有pippip3 --version # 查看安装的pip3版本 安装pip sudo apt install python-pip 安装pip3 sudo apt install python3-pip 安装 virtualenv 和 virtualenvwrapper 1234567在终端输入如下命令：pip install virtualenvpip install virtualenvwrapper# 如果python2和python3共存，则需要同时安装pip3 install virtualenvpip3 install virtualenvwrapper# virtualenvwrapper是virtualenv的扩展包，可以更⽅便的新增、删除、复制、切换虚 拟环境。 Python2的安装 Python3的安装 找到 virtualenvwrapper.sh 的路径 修改virtualenvwrapper.sh的路径 测试 python3 解释器能否正常导入 virtualenvwrapper 如下图所示即代表成功 配置环境变量 修改 .bashrc 文件（mac电脑是 .bash_profile文件） 将下列内容添加到~/.bashrc 文件中 12345#Setting virtualenv PATH for python3VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source /usr/local/bin/virtualenvwrapper.sh # virtualenvwrapper.sh的路径export WORKON_HOME=&quot;/home/python/workspace&quot; # workspace是盛放虚拟环境的文件夹（根据自己的修改）# export WORKON_HOME=$HOME/.virtualenvs # 盛放虚拟环境的文件夹也可以设置为.virtualenvs 更新环境变量 执行source ~/.bashrc 创建虚拟开发环境 Django虚拟环境 mkvitualenv -p python3 django_py3 AI虚拟环境 如此，虚拟环境即创建成功 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。","link":"/2019/07/22/Ubuntu系统搭建配置Python虚拟开发环境/"},{"title":"Ubuntu纯净卸载软件","text":"如果你关注搜索到这篇文章，那么我可以合理怀疑你被apt-get的几个卸载命令有点搞晕了。 apt-get的卸载相关的命令有remove/purge/autoremove/clean/autoclean等。具体来说： 123apt-get purge / apt-get --purge remove 删除已安装包（不保留配置文件)。 如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文件 12apt-get autoremove 删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。 12apt-get remove 删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。 12apt-get autoclean APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb。 12apt-get clean 使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。 那么如何彻底卸载软件呢？具体来说可以运行如下命令： 删除软件及其配置文件1apt-get --purge remove &lt;package&gt; 删除没用的依赖包1apt-get autoremove &lt;package&gt; 此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：1dpkg -l |grep ^rc|awk &apos;{print $2}&apos; |sudo xargs dpkg -P 当然如果要删除暂存的软件安装包，也可以再使用clean命令。","link":"/2018/07/22/Ubuntu纯净卸载软件/"},{"title":"Windows系统安装配置Pycharm","text":"下载Pycharm 使用浏览器打开Pycharm官方网站：http://www.jetbrains.com/pycharm 选择对应的系统安装包，点击DOWNLOAD进行下载(文档以Windows系统举例) 选择Pycharm软件包的安装位置 安装Pycharm 运行Windows Denfender SmartScreen 更改Pycharm默认安装位置 选择自定义Pycharm安装位置 补充说明： 64-bit 表示跟64位操作系统相关(如下图所示) .py 表示关联后缀为.py的Python相关文件 等待安装完成 配置&amp;激活Pycharm 选择主题颜色 激活Pycharm的两种方式 1.选择免费试用30天(如下图所示) 2.破解激活 通过搜索引擎搜索：lanyus 修改Windows系统的hosts文件 hosts文件所在路径：C:\\Windows\\System32\\drivers\\etc 获得’注册码‘ 如此即代表安装安装配置成功 编写并运行你的第一个Python程序 修改程序的默认存放路径 修改完程序存放路径后，需要制定Python解释器 我的安装在C:\\software\\python3.7 找到 C:\\software\\python3.7 下的 python.exe 由于篇幅短小和时间仓促,若你发现了错误请告知我。 希望我没有误导你，而是带你看了小小的新世界。","link":"/2018/05/22/Windows系统安装配置Pycharm/"},{"title":"种一棵树最好的时间是十年前其次是现在","text":"“随着年龄的增长，你会失去很多东西，你的爱人，你的工作，你的头发，你的视力。 但当你开始学习新东西的时候，不管是编程还是弹钢琴，这些都是一种加分，是一种激励” ——若宫雅子，82岁程序员。","link":"/2018/03/14/种一棵树最好的时间是十年前其次是现在/"},{"title":"ubuntu-安装Pycharm，简单粗暴的方法，三行命令行","text":"对于Ubuntu 16.10和Ubuntu 17.04，通过Ctrl + Alt + T打开终端，或通过从应用启动器搜索“terminal”，打开后，执行以下步骤： .通过命令添加PPA存储库：sudo add-apt-repository ppa:mystic-mirage/pycharm 2.如果您安装了以前的版本，请通过软件更新程序升级PyCharm。 运行命令来检查更新并安装IDE（社区版本）sudo apt updatesudo apt install pycharm-professional 或运行命令来检查更新并安装IDE（社区版本）：sudo apt updatesudo apt install pycharm 3.卸载PyCharm：要卸载PyCharm Python IDE，只需运行命令：专业版: sudo apt remove --autoremove pycharm pycharm-professional社区版: sudo apt remove --autoremove pycharm pycharm-community","link":"/2018/07/22/ubuntu-安装pycharm，简单粗暴的方法，三行命令行/"},{"title":"安装Ubuntu后要做的事","text":"Ubuntu 16.04安装完成后，还需要做一些配置才能愉快的使用，所以装完系统后还要进行一系列的优化。1.删除libreofficelibreoffice虽然是开源的，但是Java写出来的office执行效率实在不敢恭维，装完系统后果断删掉 sudo apt-get remove libreoffice-common 2.删除Amazon的链接sudo apt-get remove unity-webapps-common 3.删掉基本不用的自带软件（用的时候再装也来得及）123sudo apt-get remove thunderbird totem rhythmbox empathy brasero simple-scan gnome-mahjongg aisleriot gnome-mines cheese transmission-common gnome-orca webbrowser-app gnome-sudoku landscape-client-ui-installsudo apt-get remove onboard deja-dup 这样系统就基本上干净了。 4.安装Vim居然默认没有集成Vim神器，只能手动安装了。 sudo apt-get install vim 5.设置时间使用UTCsudo vim /etc/default/rcS 将UTC=no改为UTC=yes 6.安装Chrome通过直接下载安装Google Chrome浏览器deb包。 打开Ubuntu终端，以下为32位版本，使用下面的命令。 wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb 以下为64位版本，使用下面的命令。 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 下载好后 —————————— 32 位安装命令: sudo dpkg -i google-chrome-stable_current_i386.deb 64 位安装命令: sudo dpkg -i google-chrome-stable_current_amd64.deb —————————— 添加 Google Chrome 的PPA 安装Google Chrome浏览器官方PPA，打开终端然后运行下面的命令，下载签名密钥： wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add 然后 12345sudo sh -c &apos;echo &quot;deb http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list.d/google-chrome.list&apos;sudo apt-get updatesudo apt-get install google-chrome ———————————————— 安装Google Chrome unstable 版本： sudo apt-get install google-chrome-beta ———————————————— 安装Google Chrome beta 版本： sudo apt-get install google-chrome-unstable 7.安装搜狗输入法123456789vim /etc/apt/sources.list.d/ubuntukylin.list文件，加入ubuntu kylin的apt源deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty main然后sudo apt-get updatesudo apt-get install sogoupinyin 这样就可以apt安装和更新搜狗输入法了。 其实Ubuntu16.04自带的中文输入法挺好用的，特别对于需要经常输入拉丁字符、希腊字符的朋友。不过由于用户习惯，Sougou拼音还是需要安装的 8.安装WPS OfficeMS一直未出Linux版的Office，只能凑合着用WPS了 sudo apt-get install wps-office 9.安装Oracle Java12345sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installer 由于系统自带的是OpenJDK，卸载OpenJDK之后会带有残留，导致运行 java -version 时第一行不是java的版本号，会是Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar这个提示，导致很多检测java版本号的脚本会运行出错，因此需要手动清除残留。 sudo rm /usr/share/upstart/sessions/jayatana.conf 删除/usr/share/upstart/sessions/jayatana.conf文件，重启之后再运行java -version就不会再有Picked up JAVA_TOOL_OPTIONS: -javaagent:/usr/share/java/jayatanaag.jar提示了。 10.安装Sublime Text 312345sudo add-apt-repository ppa:webupd8team/sublime-text-3sudo apt-get updatesudo apt-get install sublime-text 11.安装经典菜单指示器12345sudo add-apt-repository ppa:diesch/testingsudo apt-get updatesudo apt-get install classicmenu-indicator 12.安装系统指示器SysPeek12345sudo add-apt-repository ppa:nilarimogard/webupd8sudo apt-get updatesudo apt-get install syspeek 13.自定义DHCP网络的DNS Server IP地址12345sudo vim /etc/dhcp/dhclient.conf文件，在第21行#prepend domain-name-servers 127.0.0.1;下一行添加如下2行使用aliyun和114的DNSprepend domain-name-servers 114.114.114.114;prepend domain-name-servers 223.5.5.5; 这样可以优先使用aliyun的dns，次要使用114的DNS。 14.安装git和vpncgit和vpn大家都懂的，程序员的好工具。 sudo apt-get install vpnc git 15.安装axelaxel是Linux命令行界面的多线程下载工具，比wget的好处就是可以指定多个线程同时在命令行终端里下载文件。 sudo apt-get install axel 安装之后，就可以代替wget用多线程下载了。 16.安装openssh-serversudo apt-get install openssh-server 安装之后，就可以在Win下用ssh工具远程登陆了，当然也多了一个安全隐患，如果不想远程登陆本机的话，可以不装openssh-server。 17.安装CMake和Qt CreatorCMake和Qt Creator是Linux下开发C++程序的神器，Ubuntu 17.10已经集成了最新版的Qt Creator （4.4.1）。 sudo apt-get install cmake qtcreator 18.安装ExFat文件系统驱动Ubuntu默认不支持exFat文件系统的挂载，需要手动安装exfat的支持 sudo apt-get install exfat-fuse 装上exfat-fuse之后就可以挂载exfat分区的磁盘了。 19.安装lnavlnav工具是在终端界面看日志的神器 sudo apt-get install lnav 装上之后在终端里就可以用lnav彩色显示日志了。 20.安装unrar系统默认不带解压缩rar文件的功能，手动安装unrar程序 sudo apt-get install unrar 装上之后就可以用命令解压缩rar文件了。 使用如下命令解压缩文件到当前目录。 unrar x test.rar","link":"/2018/06/22/安装Ubuntu后要做的事/"},{"title":"在Deepin系统下安装Anaconda","text":"运行安装Anaconda1bash Anaconda3-4.3.1-Linux-x86_64.sh 安装具体步骤在执行上一步骤之后会出现以下： 123456Welcome to Anaconda3 5.0.1In order to continue the installation process, please review the licenseagreement.Please, press ENTER to continue&gt;&gt;&gt; 按ENTER继续，然后按ENTER读取许可证。读完许可证后，系统会提示您批准许可条款： 1Do you accept the license terms? [yes|no] 选择yes继续安装此时，系统将提示您选择安装的位置。您可以按ENTER接受默认位置，或指定其他位置以进行修改。在这里我选择了其它路径的安装，安装过程需要一些时间 123456789101112131415[/root/anaconda3] &gt;&gt;&gt; /home/wenbin/anaconda3PREFIX=/home/wenbin/anaconda3installing: python-3.6.3-hc9025b9_1 ...Python 3.6.3 :: Anaconda, Inc.installing: ca-certificates-2017.08.26-h1d4fec5_0 ...installing: conda-env-2.6.0-h36134e3_1 ...installing: intel-openmp-2018.0.0-h15fc484_7 ...installing: libgcc-ng-7.2.0-h7cc24e2_2 ...installing: libgfortran-ng-7.2.0-h9f7466a_2 ...installing: libstdcxx-ng-7.2.0-h7a57d05_2 ...installing: bzip2-1.0.6-h0376d23_1 ...installing: expat-2.2.4-hc00ebd1_1 ...installing: gmp-6.1.2-hb3b607b_0 .......................... 完成后，您将收到以下输出： 1234installation finished.Do you wish the installer to prepend the Anaconda3 install locationto PATH in your /root/.bashrc ? [yes|no][no] &gt;&gt;&gt; yes 键入yes ，以便可以使用conda命令。接下来将看到以下输出： 1234567Appending source /home/wenbin/anaconda3/bin/activate to /root/.bashrcA backup will be made to: /root/.bashrc-anaconda3.bakFor this change to become active, you have to open a new terminal.Thank you for installing Anaconda3! 如果你选择了no，那么你就需要手动的将Anaconda3添加的环境变量当中请打开文本编辑器并从主目录打开文件.bashrc或.bash_profile。添加该行。 1export PATH=&quot;/&lt;path to anaconda&gt;/bin:$PATH&quot; 注意：将&lt;path-to-anaconda&gt;替换为安装的anaconda文件的实际路径。保存文件。如果您打开任何终端窗口，请关闭它们，然后打开一个新窗口。您可能需要重新启动计算机才能使PATH更改生效。 为了激活安装，你应该来源~/.bashrc文件： 1source ~/.bashrc 之后你可以验证你的安装通过使用conda命令，例如与list ： 123456789wenbin@wenbin:~$ conda list# packages in environment at /home/wenbin/anaconda3:#_ipyw_jlab_nb_ext_conf 0.1.0 py36he11e457_0 alabaster 0.7.10 py36h306e16b_0 anaconda 5.0.1 py36hd30a520_1 anaconda-client 1.6.5 py36h19c0dcd_0 anaconda-navigator 1.6.9 py36h11ddaaa_0 .............. 设置Anaconda环境查看可用的Python解释器版本： 1conda search &quot;^python$&quot; 使用最新版本的Python 3创建一个环境。我们可以通过将版本3分配给python参数来实现。 我们将调用环境my_python ，但是您可能希望为您的环境使用更具描述性的名称，特别是如果您使用环境来访问多个版本的Python。 1conda create --name my_python python=3 通过一下命令来激活环境 1source activate my_python 通过一下命令添加其他包，比如requests 1conda install --name my_python requests","link":"/2018/06/12/在Deepin系统下安装Anaconda/"},{"title":"安装谷歌拼音","text":"linux下面的中文输入法一直不给力，Ubuntu里正常使用的搜狗输入法经常突然无法输出中文（具体现象是，可以呼出搜狗输入法界面，但是候选词列表无显示）虽然用惯了搜狗输入法但是实在忍不了啦，于是痛定思痛果断换掉。 现在,google拼音输入法可以用了！ 这得感谢下面这个项目： libgooglepinyin ( A fork from google pinyin on android) 项目地址：http://code.google.com/p/libgooglepinyin/ 安装之后记录了下来，希望能为同样遇到输入法问题的人提供参考 一、1sudo apt-get install fcitx-googlepinyin 二、 在settings-&gt;Language Support里将keyboard input method system设置为fcitx 三 、注销系统，再登录 在settings-&gt;Text Entry里，添加输入源，搜索google-pinyin添加即可。","link":"/2018/06/22/安装谷歌拼音/"},{"title":"Python中的垃圾回收机制","text":"1、小整数对象池在程序中整数的使用非常的广泛，Python为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存的空间。Python中对象小整数的定义是[-5,256]，这些整数的对象是提前建立好的，不会被垃圾回收。在一个Python的程序中，所有位于这个范围内的整数使用的都是同一个对象。 1234567891011121314151617181920212223242526272829In [1]: a = -5In [2]: id(a)Out[2]: 10911520In [3]: b = -5In [4]: id(b)Out[4]: 10911520In [5]: c = 256In [6]: id(c)Out[6]: 10919872In [7]: d = 256In [8]: id(d)Out[8]: 10919872In [9]: e = 257In [10]: id(e)Out[10]: 139826489334128In [11]: f = -6In [12]: id(f)Out[12]: 139826489334064 ​ 上面中，我们可以看到范围在[-5,256]之间的整数，包含-5和256，对象在内存中的地址是相同的，同理，单个字母也是这样。 ​ 但是当定义两个相同的字符串时，引用计数为0,那么就会触发垃圾回收。 2、大整数对象池每一个大整数，均创建一个新的对象。 123456789In [14]: a = 1234In [15]: id(a)Out[15]: 139826489334576In [16]: b = 1234In [17]: id(b)Out[17]: 139826489334640 3、intern机制假如有好多个对象： 12345678a1 = \"HelloWorld\"a2 = \"HelloWorld\"a3 = \"HelloWorld\"a4 = \"HelloWorld\"a5 = \"HelloWorld\"a6 = \"HelloWorld\"a7 = \"HelloWorld\"a8 = \"HelloWorld\" python会不会创建8个对象呢？会不会在内存中开辟8个内存 空间？答案是不会的，想一下，如果我们写10000个对象，像上面那样，那岂不是会在内存中开辟10000个空间，那得占用多少的内存。所以在Python中有这样的一个机制—-&gt;intern机制， 让他只占用一个“HelloWorld”所占的空间，靠引用计数去维护何时释放。 123456789101112131415161718192021In [19]: a = 'abcd'In [20]: id(a)Out[20]: 139826471344368In [21]: b = 'abcd'In [22]: id(b)Out[22]: 139826471344368In [23]: c = bIn [24]: id(c)Out[24]: 139826471344368In [25]: del aIn [26]: del bIn [27]: id(c)Out[27]: 139826471344368 总结 小整数[-5,256]共用内存，常驻内存。 单个字符公用内存，常驻内存 单个单词，不可修改，默认开启intern机制，公用内存，引用计数为0，则销毁 字符串(含有空格)，不可修改，没开启intern机制，不共用对象，引用计数为0，销毁 12345678910111213141516171819In [30]: a = 'hello world'In [31]: b = 'hello world'In [32]: id(a)Out[32]: 139826489193264In [33]: id(b)Out[33]: 139826489192816In [34]: c = 'helloworld'In [35]: d = 'helloworld'In [36]: id(c)Out[36]: 139826486896048In [37]: id(d)Out[37]: 139826486896048 大整数不共用内存，引用计数为0，销毁 数值类型和字符串类型在Python中都是不可变的数据类型，这意味着你无法修改这个对象的值，每次对变量的修改，实际上是创建了一个新的对象。 12345678910111213141516171819In [39]: a = 110 In [40]: id(a) Out[40]: 10915200 In [41]: a += 1 In [42]: id(a) Out[42]: 10915232 In [43]: b = 'hello' In [44]: id(b) Out[44]: 139826471345768 In [45]: b = 'world' In [46]: id(b) Out[46]: 139826471344368 4、Garbage collection(GC垃圾回收)python采用的是引用计数机制为主，分代收集机制为辅的策略 当引用计数为0时，该对象的生命就结束了 引用计数机制的优点： 简单 实时性：一旦没有引用，即引用计数为0，内存就直接释放了。不用像其他机制等到特定的时机，实时性还带来一个好处：处理回收内存的时间分摊到了平时 引用计数机制的缺点： 维护引用计数消耗资源 循环引用 1234list1 = []list2 = []list1.append(list2)list2.append(list1) list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。对于如今的强大硬件，缺点1尚可接受，但是循环引用导致内存泄露，注定python还将引入新的回收机制。(分代收集) GC系统所承担的工作远比”垃圾回收”多得多。实际上，它们负责三个重要任务： 为新生成的对象分配内存 识别哪些垃圾对象 从垃圾对象那回收内存 5、垃圾回收机制 1、导致引用计数+1的情况 对象被创建，如：a = 10 对象被引用，如：b = a 对象被作为参数，传递到一个函数中，如：func(a) 对象作为一个元素，存储在容器中，如：list = [a, a] 2、导致引用计数-1的情况： 对象的别名被显示销毁，如：del a 对象的别名被赋予新的对象，如：a = 20 一个对象离开他的作用域， 如函数f执行完毕时，func函数中的局部变量(全局变量不会) 对象所在的容器被销毁，或从容器中删除对象 3、查看一个对象的引用计数 123import sysa = \"hello world\"sys.getrefcount(a) 可以查看a对象的应用计数，但是比正常计数大1，因为在调用函数的时候传入a，这会让a的引用计数+1 6、循环引用导致内存泄露​ 内存泄露： ​ 申请了某些内存，但是忘记了释放，那么这就造成了内存的浪费，久而久之内存就不够用了. 12345678910111213141516171819import gcclass ClassA(): def __init__(self): print('object born,id:%s'%str(id(self)))def f2(): while True: c1 = ClassA() c2 = ClassA() c1.t = c2 c2.t = c1 del c1 del c2#python默认是开启垃圾回收的，可以通过下面代码来将其关闭gc.disable()f2() ​ 执行f2()，进程占用的内存会不断增大。 创建了c1，c2后这两块内存的引用计数都是1，执行c1.t=c2和c2.t=c1后，这两块内存的引用计数变成2. 在del c1后，引用计数变为1，由于不是为0，所以c1对象不会被销毁;同理，c2对象的引用数也是1。 python默认是开启垃圾回收功能的，但是由于以上程序已经将其关闭，因此导致垃圾回收器都不会回收它们，所以就会导致内存泄露。 7、垃圾回收123456789101112131415161718class ClassA(): def __init__(self): print('object born,id:%s'%str(id(self)))def f2(): while True: c1 = ClassA() c2 = ClassA() c1.t = c2 c2.t = c1 del c1 del c2 gc.collect()#手动调用垃圾回收功能，这样在自动垃圾回收被关闭的情况下，也会进行回收#python默认是开启垃圾回收的，可以通过下面代码来将其关闭gc.disable()f2() ​ 有三种情况会触发垃圾回收 当gc模块的计数器达到阀值的时候，自动回收垃圾 调用gc.collect()，手动回收垃圾 程序退出的时候，python解释器来回收垃圾 8、gc模块的自动垃圾回收触发机制在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，改对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。 gc模块里面会有一个长度为3的列表的计数器，可以通过gc.get_count()获取。 例如(488,3,0)，其中488是指距离上一次一代垃圾检查，Python分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。例如： 12345print gc.get_count() # (590, 8, 0)a = ClassA()print gc.get_count() # (591, 8, 0)del aprint gc.get_count() # (590, 8, 0) 3是指距离上一次二代垃圾检查，一代垃圾检查的次数，同理，0是指距离上一次三代垃圾检查，二代垃圾检查的次数。 gc模快有一个自动垃圾回收的阀值，即通过gc.get_threshold函数获取到的长度为3的元组，例如(700,10,10)，每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器。 例如，假设阀值是(700,10,10)： 1234&gt; 当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)&gt; 当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)&gt; 当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)&gt;","link":"/2019/07/14/2017-11-17-垃圾回收/"},{"title":"NVCPC preview contest from Tailmon","text":"overview Tailmon’s Multiple 30算法显而易见，要特判各位数相加为0的情况。 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int sum=0; string s; cin&gt;&gt;s; sort(s.rbegin(),s.rend()); for(int i=0; i&lt;s.size(); ++i)sum+=s[i]-'0'; cout&lt;&lt;(sum&amp;&amp;sum%3==0&amp;&amp;s.back()=='0'?s:\"-1\")&lt;&lt;'\\n';} Tailmon’s Fibnacci Sequence12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespae std;typedef long long ll;int main(){ ll n,a=0,b=1,c,sum=1; for(cin&gt;&gt;n; --n;) { c=b; sum+=b+=a; b%=1000000007; sum%=1000000007; a=c; } cout&lt;&lt;sum&lt;&lt;'\\n';} Tailmon’s Evolution题面没有说明的是，无论输入单词间有多少空格间隔，输出时统一按一个，结尾也要空格。 12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ for(string s; cin&gt;&gt;s;) cout&lt;&lt;(s!=\"tailmon\"?s:\"angewomon\")&lt;&lt;' '; cout&lt;&lt;'\\n'; } Tailmon with God Ye判断是否要对时间最长的任务上标签。 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,sum=0,g=0; cin&gt;&gt;n; for(int i=0,t; i&lt;n; ++i) cin&gt;&gt;t,sum+=t,g=max(g,t); if(g&gt;2)sum-=g-2; cout&lt;&lt;sum&lt;&lt;'\\n';} Tailmon Compares Numbers123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;bool less(const string &amp;s0, const string &amp;s1){ if(s0.size()!=s1.size())return s0.size()&lt;s1.size(); for(int i=0; i!=s0.size(); ++i) if(s0[i]!=s1[i]) return s0[i]&lt;s1[i]; return 0;}int main(){ string s[2]; for(int i=0,pos; i&lt;2; ++i) { cin&gt;&gt;s[i]; for(pos=0; pos&lt;s[i].size()&amp;&amp; s[i][pos]=='0'; ++pos); s[i]=s[i].substr(pos); } cout&lt;&lt;(less(s[0],s[1])?'&lt;': less(s[1],s[0])?'&gt;':'=') &lt;&lt;'\\n';} Tailmon Wants to Make a Big News1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int cal(int n){ static int f[64]={0,1,2,0}; if(f[n])return f[n]; return f[n]=cal(n-1)+cal(n-2);}int main(){ int n; cin&gt;&gt;n; cout&lt;&lt;cal(n)&lt;&lt;'\\n';} Tailmon on a Chessboard卡cin读入，换C做这题。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;char chess[111][11111]= {0};int n,m,q,t,x,y,pos[111]= {0};int main(){ scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q); for(int i=1; i&lt;=n; pos[i]=i++) for(int j=1; j&lt;=m; ++j) chess[i][j]='.'; while(q--) { scanf(\"%d\",&amp;t); if(t==1) { scanf(\"%d%d%d\",&amp;t,&amp;x,&amp;y); chess[pos[x]][y]=(t==1?'w':'b'); } else { scanf(\"%d%d\",&amp;x,&amp;y); t=pos[x]; pos[x]=pos[y]; pos[y]=t; } } for(int i=1; i&lt;=n; ++i) printf(\"%s\\n\",chess[pos[i]]+1);} Tailmon Found Hakurei Shrine对于询问的每个点，既然没有摧毁并且不能到达源点，那么与它们相邻的每个点一定不可以到达（反证：如果可以到达，那么询问点只需到达该点就可转至源点，与题意矛盾；前提：地震前所有点都连通）。于是强行摧毁所有与询问点联通且非询问点的点，便得到最优解。出题人良心，凭借上述算法过不了第二个样例。原因是当上述点被摧毁后，又有新的点无法到达源点（样例中的9号点）。于是从源点DFS并避开所有询问点和摧毁点，此次DFS中没有访问到的点总数就是所求答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;struct Edge{ int from,to;}e_tmp;struct Graph:vector&lt;Edge&gt;{ int n; vector&lt;vector&lt;int&gt; &gt; a; void to_list(int _n) { n=_n; a.assign(n,vector&lt;int&gt;()); for(iterator i=begin(); i!=end(); ++i) a[i-&gt;from].push_back(i-begin()); }}g;int m,k,ans=0;bool flag[30001]={0},vis[30001]={0}; void dfs(int k){ if(flag[k]||vis[k])return; vis[k]=1; for(int i=0;i!=g.a[k].size();++i) dfs(g[g.a[k][i]].to);}int main(){ cin&gt;&gt;g.n&gt;&gt;m&gt;&gt;k; while(m--) { cin&gt;&gt;e_tmp.from&gt;&gt;e_tmp.to; g.push_back(e_tmp); swap(e_tmp.from,e_tmp.to); g.push_back(e_tmp); } g.to_list(++g.n); while(k--) { cin&gt;&gt;m; flag[m]=1; for(int i=0;i!=g.a[m].size();++i) flag[g[g.a[m][i]].to]=1; } dfs(1); for(int i=1;i!=g.n;++i) if(flag[i]||!vis[i]) ++ans; cout&lt;&lt;ans&lt;&lt;'\\n';} Tailmon %%%YSX线段树，每个节点维护的值见注释，能过样例（比赛结束所以没办法评测？）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll INF=1e18;struct SegmentTree{ struct Node { ll add,hl,hr;//该点add值，左右端点值 int ldown,rup,lman,rman,man;//依次是包含左端点的最长下降序列右端点、右…左、包含左端点的最长人字序列右端点、右…左、最长人字序列长度-1 }; vector&lt;Node&gt; v; int LAST,L,R; SegmentTree(int n):LAST(n),v(2*n+1) {} Node&amp; lv(int l,int r) { return v[l+r|l!=r]; } void push_down(Node &amp;lc,Node &amp;rc,Node &amp;fa) { lc.add+=fa.add; rc.add+=fa.add; fa.add=0; } void push_up(const Node &amp;lc,const Node &amp;rc,Node &amp;fa,int l,int r)//将区间左右相连的lc、rc归并到fa { int m=l+(r-l)/2; fa.hl=lc.hl,fa.hr=rc.hr; fa.ldown=lc.ldown; if(fa.ldown==m&amp;&amp;lc.hr&gt;rc.hl) fa.ldown=rc.ldown; fa.rup=rc.rup; if(fa.rup==m+1&amp;&amp;lc.hr&lt;rc.hl) fa.rup=lc.rup; fa.lman=lc.lman; if(fa.lman==m&amp;&amp;lc.hr&gt;rc.hl) fa.lman=max(fa.lman,rc.ldown); if(lc.rup==l&amp;&amp;lc.hr&lt;rc.hl) fa.lman=max(fa.lman,rc.lman); fa.rman=rc.rman; if(fa.rman==m+1&amp;&amp;lc.hr&lt;rc.hl) fa.rman=min(fa.rman,lc.rup); if(rc.ldown==r&amp;&amp;lc.hr&gt;rc.hl) fa.rman=min(fa.rman,lc.rman); fa.man=max(lc.man,rc.man); fa.man=max(fa.man,rc.ldown-lc.rup); fa.man=max(fa.man,fa.lman-l); fa.man=max(fa.man,r-fa.rman); if(lc.hr&lt;rc.hl)fa.man=max(fa.man,rc.lman-lc.rup); if(lc.hr&gt;rc.hl)fa.man=max(fa.man,rc.ldown-lc.rman); } void maintain(int l,int r) { Node &amp;fa=lv(l,r); if(l&lt;r) { int m=l+(r-l)/2; push_up(lv(l,m),lv(m+1,r),fa,l,r); } else { fa.ldown=fa.rup=fa.lman=fa.rman=l; fa.hl=fa.hr=fa.man=0; } fa.hl+=fa.add,fa.hr+=fa.add; } void add(int l,int r,ll val,bool out=1) { if(out)return L=l,R=r,add(1,LAST,val,0); if(L&lt;=l&amp;&amp;r&lt;=R)lv(l,r).add+=val; else { int m=l+(r-l)/2; push_down(lv(l,m),lv(m+1,r),lv(l,r)); if(L&lt;=m)add(l,m,val,0); else maintain(l,m); if(R&gt;m)add(m+1,r,val,0); else maintain(m+1,r); } maintain(l,r); }};int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; SegmentTree teemo(n); for(int i=1,d; i&lt;=n; ++i) cin&gt;&gt;d,teemo.add(i,i,d); for(int i=1,l,r,d; i&lt;=m; ++i) { cin&gt;&gt;l&gt;&gt;r&gt;&gt;d,teemo.add(l,r,d); cout&lt;&lt;teemo.lv(1,n).man+1&lt;&lt;'\\n'; }} 队友的过评测代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N=100005;const int M=N*5;int n,m,mx1L[M],mx1R[M],mx2L[M],mx2R[M],mxL[M],mxR[M],mx[M];ll a[N],Left[M],Right[M],tag[M];inline void cmax(int&amp;x,int y){if(y&gt;x)x=y;}void up(int l,int r,int x){ int mid=(l+r)&gt;&gt;1; Left[x]=Left[x&lt;&lt;1]; Right[x]=Right[x&lt;&lt;1|1]; mx1L[x]=mx1L[x&lt;&lt;1]; if(mx1L[x&lt;&lt;1]==mid-l+1&amp;&amp;Right[x&lt;&lt;1]&lt;Left[x&lt;&lt;1|1])mx1L[x]+=mx1L[x&lt;&lt;1|1]; mx1R[x]=mx1R[x&lt;&lt;1|1]; if(mx1R[x&lt;&lt;1|1]==r-mid&amp;&amp;Right[x&lt;&lt;1]&lt;Left[x&lt;&lt;1|1])mx1R[x]+=mx1R[x&lt;&lt;1]; mx2L[x]=mx2L[x&lt;&lt;1]; if(mx2L[x&lt;&lt;1]==mid-l+1&amp;&amp;Right[x&lt;&lt;1]&gt;Left[x&lt;&lt;1|1])mx2L[x]+=mx2L[x&lt;&lt;1|1]; mx2R[x]=mx2R[x&lt;&lt;1|1]; if(mx2R[x&lt;&lt;1|1]==r-mid&amp;&amp;Right[x&lt;&lt;1]&gt;Left[x&lt;&lt;1|1])mx2R[x]+=mx2R[x&lt;&lt;1]; mxL[x]=mxL[x&lt;&lt;1]; if(mxL[x&lt;&lt;1]==mid-l+1&amp;&amp;Right[x&lt;&lt;1]&gt;Left[x&lt;&lt;1|1])mxL[x]+=mx2L[x&lt;&lt;1|1]; if(mx1L[x&lt;&lt;1]==mid-l+1&amp;&amp;Right[x&lt;&lt;1]&lt;Left[x&lt;&lt;1|1])cmax(mxL[x],mid-l+1+mxL[x&lt;&lt;1|1]); mxR[x]=mxR[x&lt;&lt;1|1]; if(mxR[x&lt;&lt;1|1]==r-mid&amp;&amp;Right[x&lt;&lt;1]&lt;Left[x&lt;&lt;1|1])mxR[x]+=mx1R[x&lt;&lt;1]; if(mx2R[x&lt;&lt;1|1]==r-mid&amp;&amp;Right[x&lt;&lt;1]&gt;Left[x&lt;&lt;1|1])cmax(mxR[x],r-mid+mxR[x&lt;&lt;1]); mx[x]=max(mxL[x],mxR[x]); cmax(mx[x],max(mx[x&lt;&lt;1],mx[x&lt;&lt;1|1])); if(Right[x&lt;&lt;1]&gt;Left[x&lt;&lt;1|1])cmax(mx[x],mxR[x&lt;&lt;1]+mx2L[x&lt;&lt;1|1]); if(Right[x&lt;&lt;1]&lt;Left[x&lt;&lt;1|1])cmax(mx[x],mx1R[x&lt;&lt;1]+mxL[x&lt;&lt;1|1]);}void down(int l,int r,int x){ if(tag[x]){ tag[x&lt;&lt;1]+=tag[x]; tag[x&lt;&lt;1|1]+=tag[x]; Left[x&lt;&lt;1]+=tag[x]; Left[x&lt;&lt;1|1]+=tag[x]; Right[x&lt;&lt;1]+=tag[x]; Right[x&lt;&lt;1|1]+=tag[x]; tag[x]=0; }}void build(int l,int r,int x){ if(l==r){ Left[x]=Right[x]=a[l]; mx1L[x]=mx1R[x]=mx2L[x]=mx2R[x]=mxL[x]=mxR[x]=mx[x]=1; return; } int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,x&lt;&lt;1|1); up(l,r,x);}void update(int v,int L,int R,int l,int r,int x){ if(l&gt;=L&amp;&amp;r&lt;=R){ Left[x]+=v; Right[x]+=v; tag[x]+=v; return; } down(l,r,x); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)update(v,L,R,l,mid,x&lt;&lt;1); if(R&gt;mid)update(v,L,R,mid+1,r,x&lt;&lt;1|1); if(L==l)Left[x]+=v; if(R==r)Right[x]+=v; up(l,r,x);}int main(){ //freopen(\"aa.in\",\"r\",stdin); int i,j,l,r,x; scanf(\"%d%d\",&amp;n,&amp;m); for(i=1;i&lt;=n;++i)cin&gt;&gt;a[i]; build(1,n,1); for(i=1;i&lt;=m;++i){ scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;x); update(x,l,r,1,n,1); printf(\"%d\\n\",mx[1]); } return 0;}","link":"/2017/12/13/2017-12-13-NVCPC preview contest from Tailmon/"},{"title":"追分大作战Final·补♂课第110场","text":"Overview小标题上的链接给出了可供参考的外部地址。这套题的前身是补♂课第110场冰淇淋强迫症标程，所有代码的main函数都只由for语句构成，其余部分也尽可能地用for语句缩短代码。实际写代码的时候不要模仿。 算术运算出这道题的目的是让不会读文件末的同学学习一下应对多组数据的处理方法。 123456#include&lt;stdio.h&gt;long long a,b;int main(){ for(char c; scanf(\"%lld %c %lld\",&amp;a,&amp;c,&amp;b)!=EOF; printf(\"%lld\\n\",c=='+'?a+b:a-b));} 扩展1：scanf函数返回值成功赋值的接收参数的数量（可以为零，在首个接收用参数赋值前匹配失败的情况下），或者若输入在首个接收用参数赋值前发生失败，则为EOF。 扩展2：EOFint类型的负值整数常量表达式，通常为-1。因此喜欢压代码量的竞赛选手有时候会喜欢直接使用位取反运算符~，即像下面这样写：while(~scanf(\\*...*\\)) {} 扩展3：%c与%s%c是非格式化读入，会把空格、换行等空白符也读进来。因此，假如不知道读进来的时候有多少个空格作为间隔符，scanf(&quot;%lld %c %lld&quot;,&amp;a,&amp;c,&amp;b)通常用scanf(&quot;%lld%s%lld&quot;,&amp;a,s,&amp;b)代替，此时会跳过空白符，s[0]就是所要的可显字符，使得程序更具鲁棒性。 判断数字个数输入有空格，要用gets整行读入。 12345678910111213#include&lt;stdio.h&gt;int cnt[255]= {0};int main(){ for(char s[1023]; gets(s)!=NULL;) { for(int i=0; s[i]; ++i) ++cnt[s[i]]; for(char i='0'; i&lt;='9'; cnt[i++]=0) if(cnt[i]) printf(\"%c:%d\\n\",i,cnt[i]); }} 扩展：gets函数12char *gets(char *s);//(C11 中移除) char *gets_s(char *str,rsize_t n);//(C11 起)(可选) 成功时为str，失败时为NULL。（由于返回的是指针类型因此不返回EOF）gets()函数不进行边界检查，从而此函数对缓冲区溢出攻击极度脆弱。无法安全使用它（除非程序运行的环境限定能出现在stdin上的内容）。因此，此函数在C99的第三次勘误中被弃用，而在C11标准发布时被移除。推荐的替代品是fgets()和gets_s()，详见参考链接。 另外一种字符处理类型的题目的思路把单个字符逐个getchar进来，遇到间隔符'\\n'的时候开始实际处理。 12345678910#include&lt;stdio.h&gt;int cnt[255]= {0};int main(){ for(int ch; (ch=getchar())!=EOF; ++cnt[ch]) if(ch=='\\n') for(char i='0'; i&lt;='9'; cnt[i++]=0) if(cnt[i]) printf(\"%c:%d\\n\",i,cnt[i]);} 扩展：getchar定义于头文件&lt;stdio.h&gt;，成功时为获得的字符，失败时为EOF。等价于getc(stdin)。返回值类型是int，因为要区分读入的char值和int类型的EOF。 素数回文数的个数判断素数和回文数的常见套路。 12345678910111213141516171819202122#include&lt;stdio.h&gt;int isPrime(int n){ for(int i=2; i*i&lt;=n; ++i) if(n%i==0) return 0; return 1;}int isPalindromic(int n){ int m=0; for(int t=n; t; t/=10) m=m*10+t%10; return m==n;}int main(){ for(int n,ans; scanf(\"%d\",&amp;n)!=EOF; printf(\"%d\\n\",ans)) for(int i=11+(ans=0); i&lt;=n; ++i) if(isPrime(i)&amp;&amp;isPalindromic(i)) ++ans;} 另一种较优的解法手动构造回文数，判断是否为素数。考虑有多次询问，可以先生成一张回文素数表，对于每次询问直接查表。此外，下述代码中表恰好是从小到大存储的，因此可以直接二分查找第一个比n小的数的下标作为答案，在程序的执行效率上会有更优的表现，请自己实现。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int len=0,a[127]= {0};int isPrime(int n){ for(int i=2; i*i&lt;=n; ++i) if(n%i==0) return 0; return 1;}int main(){ for(int i=11; i&lt;=99; i+=11) if(isPrime(i)) a[len++]=i; for(int i=1; i&lt;=9; ++i) for(int j=0; j&lt;=90; j+=10) if(isPrime(i*101+j)) a[len++]=i*101+j; for(int n,ans; scanf(\"%d\",&amp;n)!=EOF; printf(\"%d\\n\",ans)) for(int i=ans=0; i!=len; ++i) if(n&gt;=a[i]) ++ans;} 扩号匹配很推荐一做的题目，多个括号之间如何确定配对关系？从待匹配的地址出发，遇到右括号就将计数器加一，遇到左括号把计数器减一，当计数器的值为0的时候就是成功匹配了。很有益的思想。 123456789101112131415161718#include&lt;stdio.h&gt;char s[1023];int pipei(int p){ for(int cnt=1; cnt;) { if(s[--p]=='2')++cnt; else --cnt; } return p;}int main(){ for(int n; scanf(\"%d%s\",&amp;n,s)!=EOF; printf(\"\\n\")) for(int i=0; i!=n; ++i) if(s[i]=='2') printf(\"%d \",pipei(i)+1);} 加减乘除由于有多组数据，因此不可以直接读三个数据进来。先读进来前两个元素，然后再判断需不需要读第三个。 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int a,b;int main(){ for(char c; scanf(\"%d %c\",&amp;a,&amp;c)!=EOF;) { if(c=='!') { for(int i=b=1; i&lt;=a; b*=i++); printf(\"%d\\n\",b); continue; } scanf(\"%d\",&amp;b); if(!b&amp;&amp;(c=='/'||c=='%')) printf(\"error\\n\"); else printf(\"%d\\n\", c=='+'?a+b: c=='-'?a-b: c=='*'?a*b: c=='/'?a/b:a%b); }} 期末考试第二题——比较数字个数由于NULL的值通常是0，因此像下面这样直接省略也可以。 1234567891011121314#include&lt;stdio.h&gt;int main(){ for(char flag,s[2][128],cnt[256]; gets(s[0]),gets(s[1]); printf(\"%d\\n\",!flag)) { for(int i=flag=0; i!=256; cnt[i++]=0); for(int i=0; s[1][i]; ++i) ++cnt[s[1][i]]; for(int i=0; s[0][i]; ++i) if('a'&lt;=s[0][i]&amp;&amp;s[0][i]&lt;='z') if(--cnt[s[0][i]]&lt;0) flag=1; }} 期末考试第三题——最大最小数之差12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;long long p,q,len,a[31];int main(){ for(char s[31]; gets(s); printf(\"%lld\\n\",q-p)) { for(int i=p=q=len=0; s[i]; ++i) { if('0'&lt;=s[i]&amp;&amp;s[i]&lt;='9') a[len++]=s[i]-'0'; if('a'&lt;=s[i]&amp;&amp;s[i]&lt;='f') a[len++]=s[i]-'a'+10; if('A'&lt;=s[i]&amp;&amp;s[i]&lt;='F') a[len++]=s[i]-'A'+10; for(int j=0,t; j!=len; ++j)//使插入元素有序 if(a[j]&gt;a[len-1]) { t=a[j]; a[j]=a[len-1]; a[len-1]=t; } } for(int i=0; i!=len; ++i) p=p*16+a[i]; for(int i=len-1; i!=-1; --i) q=q*16+a[i]; }} 扩展：不定长的数据虽然C语言有malloc和free机制，但是在在线测试中不够实用。在实战中，用一个大小足够大的数组和一个siz标记来代替是更实用的选择。 12345#define N 100009int a[N],siz=0;a[siz++]=1;//向a尾部加一个1--siz;//去掉a尾部的元素a[--siz]; 停车场收费灵活使用条件表达式。 12345#include&lt;stdio.h&gt;int main(){ for(double t; scanf(\"%lf\",&amp;t)!=EOF; printf(\"%.2lf\\n\",t&lt;3?5:t&gt;20.5?40:2*t-1));} Inserting Something in Strings123456789101112#include&lt;stdio.h&gt;int main(){ for(char pos,s[2][15]; scanf(\"%s%s\",s[0],s[1])!=EOF; printf(\"\\n\")) { for(int i=pos=0; s[0][i]; ++i) if(s[0][pos]&lt;s[0][i]) pos=i; for(int i=0; s[0][i]; ++i) printf(\"%c%s\",s[0][i],i==pos?s[1]:\"\"); }} 有未知数的表达式递归求表达式的应用，熟悉栈结构也可以用之代替。理解运算符的结合顺序，递归展开时从低到高展开。思考题：如果表达式中有括号怎么处理？（可参考“括号匹配”这一题） 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;char s[31];int work(int l,int r){ for(int i=r; i&gt;=l; --i) { if(s[i]=='+') return work(l,i-1)+work(i+1,r); if(s[i]=='-') return work(l,i-1)-work(i+1,r); } for(int i=l,b=0; i&lt;=r; ++i) { if('0'&gt;s[i]||s[i]&gt;'9') { if(i==l)break; return b*work(i,r); } b=b*10+s[i]-'0'; if(i==r)return b; } for(int i=r; i&gt;=l; --i) if(s[i]=='^') return pow(work(l,i-1),work(i+1,r)); return l&gt;r?0:3;}int main(){ for(; scanf(\"%s\",s)!=EOF; printf(\"%d\\n\",work(0,strlen(s)-1)));}","link":"/2017/12/24/2017-12-24-补♂课第110场/"},{"title":"第4章·几何问题","text":"计算几何模板 12345Coord getCoord(){ lf x,y; return scanf(\"%lf%lf\",&amp;x,&amp;y),Coord(x,y);} 基础题目Triangle Fun按照题目意思的直接解法。 12345678910111213int main(){ int n; for(scanf(\"%d\",&amp;n); n--;) { Coord A=getCoord(),B=getCoord(),C=getCoord(), D=B+(C-B)/3.0,E=C+(A-C)/3.0,F=A+(B-A)/3.0, P=getLineIntersection(A,D,B,E), Q=getLineIntersection(B,E,C,F), R=getLineIntersection(C,F,A,D); printf(\"%.0f\\n\",fabs(Area2(P,Q,R)/2)); }} 可证明$\\triangle ABC$的面积是$\\triangle PQR$的7倍，于是有下面的解法。 12345678int main(){ int n; for(scanf(\"%d\",&amp;n); n--; printf(\"%.0f\\n\", fabs(Area2(getCoord(),getCoord(),getCoord())/14)));} Determine the Shape12345678910111213141516171819202122232425262728293031int main(){ char s[6][32]= { \"Square\", \"Rectangle\", \"Rhombus\", \"Parallelogram\", \"Trapezium\", \"Ordinary Quadrilateral\" }; int t,kase=0,ans; for(scanf(\"%d\",&amp;t); t--; printf(\"Case %d: %s\\n\",++kase,s[ans])) { ans=5; Coord p[4]= {getCoord(),getCoord(),getCoord(),getCoord()}; sort(p,p+4,cmpCoord); do { Coord &amp;a=p[0],&amp;b=p[1],&amp;c=p[2],&amp;d=p[3]; if(!sgn(Cross(b-a,d-c))||!sgn(Cross(a-d,c-b)))ans=min(ans,4); if(!sgn(Cross(b-a,d-c))&amp;&amp;!sgn(Cross(a-d,c-b))) { ans=min(ans,sgn(Dot(c-a,b-d))?3:2); if(!sgn(Dot(b-a,c-b))) ans=min(ans,sgn(Dot(c-a,b-d))?1:0); } } while(next_permutation(p,p+4,cmpCoord)); }} Athletics Track1234567int main(){ for(lf a,b,c,kase=0; ~scanf(\"%lf : %lf\",&amp;a,&amp;b); printf(\"Case %.0f: %.5f %.5f\\n\",kase+=1,a*c,b*c)) c=200/(sqrt(a*a+b*b)*atan(b/a)+a);} Tunnelling the Earth123456789101112int main(){ int n; Sphere earth(Coord3(0,0,0),6371009); for(scanf(\"%d\",&amp;n); n--;) { lf a,b,c,d; scanf(\"%lf%lf%lf%lf\",&amp;a,&amp;b,&amp;c,&amp;d); Coord3 A(earth.point(a,b)),B(earth.point(c,d)); printf(\"%.0f\\n\",fabs(Angle(A,B)*earth.r)-abs(A-B)); }} 二维几何计算Morley’s Theorem12345678910111213141516int main(){ int t; for(scanf(\"%d\",&amp;t); t--; printf(\"\\n\")) { Coord A=getCoord(),B=getCoord(),C=getCoord(),D; for(int i=0; i!=3; ++i) { lf b=Angle(A-B,C-B),c=Angle(A-C,B-C); Line BD(B,Rotate(C-B,b/3)),CD(C,Rotate(B-C,-c/3)); D=getLineIntersection(BD,CD); printf(\"%.6f %.6f \",D.X,D.Y); swap(A,B),swap(B,C); } }} That Nice Euler Circuit12345678910111213141516171819202122232425262728struct CoordCmp{ bool operator()(Coord A,Coord B) { return cmpCoord(A,B); }};int main(){ for(int e,kase=0; scanf(\"%d\",&amp;e)&amp;&amp;e; printf(\"Case %d: There are %d pieces.\\n\",++kase,--e))//读入时e本身大1个（最后一笔回到起点），因此上面得到的边数要减去一个 { vector&lt;Coord&gt; p; set&lt;Coord,CoordCmp&gt; v; for(int i=0; i&lt;e; ++i) { p.push_back(getCoord()); v.insert(p.back()); for(int j=1; j&lt;i; ++j) if(SegmentProperIntersection(p[i-1],p[i],p[j-1],p[j]))//不包含端点的相交 v.insert(getLineIntersection(p[i-1],p[i],p[j-1],p[j])); } for(set&lt;Coord,CoordCmp&gt;::iterator i=v.begin(); i!=v.end(); ++i) for(int j=1; j&lt;p.size(); ++j) if(onSegment(*i,p[j-1],p[j])) ++e; e+=2-v.size();//欧拉定理：平面图的点数V、边数E和面数F满足F=E+2-V }} Dog Distance12345678910111213141516171819202122232425262728int main(){ int I,kase=0,a[2]; lf maxd,mind,t,len[2]; Coord p[2]; vector&lt;Coord&gt; q[2]; for(scanf(\"%d\",&amp;I); I--; printf(\"Case %d: %.0f\\n\",++kase,maxd-mind)) { scanf(\"%d%d\",&amp;a[0],&amp;a[1]); for(int i=0; i&lt;2; ++i) { while(a[i]--)q[i].push_back(getCoord()); for(int j=len[i]=0; j+1&lt;q[i].size(); ++j) len[i]+=abs(q[i][j]-q[i][j+1]); p[i]=q[i].back(),q[i].pop_back(); } for(maxd=mind=abs(p[0]-p[1]); !q[0].empty()&amp;&amp;!q[1].empty();) { Coord v[2]= {q[0].back()-p[0],q[1].back()-p[1]}; t=min(abs(v[0])/len[0],abs(v[1])/len[1]); for(int i=0; i&lt;2; ++i) if(q[i].back()==(p[i]+=v[i]*=t*len[i]/abs(v[i]))) q[i].pop_back(); maxd=max(maxd,abs(p[0]-p[1])); mind=min(mind,DistanceToSegment(p[0],p[1]-v[1]+v[0],p[1])); } }} 2D Geometry 110 in 1!EPS调成1e-6，再小判定圆和直线相切受影响。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121lf getlf(){ lf x; return scanf(\"%lf\",&amp;x),x;}Coord getCoord(){ lf x=getlf(),y=getlf(); return Coord(x,y);}void printf(lf sol){ printf(\"%.6lf\",sol);}void printf(Coord sol){ printf(\"(\"),printf(sol.X),printf(\",\"), printf(sol.Y),printf(\")\");}void printf(Circle sol){ printf(\"(\"),printf(sol.c.X),printf(\",\"), printf(sol.c.Y),printf(\",\"), printf(sol.r),printf(\")\");}template&lt;typename T&gt;void printf(vector&lt;T&gt; sol){ sort(sol.begin(),sol.end(),cmpCoord); printf(\"[\"); for(int i=0; i!=sol.size(); ++i) printf(i?\",\":\"\"),printf(sol[i]); printf(\"]\");}int main(){ for(char s[128]; ~scanf(\"%s\",s); printf(\"\\n\")) { if(!strcmp(s,\"CircumscribedCircle\")) { Coord p[3]= {getCoord(),getCoord(),getCoord()}, p0=(p[1]+p[2])/2.0, p2=(p[1]+p[0])/2.0; Line l0(p0,Normal(p[2]-p[1])), l2(p2,Normal(p[0]-p[1])); Circle sol(getLineIntersection(l0,l2)); sol.r=abs(sol.c-p[1]); printf(sol); } else if(!strcmp(s,\"InscribedCircle\")) { Coord p[3]= {getCoord(),getCoord(),getCoord()}; lf arg0=(arg(p[1]-p[0])+arg(p[2]-p[0]))/2, arg2=(arg(p[1]-p[2])+arg(p[0]-p[2]))/2; Line l0(p[0],polar(1.0,arg0)), l2(p[2],polar(1.0,arg2)); Circle sol(getLineIntersection(l0,l2)); sol.r=fabs(DistanceToLine(sol.c,Line(p[0],p[2]-p[0]))); printf(sol); } else if(!strcmp(s,\"TangentLineThroughPoint\")) { Circle C(getCoord()); C.r=getlf(); Coord P=getCoord(); vector&lt;Coord&gt; ans; getTangents(P,C,ans); vector&lt;lf&gt; sol; for(int i=0; i!=ans.size(); ++i) { sol.push_back(arg(ans[i]-P)*180/PI); if(sol.back()&lt;0)sol.back()+=180; } printf(sol); } else if(!strcmp(s,\"CircleThroughAPointAndTangentToALineWithRadius\")) { Circle C(getCoord()); Coord p[2]= {getCoord(),getCoord()}; C.r=getlf(); Coord mov=Normal(p[1]-p[0])*C.r; Line L0(p[0]+mov,p[1]-p[0]),L1(p[0]-mov,p[1]-p[0]); vector&lt;Coord&gt; sol; getLineCircleIntersection(L0,C,sol); getLineCircleIntersection(L1,C,sol); printf(sol); } else if(!strcmp(s,\"CircleTangentToTwoLinesWithRadius\")) { Coord p[4]= {getCoord(),getCoord(),getCoord(),getCoord()}; lf r=getlf(); Coord mov=Normal(p[1]-p[0])*r; Line L0(p[0]+mov,p[1]-p[0]),L1(p[0]-mov,p[1]-p[0]); mov=Normal(p[3]-p[2])*r; Line L2(p[2]+mov,p[3]-p[2]),L3(p[2]-mov,p[3]-p[2]); vector&lt;Coord&gt; sol; sol.push_back(getLineIntersection(L0,L2)); sol.push_back(getLineIntersection(L0,L3)); sol.push_back(getLineIntersection(L1,L2)); sol.push_back(getLineIntersection(L1,L3)); printf(sol); } else if(!strcmp(s,\"CircleTangentToTwoDisjointCirclesWithRadius\")) { Circle C[2]; for(int i=0; i!=2; ++i) C[i].c=getCoord(),C[i].r=getlf(); lf r=getlf(); C[0].r+=r,C[1].r+=r; vector&lt;Coord&gt; sol; getCircleIntersection(C[0],C[1],sol); printf(sol); } }} 几何算法Board Wrapping凸包模板题。 123456789101112131415161718int main(){ int t,n; for(scanf(\"%d\",&amp;t); t--;) { vector&lt;Coord&gt; p; lf x,y,w,h,j,s=0; for(scanf(\"%d\",&amp;n); n--; s+=w*h) { scanf(\"%lf%lf%lf%lf%lf\",&amp;x,&amp;y,&amp;w,&amp;h,&amp;j); p.push_back(Coord(x,y)+Rotate(Coord(-w/2,-h/2),-j/180*PI)); p.push_back(Coord(x,y)+Rotate(Coord(w/2,-h/2),-j/180*PI)); p.push_back(Coord(x,y)+Rotate(Coord(-w/2,h/2),-j/180*PI)); p.push_back(Coord(x,y)+Rotate(Coord(w/2,h/2),-j/180*PI)); } printf(\"%.1f %%\\n\",s*100/PolygonArea(ConvexHull(p))); }} Airport1234567891011121314151617181920212223242526272829int main(){ int t,n,kase=0; for(scanf(\"%d\",&amp;t); t--;) { vector&lt;Coord&gt; p; for(scanf(\"%d\",&amp;n); n--;) { lf x,y; scanf(\"%lf%lf\",&amp;x,&amp;y); p.push_back(Coord(x,y)); } if(p.size()&lt;3) { printf(\"Case #%d: 0.000\\n\",++kase); continue; } vector&lt;Coord&gt; ch(ConvexHull(p)); lf ans=INF; for(int i=0; i&lt;ch.size(); ++i) { lf sum=0,len=abs(ch[i]-ch[(i+1)%ch.size()]); for(int j=0; j&lt;p.size(); ++j) sum+=Cross(ch[i]-p[j],ch[(i+1)%ch.size()]-p[j])/len; ans=min(ans,sum); } printf(\"Case #%d: %.3f\\n\",++kase,ans/p.size()); }} The Great Divide判断两凸包是否相交。 1234567891011121314151617181920212223242526272829bool ConvexPolygonDisjoint(const vector&lt;Coord&gt; &amp;ch1,const vector&lt;Coord&gt; &amp;ch2){ for(int i=0; i&lt;ch1.size(); ++i) if(inPolygon(ch1[i],ch2)) return 0; for(int i=0; i&lt;ch2.size(); ++i) if(inPolygon(ch2[i], ch1)) return 0; for(int i=0; i&lt;ch1.size(); ++i) for(int j=0; j&lt;ch2.size(); ++j) if(SegmentProperIntersection(ch1[i],ch1[(i+1)%ch1.size()],ch2[j],ch2[(j+1)%ch2.size()])) return 0; return 1;}int main(){ for(int n[2]; ~scanf(\"%d%d\",&amp;n[0],&amp;n[1])&amp;&amp;n[0]&amp;&amp;n[1];) { vector&lt;Coord&gt; P[2]; for(int i=0; i&lt;2; ++i) for(int j=0; j&lt;n[i]; ++j) { lf x,y; scanf(\"%lf%lf\",&amp;x,&amp;y); P[i].push_back(Coord(x,y)); } printf(ConvexPolygonDisjoint(ConvexHull(P[0]),ConvexHull(P[1]))?\"Yes\\n\":\"No\\n\"); }} Squares1234567891011121314151617181920212223242526272829303132int main(){ int t,n; for(scanf(&quot;%d&quot;,&amp;t); t--;) { scanf(&quot;%d&quot;,&amp;n); vector&lt;Coord&gt; p; for(int i=0; i&lt;n; ++i) { lf x,y,w; scanf(&quot;%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;w); p.push_back(Coord(x,y)); p.push_back(Coord(x,y+w)); p.push_back(Coord(x+w,y)); p.push_back(Coord(x+w,y+w)); } vector&lt;Coord&gt; ch(ConvexHull(p)); lf ans; if(ch.size()==1)ans=0; else if(ch.size()==2)ans=norm(ch[0]-ch[1]); else for(int u=ans=0,v=1,k; u&lt;ch.size(); ++u) for(;; v=(v+1)%ch.size()) if(k=sgn(Cross(ch[(u+1)%ch.size()]-ch[u],ch[(v+1)%ch.size()]-ch[v])),k&lt;=0) { ans=max(ans,norm(ch[u]-ch[v])); if(k==0)ans=max(ans,norm(ch[u]-ch[(v+1)%ch.size()])); break; } printf(&quot;%.0f\\n&quot;,ans); }} Most Distant Point from the Sea1234567891011121314151617181920212223242526int main(){ for(int n; ~scanf(\"%d\", &amp;n)&amp;&amp;n;) { lf l,r; vector&lt;Coord&gt; p; for(int i=0; i&lt;n; ++i) { scanf(\"%lf%lf\",&amp;l,&amp;r); p.push_back(Coord(l,r)); } for(l=0,r=INF; r-l&gt;EPS;) { lf m=(l+r)/2; vector&lt;Line&gt; L; for(int i=0; i&lt;n; ++i) { L.push_back(Line(p[i],p[(i+1)%n]-p[i])); L.back().p+=m*Normal(L.back().v); } if(getHalfPlaneIntersection(L).empty())r=m; else l=m; } printf(\"%.6f\\n\",l); }}","link":"/2017/12/21/2017-12-21-蓝书习题·第4章·几何问题/"},{"title":"程设项目二：圣杯战争","text":"项目概况项目名称：圣杯战争项目介绍：实现一个游戏的英雄系统、战斗系统、装备系统、技能系统等，可模拟游戏从者间的相互对抗 游戏背景圣杯战争是TYPE-MOON出品的《Fate/stay night》和《Fate/Zero》等Fate系列作品中出现的概念。广义上的圣杯战争，就是围绕着能实现持有者心愿的“圣杯”的争夺战。本项目还原了这一概念，七名御主（Master，即玩家）操纵自己的从者（Servant）互相战斗，最后一名幸存的从者及其御主赢得胜利，获得圣杯。 需求分析 项目任务书中直接要求实现英雄系统、战斗系统、装备系统。 一个完整的游戏系统中，除上述系统之外，不可避免的还要包含技能系统，包括英雄主动使用的主动技能，和战斗时自动触发的被动技能。 为游戏的可玩性、竞技性，增加Buff/DeBuff机制。实现思路从者 一开始有想过给从者加很多参数：暴击、格挡、闪避、命中……甚至包含一个根据经验值自动成长的属性系统。然而，这样过于复杂的系统，很难去平衡属性之间的数值平衡，也是没有必要的。例如，闪避过高会拖慢游戏的节奏，而暴击过高又容易使游戏失衡。作为补充，设计了多样的宝具系统和Buff/DeBuff机制。如果要追求暴击、闪避、吸血之类的属性可以设计成宝具的被动技能或者Buff/DeBuff。 从者（Servant）是TYPE-MOON世界观中的魔术现象。死后升格为超越人的存在的英雄之魂被称为“英灵”，他们通过仪式被召唤到现世，成为可以被使役的存在，即为“从者”。通常情况下召唤出的从者只是英灵本体的分身，完成任务后便会消失返回英灵之座。设计的从者类class Servant包含属性见下表。 变量名 作用 备注 NAME 表示从者名称 仅在初始化时赋值 HP 表示血量，范围[0,100]，0表示从者死亡 调用接口函数addHP()时，超出范围的生命值会被自动修正到上下界；某些Buff/DeBuff会对返回值产生影响（例如【必灭】，生命值回复效果减少一半，向上取整） NP 表示能量，发动宝具主动技能的需要消耗的必要属性，范围[0,100] 调用接口函数addNP()时，超出范围的能量值会被自动修正到上下界；某些Buff/DeBuff会对返回值产生影响（同上） ATK 表示攻击，造成伤害的必要属性 调用接口函数getATK()时，某些Buff/DeBuff会对返回值产生影响(同上) DEF 表示防御，攻击属性的抗性 调用接口函数getDEF()时，某些Buff/DeBuff会对返回值产生影响（例如【破魔】，防御降低10%） CLOCK 表示生物钟，用于计算技能冷却、宝具充能、BUFF持续时间 BUFF BUFF池，存储被附加的增益状态以及对应的持续时间 DEBUFF DEBUFF池，存储被附加的减益状态以及对应的持续时间 BAR 装备栏，用于存储宝具的指针 由于装备栏中存储了宝具的指针，因此禁用了Servant类的拷贝操作和赋值操作 宝具 设计一个新从者，只需要设计他的一件专属宝具，即可带来属性、技能、装备的多样化。 宝具，是Servant所持有的武装、象征、绝招，被称为“贵い幻想（尊贵的幻想，Noble Phantasm）”。设计的宝具基类class NoblePhantasm包含如下特点： 装备时可为从者带来属性增益，脱下装备时减少相应增益。 可由从者使用主动技能。 战斗时自动触发被动技能。 目前代码中已经派生的宝具类见下表。 宝具 被动技能 主动技能 属性加成 誓约胜利之剑 远离尘世的理想乡：触发时回复1点HP 魔力放出：消耗所有NP并按比例对对手造成伤害 王之财宝 全属性+30 炽天覆七重圆环 免疫低于7的伤害 十二试炼 每三次触发获得一层试炼，最多11层；每层试炼抵抗一点致命伤害 万戒必破之符 高速神言:触发时回复5点NP 造成伤害并清除增益效果 穿刺死棘之枪 造成伤害，10%触发【逆转因果：99点额外伤害】 破魔红蔷薇&amp;必灭黄蔷薇 造成伤害，随机给对手附加Debuff【破魔】【必灭】之一 本次大作业暂时只实现以上7件宝具。事实上，要加入新的宝具，只需增加一个class NoblePhantasm的派生类即可，详见NoblePhantasm.cpp中的具体实现。 12345678sequenceDiagram从者-&gt;&gt;宝具:构造一个新的宝具对象宝具--&gt;&gt;从者:产生属性增益从者-&gt;&gt;宝具:加入装备栏从者-&gt;&gt;宝具:使用主动技能，触发被动技能从者-&gt;&gt;宝具:脱下宝具宝具--&gt;&gt;从者:去除属性增益从者-&gt;&gt;宝具:delete对应指针 战斗 单次战斗，定义成一名从者对另一从者使用某个宝具的主动技能。特别地，当这件宝具没有自定义的主动技能时，将调用宝具基类的主动技能（普通攻击）。 战斗的流程如下（参见下面的时序图）： 攻方从者触发Buff、宝具被动。 受方从者触发Buff、宝具被动。 攻方发动宝具对受方造成伤害和效果。 攻方宝具被动、Buff结算。 受方宝具被动、Buff结算。123456789sequenceDiagram攻方从者--&gt;&gt;攻方宝具:触发被动受方从者--&gt;&gt;受方宝具:触发被动攻方从者-&gt;&gt;攻方宝具:发动主动技能攻方宝具-&gt;&gt;受方从者:造成伤害和效果攻方宝具--&gt;&gt;攻方从者:被动结算受方宝具--&gt;&gt;受方从者:被动结算攻方从者--&gt;&gt;攻方从者:属性结算受方从者--&gt;&gt;受方从者:属性结算 Buff/DeBuff Buff池的代码实现使用了map&lt;string,int&gt;，来保存Buff和对应的结束时间。查找/插入一个Buff的时间复杂度为O(logN)，其中N为Buff池中Buff的数量。 Buff/DeBuff机制的实现依赖于Buff池。 战斗中Buff的触发早于宝具被动触发；结算晚于宝具被动结算。 目前代码中已经实现的Buff/DeBuff见下表。 名称 类别 效果 必灭 DeBuff HP回复效果降低50%，向上取整 破魔 DeBuff 战斗时防御为真实值的90% 防御增益（懒得取名了，下同） Buff 战斗时防御值为真实值的110%，与【破魔】可叠加，效果为真实防御值的99% 攻击增益 Buff 同【防御增益】 攻击减益 DeBuff 同【破魔】 能量回复减益 DeBuff 同【必灭】 增益免疫 DeBuff Buff附加抗性 减益免疫 Buff 同【增益免疫】 本次大作业暂时只实现以上8个Buff。事实上，要加入新的Buff，只需在class Servant中对应函数位置增加代码即可，详见Servant.cpp中的具体实现。 12345sequenceDiagramBuff-&gt;&gt;从者:持续时间从者--&gt;&gt;从者:计算Buff消失时间从者-&gt;&gt;Buff池:加入Buff池Buff池--&gt;&gt;Buff池:检查是否已经存在此Buff或免疫抗性\\n若存在则判断是否覆盖\\n否则直接加入 12345678910111213graph TBst1=&gt;start: 外部查询/修改从者属性op1=&gt;operation: 查询Buff/DeBuff池cond1=&gt;condition: 是否有相关Buff/DeBuff？cond2=&gt;condition: 是否在生效时间内？e=&gt;end: 查询/修改属性op2=&gt;operation: Buff/DeBuff生效st1-&gt;op1op1-&gt;cond1cond1(yes)-&gt;cond2cond1(no)-&gt;econd2(no)-&gt;econd2(yes)-&gt;op2-&gt;e 代码测试文件夹中main.cpp中保存了一段用于测试的代码，运行后得到如下输出，符合预期： 1234567891011121314151617181920212223242526272829303132333435【阿尔托莉雅】装备宝具【誓约胜利之剑】【库丘林】装备宝具【穿刺死棘之枪】【库丘林】装备宝具【破魔红蔷薇&amp;必灭黄蔷薇】【卫宫】装备宝具【王之财宝】【卫宫】装备宝具【炽天覆七重圆环】【美狄亚】装备宝具【万戒必破之符】【赫拉克勒斯】装备宝具【十二试炼】【阿尔托莉雅】当前状态：【HP:100】【NP:100】【ATK:100】【DEF:100】【宝具】:【誓约胜利之剑】【Buff】:【DeBuff】:【库丘林】对【阿尔托莉雅】释放宝具【破魔红蔷薇】，附加3回合DeBuff【破魔】，造成伤害【38】【卫宫】对【赫拉克勒斯】造成伤害【40】【赫拉克勒斯】对【卫宫】造成伤害【3】【卫宫】发动宝具【炽天覆七重圆环】，免疫本次不高于【7】的伤害【阿尔托莉雅】对【赫拉克勒斯】释放宝具【誓约胜利之剑】，造成伤害【50】【赫拉克勒斯】对【阿尔托莉雅】造成伤害【43】【阿尔托莉雅】当前状态：【HP:21】【NP:0】【ATK:100】【DEF:90】【宝具】:【誓约胜利之剑】【Buff】:【DeBuff】:【破魔】【美狄亚】对【美杜莎】释放宝具【万戒必破之符】，造成伤害【0】，并清除所有增益效果【卫宫】对【赫拉克勒斯】造成伤害【40】【赫拉克勒斯】发动宝具【十二试炼】，成功续命，剩余试炼数【0】【库丘林】对【卫宫】释放宝具【穿刺死棘之枪】，造成伤害【8】，逆转因果，造成【99】点额外伤害！【卫宫】死亡【美狄亚】NP不足 代码接口仅给出对应头文件，具体实现参照对应的cpp文件。以下所有代码均写在namespace wk中，避免命名冲突。 WkRandom.h实现一个自用的伯努利概率分布函数。根据编译器版本不同，自动选择调用&lt;random&gt;库（C++11以上）或rand()函数实现。前者的准确度要高于后者。 1bool getRand(double p);//产生随机数0/1，概率期望值为p Servant.h12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Servant{public: Servant(const std::string NAME): NAME(NAME), HP(100), NP(0), ATK(100), DEF(100), CLOCK(0) {} ~Servant();//要释放装备指针 std::string getName(); void print();//输出当前状态 //下为属性相关函数会受(De)Buff影响 int getHP(); void addHP(int,bool buff=1);//修改血量，超过上限100或下限0时自动修正 int getNP(); void addNP(int,bool buff=1);//修改能量，超过上限100或下限0时自动修正 int getATK(); void addATK(int); int getDEF(); void addDEF(int); //下为Buff/DeBuff相关 int getClock();//外界不允许修改人物技能时钟，没有set/add函数 bool hasBuff(const std::string&amp;); bool hasDeBuff(const std::string&amp;); void addBuff(const std::string&amp;,int,bool buff=1);//附加持续时间t的Buff void addDeBuff(const std::string&amp;,int,bool buff=1);//附加持续时间t的DeBuff void clearBuff(); void clearDeBuff(); //下为宝具/技能相关 void equip(NoblePhantasm*);//装备宝具（到装备栏最后） void sold();//出售（最后一件）宝具 void swapBar(int,int);//交换装备栏中宝具的次序 void pre();//触发宝具被动 void pos();//宝具被动结算 void attack(Servant &amp;defender,int k);//发动宝具k攻击敌方，k非法时退出private: const std::string NAME; int HP,//血量 NP,//能量 ATK,//攻击力 DEF,//防御力 CLOCK;//记录人物时钟 std::map&lt;std::string,int&gt; BUFF,DEBUFF;//Buff、DeBuff池 std::vector&lt;NoblePhantasm*&gt; BAR;//装备栏 Servant(const Servant&amp;);//禁用拷贝构造函数 Servant&amp; operator=(const Servant&amp;);//禁用赋值函数}; NoblePhantasm.h实现了一个宝具基类NoblePhantasm，并派生了七种各有特色的宝具类，其特性见代码注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class NoblePhantasm//宝具基类{public: virtual std::string getName()=0;//纯虚函数，每件宝具都要有自己的名字 virtual bool buy(Servant &amp;user);//虚函数，装备宝具时的属性增益 virtual bool sold(Servant &amp;user);//虚函数，脱下宝具时的属性消减 virtual bool act(Servant &amp;attacker,Servant &amp;defender);//虚函数，主动发动的技能 virtual void pre(Servant &amp;user) {} //虚函数，战斗前触发被动 virtual void pos(Servant &amp;user) {} //虚函数，战斗后被动结算 virtual ~NoblePhantasm() {} //虚函数，析构函数需要用虚函数};class Excalibur:public NoblePhantasm{public: std::string getName();//誓约胜利之剑 bool act(Servant &amp;attacker,Servant &amp;defender);//消耗自身所有NP并造成一定比例伤害 void pre(Servant &amp;user);//【远离尘世的理想乡】回复1点HP};class GateOfBabylon:public NoblePhantasm{public: std::string getName();//王之财宝 bool buy(Servant &amp;user);//无技能宝具，全属性加成30 bool sold(Servant &amp;user);};class LawAias:public NoblePhantasm{public: std::string getName();//炽天覆七重圆环 void pre(Servant &amp;user);//免疫低于7的伤害 void pos(Servant &amp;user);private: int hp;//触发被动时记录血量，结算时伤害低于7则回复};class GodHand:public NoblePhantasm{public: GodHand():mp(0),last(0) {} std::string getName();//十二试炼 void pos(Servant &amp;user);//三回合充能一次，每层充能抵抗一点致命伤害，至多11层private: int mp,last;//充能层数，前一次充能时间};class RuleBreaker:public NoblePhantasm{public: std::string getName();//万戒必破之符 bool act(Servant &amp;attacker,Servant &amp;defender);//主动技能：造成伤害&amp;消除增益效果 void pre(Servant &amp;user);//被动技能【高速神言】：NP恢复速度增加};class GaeBolg:public NoblePhantasm{public: std::string getName();//穿刺死棘之枪 bool act(Servant &amp;attacker,Servant &amp;defender);//低NP消耗&amp;&amp;造成伤害&amp;概率附加99点额外伤害};class GaeDeargBuidhe:public NoblePhantasm{public://【破魔】弱化防御；【必灭】弱化治疗 std::string getName();//破魔红蔷薇&amp;必灭黄蔷薇 bool act(Servant &amp;attacker,Servant &amp;defender);//为对手附加Debuff【破魔】【必灭】之一};","link":"/2018/10/16/2018-10-16-圣杯战争/"},{"title":"某科学的超会议议程管理系统（Scientific Meeting Management System）","text":"项目概况项目名称：某科学的超会议议程管理系统（Scientific Meeting Management System）项目介绍：基于命令行，实现添加(add)、删除(delete)、修改(modify)、查询(query)等议程管理功能。 需求分析 每次打开系统时，自动恢复上次的数据。 每次关闭系统时，将数据保存到本地。 向议程中加入一个会议，当会议与任何已有的议程都不冲突时成功加入议程，否则报错。 查询\\修改\\删除：根据关键字查询\\修改\\删除相关议程。 清空功能：将议程清空，以便重新读入。 实现思路交互示意图以下示意图中以SMMS（Scientific Meeting Management System）代表本系统，LOG代表本地缓存文件log.txt，STACK代表用于议程管理的栈结构（见后）。 123456sequenceDiagramUSER-&gt;&gt;SMMS:输入LOG-&gt;&gt;SMMS:读档SMMS-&gt;&gt;STACK:关键字搜索、操作SMMS-&gt;&gt;LOG:存档SMMS-&gt;&gt;USER:输出 使用高效的栈结构进行议程管理增加会议时只需加入栈顶，时间复杂度为O（1）。修改或删除会议时，只需将该元素和栈顶元素交换，然后对栈顶元素进行操作，时间复杂度仍为O（1）。清空议程时，只需将栈顶指针指向栈底而无需在数组中擦除数据，时间复杂度仍为O（1）。 关键字搜索 定义会议n和m相关，当且仅当满足下列任意条件： n和m同名 n和m时间有重合部分，并且地点相同或有相同人员（换言之两场会议是否不能同时举行） 基于会议相关的定义，可以判断一个会议是否能够加入议程；也可以像下面一样进行高效严密的关键字搜索。例如： 查询\\修改\\删除会议名为NAME的会议：搜索时仅需将key.name设置为”NAME”，其余设为-1。 查询\\修改\\删除地点为ADDRESS的会议：将key.address设为”ADDRESS”，起止时间分别设成负正无穷，其余设为-1。 查询\\修改\\删除含有参加人员PERSON的会议：将key.num_of_participants设为1，key.participants[0]设为”PERSON，起止时间分别设成负正无穷，其余设为-1。多人同理。 查询\\修改\\删除含有以上多关键字的，可以类似地设置key。 代码模块化，且接口全部使用文件流所有函数接口均使用文件流FILE*，为快速切换文件\\屏幕IO提供很大便利。与此相对应的，所有的IO均通过函数fscanf和fprintf实现。所有的IO均写有提示，方便使用。 项目测试同文件夹下log.txt文档中保存了用于测试的数据，运行结果均符合预期。 代码接口与实现代码实现分为数据结构和功能函数两个模块，分别对其展开介绍。所有头文件均写有头文件保护。 数据结构meeting.h 定义了一个结构体Meeting，用于描述一场会议，内容见下，未加注释。其中，struct tm是c标准库&lt;time.h&gt;中定义的用于保存时间的结构体。 定义了若干对Meeting结构体的操作。 define了一个常量MAXN，暂定为128，用来表示Meeting中所用数组的最大容量。实际使用时可根据需求修改MAXN的define并重新编译，十分方便。 123456789101112131415161718192021#define MAXN 128typedef struct Meeting{ int num_of_participants;//参会人数 char name[MAXN],//会议名称 address[MAXN],//会议地址 participants[MAXN][MAXN];//参会人员 struct tm begin,end;//起止时间} Meeting;//从in中读入一个Meeting，并将输入时的提示信息输出到outMeeting getMeeting(FILE *in,FILE *out);//把m输出到outvoid putMeeting(FILE *out,const Meeting *m);//比较两个时间a和b的先后关系int tmCmp(const struct tm *a,const struct tm *b);//判断会议m和n是否冲突int isRepel(const Meeting *m,const Meeting *n); 实现 meeting.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485Meeting getMeeting(FILE *in,FILE *out){ Meeting tmp_m; fprintf(out,\"Input the Meeting name.\\n\"); fscanf(in,\"%s\",tmp_m.name); fprintf(out,\"Input the Meeting address.\\n\"); fscanf(in,\"%s\",tmp_m.address); fprintf(out,\"Input the begin time(year month day hour minute).\\n\"); fscanf(in,\"%d%d%d%d%d\", &amp;tmp_m.begin.tm_year, &amp;tmp_m.begin.tm_mon, &amp;tmp_m.begin.tm_mday, &amp;tmp_m.begin.tm_hour, &amp;tmp_m.begin.tm_min); fprintf(out,\"Input the end time(year month day hour minute).\\n\"); fscanf(in,\"%d%d%d%d%d\", &amp;tmp_m.end.tm_year, &amp;tmp_m.end.tm_mon, &amp;tmp_m.end.tm_mday, &amp;tmp_m.end.tm_hour, &amp;tmp_m.end.tm_min); fprintf(out,\"Input the number of participants.\\n\"); fscanf(in,\"%d\",&amp;tmp_m.num_of_participants); for(int i=0; i&lt;tmp_m.num_of_participants; ++i) { fprintf(out,\"Input the name of participant %d.\\n\",i); fscanf(in,\"%s\",tmp_m.participants[i]); } return tmp_m;}void putMeeting(FILE *out,const Meeting *m){ fprintf(out,\"%s %s\\n%d %d %d %d %d\\n%d %d %d %d %d\\n%d\", m-&gt;name, m-&gt;address, m-&gt;begin.tm_year, m-&gt;begin.tm_mon, m-&gt;begin.tm_mday, m-&gt;begin.tm_hour, m-&gt;begin.tm_min, m-&gt;end.tm_year, m-&gt;end.tm_mon, m-&gt;end.tm_mday, m-&gt;end.tm_hour, m-&gt;end.tm_min, m-&gt;num_of_participants); for(int j=0; j&lt; m-&gt;num_of_participants; ++j) fprintf(out,\" %s\",m-&gt;participants[j]); fprintf(out,\"\\n\");}int tmCmp(const struct tm *a,const struct tm *b){ if(a-&gt;tm_year != b-&gt;tm_year) return a-&gt;tm_year - b-&gt;tm_year; if(a-&gt;tm_mon != b-&gt;tm_mon) return a-&gt;tm_mon - b-&gt;tm_mon; if(a-&gt;tm_mday != b-&gt;tm_mday) return a-&gt;tm_mday - b-&gt;tm_mday; if(a-&gt;tm_hour != b-&gt;tm_hour) return a-&gt;tm_hour - b-&gt;tm_hour; return a-&gt;tm_min - b-&gt;tm_min;}int isRepel(const Meeting *p,const Meeting *q){ if(!strcmp(p-&gt;name,q-&gt;name)) return 1; if(tmCmp(&amp;p-&gt;end,&amp;q-&gt;begin)&lt;0||tmCmp(&amp;p-&gt;begin,&amp;q-&gt;end)&gt;0) return 0; if(!strcmp(p-&gt;address,q-&gt;address)) return 1; for(int i=0; i &lt; p-&gt;num_of_participants; ++i) for(int j=0; j &lt; q-&gt;num_of_participants; ++j) if(!strcmp(p-&gt;participants[i],q-&gt;participants[j])) return 1; return 0;} 功能函数func.h 选用栈结构用于存储会议，用数组和记录栈顶下标的变量实现。除此之外未用任何全局变量。 实现了需求分析中的所有功能函数。 所有功能函数均有相同的接口(FILE *in,FILE *out)表示从in中获取数据，并通过out输出信息。这样的设计既方便了代码的调试，也方便了用户的交互。 1234567891011121314151617181920212223242526extern int top;extern Meeting stack[MAXN];//读入会议，若不产生冲突则加入议程，否则报错void add(FILE *in,FILE *out);//按关键字删除会议void del(FILE *in,FILE *out);//按关键字修改会议void modify(FILE *in,FILE *out);//按关键字查询会议void query(FILE *in,FILE *out);//读档void fin(FILE *in,FILE *out);//存档void fout(FILE *in,FILE *out);//清空void clear(FILE *in,FILE *out);//输出提示信息void help(FILE *in,FILE *out); 实现 func.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192int top=0;Meeting stack[MAXN];void add(FILE *in,FILE *out){ stack[top]=getMeeting(in,out); for(int i=0; i&lt;top; ++i) if(isRepel(&amp;stack[top],&amp;stack[i])) { fprintf(out,\"Error: Repel with Meeting %s.\\n\",stack[i].name); return; } fprintf(out,\"Add %s successfully.\\n\",stack[top++].name);}void del(FILE *in,FILE *out){ fprintf(out,\"Input the key(-1 for no key).\\n\"); Meeting key=getMeeting(in,out); for(int i=0; i&lt;top; ++i) if(isRepel(&amp;key,&amp;stack[i])) { fprintf(out,\"Delele %s successfully.\\n\",stack[i].name); stack[i--]=stack[--top]; }}void modify(FILE *in,FILE *out){ int t_len=top; del(in,out); while(top&lt;t_len) add(in,out);}void query(FILE *in,FILE *out){ fprintf(out,\"Input the key(-1 for no key).\\n\"); Meeting key=getMeeting(in,out); for(int i=0; i&lt;top; ++i) if(isRepel(&amp;key,&amp;stack[i])) { fprintf(out,\"Find \"); putMeeting(out,&amp;stack[i]); }}void fin(FILE *in,FILE *out){ fprintf(out,\"Start input from \\'log.txt\\'.\\n\"); FILE *f=fopen(\"log.txt\",\"r\"); if(f==NULL) { fprintf(out,\"Error:Do not find \\'log.txt\\'\\n\"); return; } int t_len; fscanf(f,\"%d\",&amp;t_len); while(t_len--) add(f,out); fclose(f); fprintf(out,\"Input from \\'log.txt\\' successfully.\\n\");}void fout(FILE *in,FILE *out){ fprintf(out,\"Start output to \\'log.txt\\'.\\n\"); FILE *f=fopen(\"log.txt\",\"w\"); fprintf(f,\"%d\\n\",top); for(int i=0; i&lt;top; ++i) putMeeting(f,&amp;stack[i]); fclose(f); fprintf(out,\"Output to \\'log.txt\\' successfully.\\n\");}void clear(FILE *in,FILE *out){ top=0; fprintf(out,\"Clear successfully.\\n\");}void help(FILE *in,FILE *out){ fprintf(out,\"fin : add new meetings from \\'log.txt\\' to memory if they do not repel.\\n\"); fprintf(out,\"fout : output all the meetings from memory to \\'log.txt\\'.\\n\"); fprintf(out,\"add : add a new meeting to memory if it does not repel.\\n\"); fprintf(out,\"delete : delete all the meetings which repel with the key.\\n\"); fprintf(out,\"modify : modify all the meetings which repel with the key.\\n\"); fprintf(out,\"clear : clear all the meetings from memory.\\n\"); fprintf(out,\"help : get available instructions.\\n\"); fprintf(out,\"EOF(Ctrl+Z in Windows) : exit.\\n\");} 测试123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include\"func.h\"int main(){ FILE *in=stdin,*out=stdout; fprintf(out,\"Scientific Meeting Management System by WuK&amp;LSY\\n\\n\"); fprintf(out,\"Input \\'fin\\' to read from log,or \\'help\\' to get other available instructions.\\n\\n\"); for(char s[MAXN]; fscanf(in,\"%s\",s)!=EOF; fprintf(out,\"\\n\")) { if(!strcmp(s,\"add\")) add(in,out); else if(!strcmp(s,\"delete\")) del(in,out); else if(!strcmp(s,\"modify\")) modify(in,out); else if(!strcmp(s,\"query\")) query(in,out); else if(!strcmp(s,\"fin\")) fin(in,out); else if(!strcmp(s,\"fout\")) fout(in,out); else if(!strcmp(s,\"clear\")) clear(in,out); else if(!strcmp(s,\"help\")) help(in,out); else fprintf(out,\"\\'%s\\' is not an available instruction,and you can in \\'help\\' to get available instructions.\\n\",s); }}","link":"/2019/04/11/2018-10-16-某科学的超会议议程管理系统（Scientific Meeting Management System）/"},{"title":"函数程序设计实验六：字符放大","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463module MyPicture whereimport Data.Charimport Data.Listimport Text.Printfsayit::String-&gt;IO()sayit s=putStr(say s)say::String-&gt;Stringsay s=unlines(says s)getid::Char-&gt;Intgetid c= if oc&gt;=97 then (oc-97+10) else if oc&gt;=65 then (oc-65+10) else (oc-48) where oc=ord csays::String-&gt;[String]says []=[]says (x:xs)=merge (alphabet!!(getid x)) (says xs)merge::[String]-&gt;[String]-&gt;[String]merge [] x=xmerge x []=xmerge (x:xs) (y:ys)=(x++y):(merge xs ys)alphabet= [[ \" #### \", \" ## ## \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" # \", \" ## \", \" ### \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \" ],[ \" #### \", \" # ## \", \" ## ## \", \" # ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" # \", \" # \", \" ###### \" ],[ \" #### \", \" ## # \", \" # ## \", \" ## \", \" # \", \" ### \", \" ## \", \" # \", \" # ## \", \" ## ## \", \" #### \" ],[ \" ## \", \" ## \", \" ### \", \" # # \", \" # # \", \" ## # \", \" # # \", \" ###### \", \" # \", \" # \", \" # \" ],[ \" ###### \", \" ## \", \" # \", \" ##### \", \" ## ## \", \" ## \", \" # \", \" # \", \" # ## \", \" ## # \", \" ### \" ],[ \" ### \", \" # ## \", \" ## # \", \" ## \", \" # ### \", \" ## ## \", \" ## # \", \" # # \", \" ## # \", \" # ## \", \" ### \" ],[ \" ###### \", \" ## \", \" # \", \" # \", \" # \", \" ## \", \" # \", \" # \", \" ## \", \" # \", \" # \" ],[ \" ### \", \" ## # \", \" # ## \", \" # ## \", \" ## # \", \" #### \", \" ## ## \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" ### \", \" ## # \", \" # ## \", \" # ## \", \" # ## \", \" ## ## \", \" ##### \", \" ## \", \" # ## \", \" ## # \", \" ### \" ],[ \" ## \", \" ## \", \" ## \", \" #### \", \" # # \", \" # # \", \" # # \", \" ###### \", \" # # \", \" # # \", \"## ##\" ],[ \" ##### \", \" # ## \", \" # # \", \" # # \", \" # ## \", \" ##### \", \" # ## \", \" # # \", \" # # \", \" # ## \", \" ##### \" ],[ \" ### \", \" # ## \", \" ## # \", \" # # \", \" # \", \" # \", \" # \", \" # # \", \" # # \", \" # ## \", \" ### \" ],[ \" #### \", \" # # \", \" # ## \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # ## \", \" # # \", \" #### \" ],[ \" ###### \", \" # \", \" # \", \" # \", \" # \", \" ###### \", \" # \", \" # \", \" # \", \" # \", \" ###### \" ],[ \" ###### \", \" # \", \" # \", \" # \", \" # \", \" ##### \", \" # \", \" # \", \" # \", \" # \", \" # \" ],[ \" ### \", \" # ## \", \" # # \", \" # # \", \" # \", \" # ### \", \" # # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" ###### \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \" ],[ \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \" ],[ \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" # ## \", \" # # \", \" # ## \", \" # ## \", \" ### \", \" #### \", \" # # \", \" # ## \", \" # # \", \" # ## \", \" # # \" ],[ \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" # \", \" ###### \" ],[ \" ## ## \", \" ## ## \", \" ## ## \", \" ## ## \", \" ## ## \", \" ###### \", \" # ## # \", \" # ## # \", \" # ## # \", \" # ## # \", \" # ## # \" ],[ \" # # \", \" ## # \", \" ## # \", \" ### # \", \" # # # \", \" # # # \", \" # # # \", \" # # # \", \" # ## \", \" # ## \", \" # ## \" ],[ \" #### \", \" ## ## \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" ##### \", \" # ## \", \" # # \", \" # # \", \" # # \", \" # ## \", \" ##### \", \" # \", \" # \", \" # \", \" # \" ],[ \" #### \", \" ## ## \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # ### \", \" # ### \", \" ## ## \", \" ##### \" ],[ \" ##### \", \" # ## \", \" # # \", \" # # \", \" # ## \", \" ##### \", \" # # \", \" # ## \", \" # # \", \" # ## \", \" # # \" ],[ \" #### \", \" ## ## \", \" # # \", \" # \", \" # \", \" ## \", \" ## \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \" ###### \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \" ],[ \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" # # \", \" ## ## \", \" #### \" ],[ \"## ##\", \" # # \", \" # # \", \" ## ## \", \" ## # \", \" # # \", \" # ## \", \" #### \", \" ## \", \" ## \", \" ## \" ],[ \"## ## ##\", \"## ## ##\", \"## ## # \", \" # ## # \", \" # ## # \", \" ## ### \", \" ## ## \", \" ## ## \", \" ## ## \", \" ## ## \", \" ## # \" ],[ \" # # \", \" ## # \", \" # # \", \" ### \", \" ## \", \" ## \", \" ## \", \" # ## \", \" # # \", \" ## ## \", \" # # \" ],[ \" # # \", \" # # \", \" # # \", \" # # \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \", \" ## \" ],[ \" ###### \", \" ## \", \" # \", \" ## \", \" # \", \" ## \", \" # \", \" # \", \" ## \", \" # \", \" ###### \" ]]","link":"/2018/11/08/2018-11-08-字符放大/"},{"title":"2018-2019 ICPC, NEERC, Northern Eurasia Finals","text":"Alice the Fan记忆化搜索，记忆转移方向。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;bits/stdc++.h&gt;#define dbg(x) cout &lt;&lt; (#x) &lt;&lt; \"=\" &lt;&lt; x &lt;&lt; endlusing namespace std;const int N = 207;int m, a, b;struct Node{ Node() { this-&gt;x = -2; } Node(int x, int y, int a, int b) { this-&gt;x = x; this-&gt;y = y; this-&gt;a = a; this-&gt;b = b; } int x, y, a, b;};int dp[6][6][N][N];Node last[6][6][N][N];int solve(int x, int y, int a, int b){ if (x &lt; 0 || y &lt; 0 || a &lt; 0 || b &lt; 0) return 0; if (dp[x][y][a][b] != -1) return dp[x][y][a][b]; if (!x &amp;&amp; !y) { if (!a &amp;&amp; !b) return 1; else return 0; } int up; if (x + y == 5) up = 15; else up = 25; //transfer1 up:j firstwin for (int j = 0; j &lt;= up - 2; j++) { if (y == 3) continue; if (solve(x - 1, y, a - up, b - j)) { last[x][y][a][b] = Node(x - 1, y, a - up, b - j); return dp[x][y][a][b] = 1; } } for (int i = up + 1; i &lt;= 200; i++) { if (y == 3) continue; if (solve(x - 1, y, a - i, b - (i - 2))) { last[x][y][a][b] = Node(x - 1, y, a - i, b - (i - 2)); return dp[x][y][a][b] = 1; } } //transfer2 j:up secondwin for (int j = 0; j &lt;= up - 2; j++) { if (x == 3) continue; if (solve(x, y - 1, a - j, b - up)) { last[x][y][a][b] = Node(x, y - 1, a - j, b - up); return dp[x][y][a][b] = 1; } } for (int i = up + 1; i &lt;= 200; i++) { if (x == 3) continue; if (solve(x, y - 1, a - (i - 2), b - i)) { last[x][y][a][b] = Node(x, y - 1, a - (i - 2), b - i); return dp[x][y][a][b] = 1; } } return dp[x][y][a][b] = 0;}void print(int x, int y, int a, int b){ Node t = last[x][y][a][b]; // dbg(t.x); // dbg(t.y); // dbg(t.a); // dbg(t.b); if (t.x == -2) return; print(t.x, t.y, t.a, t.b); cout &lt;&lt; a - t.a &lt;&lt; ':' &lt;&lt; b - t.b; if (max(x, y) == 3) cout &lt;&lt; endl; else cout &lt;&lt; ' ';}int main(){ // freopen(\"A.in\", \"r\", stdin); scanf(\"%d\", &amp;m); memset(dp, -1, sizeof(dp)); for (int i = 1; i &lt;= m; i++) { scanf(\"%d %d\", &amp;a, &amp;b); if (solve(3, 0, a, b)) { cout &lt;&lt; \"3\" &lt;&lt; ':' &lt;&lt; \"0\" &lt;&lt; endl; print(3, 0, a, b); } else if (solve(3, 1, a, b)) { cout &lt;&lt; \"3\" &lt;&lt; ':' &lt;&lt; \"1\" &lt;&lt; endl; print(3, 1, a, b); } else if (solve(3, 2, a, b)) { cout &lt;&lt; \"3\" &lt;&lt; \":\" &lt;&lt; \"2\" &lt;&lt; endl; print(3, 2, a, b); } else if (solve(2, 3, a, b)) { cout &lt;&lt; \"2\" &lt;&lt; \":\" &lt;&lt; \"3\" &lt;&lt; endl; print(2, 3, a, b); } else if (solve(1, 3, a, b)) { cout &lt;&lt; \"1\" &lt;&lt; ':' &lt;&lt; \"3\" &lt;&lt; endl; print(1, 3, a, b); } else if (solve(0, 3, a, b)) { cout &lt;&lt; \"0\" &lt;&lt; ':' &lt;&lt; \"3\" &lt;&lt; endl; print(0, 3, a, b); } else printf(\"Impossible\\n\"); } return 0;} Bimatching题意：每个骑士和两个女士配对，求能够形成的最大组数。 做的人很少的一题，但实际上是一道模板题。思路是把每个骑士拆成两个点，这样原来的“三元匹配”就变成传统的二元匹配了。但是这会带来新的问题，原来不能匹配的骑士此时也可以匹配了。解决办法是在拆的两点间连一条边，这样原来能够三元匹配的骑士匹配数一定是2，原来没有三元匹配的骑士匹配数一定是1。最后的结果是最大匹配数减去加入的边数n。插入边后不再是二分图了，变成一般图最大匹配，拉一个带花树的板子跑掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;const int NPOS = -1;struct UnionfindSet : vector&lt;int&gt;{ UnionfindSet(int n) : vector&lt;int&gt;(n) { for (int i = 0; i &lt; n; ++i) at(i) = i; } int ask(int u) { return at(u) != u ? at(u) = ask(at(u)) : u; } void merge(int u, int w) { if (w = ask(w), u = ask(u), w != u) at(w) = u; }};struct Graph{ struct Vertex { vector&lt;int&gt; o; }; typedef pair&lt;int, int&gt; Edge; vector&lt;Vertex&gt; v; vector&lt;Edge&gt; e; Graph(int n) : v(n) {} void add(const Edge &amp;ed) { v[ed.first].o.push_back(e.size()); e.push_back(ed); }};struct Blossom : Graph{ vector&lt;int&gt; f; Blossom(int n) : Graph(n) {} void ask() { vector&lt;int&gt; vis(v.size(), NPOS); f = vis; for (int s = 0, t = 0; s &lt; v.size(); ++s) if (f[s] == NPOS) { vector&lt;int&gt; pre(v.size(), NPOS), flag(pre); deque&lt;int&gt; q(flag[s] = 1, s); for (UnionfindSet ufs(v.size()); f[s] == NPOS &amp;&amp; !q.empty(); q.pop_front()) for (int i = 0, x = q.front(), y, a, b; i &lt; v[x].o.size(); ++i) if (y = e[v[x].o[i]].second, y != f[x] &amp;&amp; flag[y] &amp;&amp; ufs.ask(x) != ufs.ask(y)) { if (flag[y] == 1) { for (a = x, b = y, ++t;; swap(a, b)) if (a != NPOS) { if (vis[a = ufs.ask(a)] == t) break; vis[a] = t, a = f[a] != NPOS ? pre[f[a]] : NPOS; } if (ufs.ask(x) != a) pre[x] = y; if (ufs.ask(y) != a) pre[y] = x; for (int p[2] = {x, y}, j = 0; j &lt; 2; ++j) for (int x = p[j], y, z; x != a; ufs.merge(y, x), ufs.merge(x = z, y)) { if (ufs.ask(z = pre[y = f[x]]) != a) pre[z] = y; if (!flag[y]) flag[y] = 1, q.push_back(y); if (!flag[z]) flag[z] = 1, q.push_back(z); } } else if (f[y] == NPOS) { for (pre[y] = x; y != NPOS;) swap(y, f[f[y] = pre[y]]); break; } else pre[y] = x, q.push_back(f[y]), flag[f[y]] = 1, flag[y] = 0; } } }};char s[255];int t, n, m, c;int main(){ for (scanf(\"%d\", &amp;t); t--; printf(\"%d\\n\", c / 2 - n)) { scanf(\"%d%d\", &amp;n, &amp;m); Blossom g(m + n * 2); for (int i = 0; i &lt; n; ++i) { scanf(\"%s\", s); for (int j = 0; j &lt; m; ++j) if (s[j] == '1') { g.add({j, m + i * 2}); g.add({m + i * 2, j}); g.add({j, m + i * 2 + 1}); g.add({m + i * 2 + 1, j}); } g.add({m + i * 2, m + i * 2 + 1}); g.add({m + i * 2 + 1, m + i * 2}); } g.ask(); for (int i = c = 0; i &lt; g.f.size(); ++i) if (g.f[i] != NPOS) ++c; }} Easy Chess小范围数据打表，否则指定几个关键节点。体验极差。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;string&gt; ans{ \"\", \"\", \"a1 h1 h8\", \"a1 h1 h2 h8\", \"a1 h1 h2 h3 h8\", \"a1 h1 h2 h3 h4 h8\", \"a1 h1 h2 h3 h4 h5 h8\", \"a1 h1 h2 h3 h4 h5 h6 h8\", \"a1 h1 h2 h3 h4 h5 h6 h7 h8\", \"a1 b1 h1 h2 h3 h4 h5 h6 h7 h8\", \"a1 b1 c1 h1 h2 h3 h4 h5 h6 h7 h8\", \"a1 b1 c1 d1 h1 h2 h3 h4 h5 h6 h7 h8\", \"a1 b1 c1 d1 e1 h1 h2 h3 h4 h5 h6 h7 h8\", \"a1 b1 c1 d1 e1 f1 h1 h2 h3 h4 h5 h6 h7 h8\", \"a1 b1 c1 d1 e1 f1 g1 h1 h2 h3 h4 h5 h6 h7 h8\", \"a1 a2 b2 b1 c1 d1 e1 f1 g1 h1 h2 h3 h4 h5 h6 h8\", \"a1 a2 b2 b1 c1 d1 e1 f1 g1 h1 h2 h3 h4 h5 h6 h7 h8\"}, turn{ \"a1\", \"h1\", \"h2\", \"a2\", \"a3\", \"h3\", \"h4\", \"a4\", \"a5\", \"h5\", \"h6\", \"a6\", \"a8\", \"g8\", \"g7\", \"a7\", \"h7\", \"h8\"}, jump{ \"a8\", \"h7\"};int n;int main(){ cin &gt;&gt; n; if (n &lt; ans.size()) return cout &lt;&lt; ans[n], 0; int need = n - 17, to = 1; for (string now(\"a1\");;) { cout &lt;&lt; now &lt;&lt; ' '; if (now == turn[to]) ++to; if (to &gt; turn.size()) return 0; if (need == 0 || turn[to] == jump[0] || turn[to] == jump[1]) { now = turn[to]; continue; } if (now[0] &lt; turn[to][0]) ++now[0]; else if (now[0] &gt; turn[to][0]) --now[0]; else if (now[1] &lt; turn[to][1]) ++now[1]; else --now[1]; if (now != turn[to]) --need; }} Fractions123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n, m;vector&lt;ll&gt; v;void gcd(ll a, ll b, ll &amp;x, ll &amp;y){ if (!b) { x = (m - 1) / a, y = 0; return; } gcd(b, a % b, x, y); ll t = x; x = y, y = t - a / b * y;}int main(){ scanf(\"%lld\", &amp;n); m = n; for (ll i = 2; i * i &lt;= m; ++i) if (n % i == 0) { v.push_back(i); while (n % i == 0) n /= i; } if (n &gt; 1) v.push_back(n); if (v.size() &lt; 2) return printf(\"NO\"), 0; printf(\"YES\\n2\\n\"); ll a = v[0], b = v[v.size() - 1], x, y; gcd(a, b, x, y); a = m / a, b = m / b; while (x &lt;= 0) x += a, y -= b; while (x &gt;= a) x -= a, y += b; while (y &gt;= b) x += a, y -= b; while (y &lt;= 0) x -= a, y += b; printf(\"%lld %lld\\n%lld %lld\", x, a, y, b);} Guest Student123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int t, k, a[7];int main(){ for (scanf(\"%d\", &amp;t); t--;) { scanf(\"%d\", &amp;k); int sum = 0, x = 0, y = 1e9; for (int i = 0; i &lt; 7; ++i) scanf(\"%d\", &amp;a[i]), sum += a[i]; if (k &gt; 2 * sum) { k -= sum; x = k / sum * 7; k %= sum; k += sum; } for (int i = 0, j; i &lt; 7; ++i) { for (int s = j = 0; s &lt; k; ++j) s += a[(i + j) % 7]; y = min(y, j); } printf(\"%d\\n\", x + y); }} King Kog’s Reception123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 7;struct SegmentTree{ struct Node { ll val, sum; void up(const Node &amp;lc, const Node &amp;rc) { sum = lc.sum + rc.sum; val = max(lc.val + rc.sum, rc.val); } } v[N * 4]; void set(int p, ll val, int l = 1, int r = N, int rt = 1) { if (l &gt;= r) { v[rt].sum = val, v[rt].val = val ? l + val : 0; return; } int m = l + r &gt;&gt; 1; if (p &gt; m) set(p, val, m + 1, r, rt &lt;&lt; 1 | 1); else set(p, val, l, m, rt &lt;&lt; 1); v[rt].up(v[rt &lt;&lt; 1], v[rt &lt;&lt; 1 | 1]); } Node ask(int p, int q, int l = 1, int r = N, int rt = 1) { if (p &lt;= l &amp;&amp; r &lt;= q) return v[rt]; int m = l + r &gt;&gt; 1; if (m &gt;= q) return ask(p, q, l, m, rt &lt;&lt; 1); if (m &lt; p) return ask(p, q, m + 1, r, rt &lt;&lt; 1 | 1); return v[0].up(ask(p, q, l, m, rt &lt;&lt; 1), ask(p, q, m + 1, r, rt &lt;&lt; 1 | 1)), v[0]; }} t;char s[9];int n, a[N];int main(){ scanf(\"%d\", &amp;n); for (int i = 1, y; i &lt;= n; ++i) { scanf(\"%s%d\", s, &amp;a[i]); if (s[0] == '+') { scanf(\"%d\", &amp;y); t.set(a[i], y); } else if (s[0] == '-') t.set(a[a[i]], 0); else printf(\"%lld\\n\", max(t.ask(1, a[i]).val - a[i], 0LL)); }} Lazyland1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 9;typedef long long ll;vector&lt;int&gt; ans, v[N];int n, k, cnt, a[N], b[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;b[i]); for (int i = 1; i &lt;= n; ++i) v[a[i]].push_back(b[i]); for (int i = 1; i &lt;= k; ++i) { if (v[i].empty()) { ++cnt; continue; } sort(v[i].begin(), v[i].end()); for (int j = 0; j &lt; v[i].size() - 1; ++j) ans.push_back(v[i][j]); } sort(ans.begin(), ans.end()); ll tmp = 0; for (int i = 0; i &lt; cnt; ++i) tmp += ans[i]; printf(\"%lld\", tmp);}","link":"/2019/01/21/2019-01-21-2018-2019 ICPC, NEERC, Northern Eurasia Finals/"},{"title":"2017 ACM-ICPC Asia Tehran Regional Contest","text":"# [Sim Card](https://vjudge.net/problem/UVALive-8321) undefined # [Bank Card Verifier](https://vjudge.net/problem/UVALive-8322) undefined # [World Cup Draw](https://vjudge.net/problem/UVALive-8324) undefined # [Barareh on Fire](https://vjudge.net/problem/UVALive-8325) undefined # [Column Addition](https://vjudge.net/problem/UVALive-8328) undefined # [Cafe Bazaar](https://vjudge.net/problem/UVALive-8329) undefined # [Mars](https://vjudge.net/problem/UVALive-8331) undefined","link":"/2019/01/23/2019-01-23-2017 ACM-ICPC Asia Tehran Regional Contest/"},{"title":"数学分析","text":"增长趋势$n\\to+\\infty,\\forall p,q&gt;0,a&gt;1,{(\\ln n)}^q\\ll n^p\\ll a^n\\ll n!\\ll n^n$ 积分表反读可得导数表，此处略。 $\\int k,\\mathrm{d}x=kx+C$ $\\int x^a,dx=\\frac{x^{a+1}}{a+1}+C$ $\\int\\frac{1}{x},dx=\\ln\\mid x\\mid +C$ $\\int e^x,dx=e^x + C$ $\\int a^x,dx=\\frac{a^x}{\\ln a}+C$ $\\int\\cos x,dx=\\sin x+C$ $\\int\\sin x,dx=-\\cos x+C$ $\\int\\frac{1}{cos^2x},dx=\\int\\sec^2 x,dx=\\tan x+C$ $\\int\\frac{1}{sin^2x},dx=\\int\\csc^2 x,dx=-\\cot x+C$ $\\int\\frac{1}{\\sqrt{1-x^2}},dx=\\arcsin x+C=-\\arccos x+C$ $\\int\\frac{1}{1+x^2},dx=\\arctan x+C=-arccot,x+C$ $\\int\\sec x\\tan x,dx=\\sec x+C$ $\\int\\csc x\\cot x,dx=-\\csc x+C$ $\\int\\tan x,dx=-\\ln\\mid \\cos x\\mid +C$ $\\int\\cot x,dx=\\ln\\mid \\sin x\\mid +C$ $\\int\\sec x,dx=\\ln\\mid \\sec x+\\tan x\\mid +C$ $\\int\\csc x,dx=\\ln\\mid \\csc x-\\cot x\\mid +C$ $\\int sh,x,dx=ch,x+C$ $\\int ch,x,dx=sh,x+C$ $\\int\\frac{1}{x^2+a^2},dx=\\frac{1}{a}\\arctan\\frac{x}{a}+C$ $\\int\\frac{1}{x^2-a^2},dx=\\frac{1}{2a}\\ln\\mid \\frac{x-a}{x+a}\\mid +C$ $\\int\\frac{1}{\\sqrt{a^2-x^2}},dx=\\arcsin\\frac{x}{a}+C$ $\\int\\frac{1}{\\sqrt{x^2-a^2}},dx=\\ln\\mid x+\\sqrt{x^2-a^2}\\mid +C$ $\\int\\frac{1}{\\sqrt{x^2+a^2}},dx=\\ln\\mid x+\\sqrt{x^2+a^2}\\mid +C$ 积分求几何量弧长若简单闭曲线 $\\begin{cases}x=x(t),\\ y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$ 端点处重合（$x(\\alpha)=x(\\beta),y(\\alpha)=y(\\beta)$）且其他地方不自交，$x(t),y(t)$连续且满足 $[x’(t)]^2+[y’(t)]^2\\ne0,\\forall t\\in[\\alpha,\\beta]$ 此时称曲线光滑，其长度 $s=\\int_\\alpha^\\beta\\sqrt{[x’(t)]^2+[y’(t)]^2},dt$ 此式可对称推广到高维空间曲线。极坐标下， $r=r(\\theta),\\theta\\in[\\alpha,\\beta]$ 的长度为 $s=\\int_\\alpha^\\beta\\sqrt{[r(\\theta)]^2+[r’(\\theta)]^2},d\\theta$ 面积若简单闭曲线 $\\begin{cases}x=x(t),\\ y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$ 端点处连续（$x(\\alpha)=x(\\beta),y(\\alpha)=y(\\beta)$）且其他地方不自交，$x(t),y(t)$都逐段有连续微商，则此闭合曲线围起来的有界区域面积 $S=-\\int_\\alpha^\\beta x’(t)y(t),dt=-\\int_\\alpha^\\beta y(t),dx(t)=-\\oint_\\Gamma y,dx=\\oint_\\Gamma x,dy$ 等式右边称为曲线$\\Gamma$上的积分，其计算方法是带入参数方程到定积分计算式中，积分上下限为始点与终点对应的参数值。下限并不总是小于上限，参数从下限到上限变化时对应曲线的正向（沿正向观察时，曲线所围的区域永远在左侧）。极坐标下，连续非负曲线$r=r(\\theta)$与向径$\\theta=\\alpha,\\theta=\\beta$，其中 $0\\leq\\beta-\\alpha\\leq2\\pi$所围成的平面图形面积$S=\\frac{1}{2}\\int_\\alpha^\\beta r^2(\\theta),d\\theta$ 体积记立体过x点且垂直于x轴的截面面积为$S(x)$，则其体积$V=\\int_a^bS(x),dx$连续曲线$y=f(x)\\ge 0,x\\in[a,b]$绕x轴旋转一周产生的旋转体体积$V=\\pi\\int_a^by^2,dx$ 旋转体侧面积若曲线由参数方程 $\\begin{cases}x=x(t),\\ y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$ 给出，则其绕x轴旋转体的侧面积 $s=2\\pi\\int_\\alpha^\\beta y(t)\\sqrt{[x’(t)]^2+[y’(t)]^2},dt$ 方向导数设三元函数$u=f(x,y,z)$在点$P_0(x_0,y_0,z_0)$的某邻域内有定义，任意给定始于点$P_0$的射线$l$，$P(x,y,z)$为l上且含于定义域内的点。若极限 $\\lim_{r(p,p_0)\\to0^+}\\frac{f(P)-f(P_0)}{r(P,P_0)}=\\lim_{r(p,p_0)\\to0^+}\\frac{\\Delta_lf(P_0)}{r(P,P_0)}$ 存在，则称该极限值为函数$f$在点$P_0$沿方向$l$的方向导数，记为$\\frac{\\partial f}{\\partial l}\\mid _{P_0}$或$\\frac{\\partial f(P_0)}{\\partial l}$，$\\frac{\\Delta_lf(P_0)}{r(P,P_0)}$称为函数在$P_0$点沿$l$方向的增量。 特别地，$\\frac{\\partial f(P_0)}{\\partial x}$就是函数在$P_0$点沿$x$轴正向的方向导数，$y,z$轴上的方向导数同理。若函数在$P_0$点可微，则其在$P_0$沿任何方向$l$的方向导数都存在，则有以下公式 $\\frac{\\partial f(P_0)}{\\partial l}=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z})\\mid _{P_0}\\cdot\\vec{l_0}$ 其中$\\vec{l_0}=(\\cos\\alpha,\\cos\\beta,cos\\gamma)=\\frac{1}{\\rho}(\\Delta x,\\Delta y,\\Delta z)$为$l$的方向余弦。 曲率若曲线由参数方程 $\\begin{cases}x=x(t),\\ y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$ 给出且有二阶微商，则其在一点的曲率 $K=\\frac{\\mid y’’x’-y’x’’\\mid }{[x’^2+y’^2]^{\\frac{3}{2}}}$ 若$y=f(x)$，则 $K=\\frac{\\mid y’’\\mid }{(1+y’^2)^\\frac{3}{2}}$ 同时记$\\frac{1}{K}$为曲率半径。 空间曲线的切线与法平面若已知曲线上一点$P(x_0,y_0,z_0)$处的切向量为$\\tau(x_0,y_0,z_0)=(A,B,C)$则曲线在该点的切线方程为 $\\frac{x-x_0}A=\\frac{y-y_0}B=\\frac{z-z_0}C$ 法平面方程为 $A(x-x_0)+B(y-y_0)+C(z-z_0)=0$ 当曲线由参数方程 $\\begin{cases}x=x(t),\\ y=y(t),\\ z=z(t),\\end{cases}t\\in[\\alpha,\\beta]$ 给出时，曲线在P点的切向量为 $\\tau=\\pm(x’(t_0),y’(t_0),z’(t_0))$ 更一般地，若曲线用两曲面的交线给出 $\\begin{cases}F(x,y,z)=0,\\ G(x,y,z)=0,\\end{cases}$ 且在P点的某邻域能确定函数组$y=y(x),z=z(x)$满足$y_0=y(x_0),z_0=z(x_0)$，且$y’(x),z’(x)$存在，则曲线在P点的切向量 $\\tau=\\pm(\\frac{\\partial(F,G)}{\\partial(y,z)},\\frac{\\partial(F,G)}{\\partial(z,x)},\\frac{\\partial(F,G)}{\\partial(x,y)})$ 空间曲面的切平面与法线若已知曲面上一点$P(x_0,y_0,z_0)$处的切平面的法向量为$\\vec n=(A’,B’,C’)$则曲线在该点的法线方程为 $\\frac{x-x_0}{A’}=\\frac{y-y_0}{B’}=\\frac{z-z_0}{C’}$ 切平面方程为 $A’(x-x_0)+B’(y-y_0)+C’(z-z_0)=0$ 当曲面方程为$\\pi:F(x,y,z)=0$在曲面上任取一条过P的曲线，设其方程为 $\\begin{cases}x=x(t),\\ y=y(t),\\ z=z(t),\\end{cases}t\\in[\\alpha,\\beta]$ 此时有$F(x(t),y(t),z(t))=0$令$t=t_0$两边对t求导，并写成向量的内积式，得 $(F_x,F_y,F_z)_P\\cdot(x’(t_0),y’(t_0),z’(t_0))=0$ 则曲线在P点的法向量为$\\vec{n}=\\pm(F_x,F_y,F_z)_P$ 若曲线由参数方程给出 $\\begin{cases}x=x(u,v),\\ y=y(u,v),\\ z=z(u,v),\\end{cases}$ 则曲线在P点的法向量 $\\vec{n}=\\pm(\\frac{\\partial(y,z)}{\\partial(u,v)},\\frac{\\partial(z,x)}{\\partial(u,v)},\\frac{\\partial(x,y)}{\\partial(u,v)})$ 高阶导数与泰勒公式用$f^{(n)}(x)$表示f(x)的n阶导数，只要让余项&lt;EPS即可计算指定函数到任意精确度，特别取a=0时称为麦克劳林公式。 $f(x)=f(a)+f^{(1)}(a)(x-a)+\\frac{f^{(2)}(a)}{2!}(x-a)^2+\\ldots+\\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)$ $R_n(x)=o((x-a)^n)$，佩亚诺余项 $R_n(x)=\\frac{1}{n!}\\int_a^x(x-t)^nf^{(n+1)}(t),dt$，积分余项 $R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-a)^{n+1},a&lt;\\xi&lt;x$，拉格朗日余项 $R_n(x)=\\frac{(x-a)^{n+1}}{n!}(1-\\theta)^nf^{(n+1)}(a+\\theta(x-a)),0&lt;\\theta&lt;1$，柯西余项 对数函数$[\\ln(1+x)]^{(n)}=(-1)^{n-1}(n-1)!(1+x)^{-n}$ $\\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+\\ldots+(-1)^{n-1}\\frac{x^n}{n}+R_n(x)$ 幂函数$[(1+x)^a]^{(n)}=a(a-1)\\ldots(a-n+1)(1+x)^{a-n}$ $(1+x)^a=1+ax+\\frac{a(a-1)}{2!}x^2+\\dots+\\frac{a(a-1)\\ldots(a-n+1)}{n!}x^n+R_n(x)$ 三角函数$(\\sin x)^{(n)}=\\sin(x+\\frac{n\\pi}{2})$ $\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\ldots+(-1)^{k-1}\\frac{x^{2k-1}}{(2k-1)!}+R_{2k}(x)$ $R_{2k}(x)=(-1)^k\\frac{\\cos\\theta x}{(2k+1)!}x^{2k+1}$ $(\\cos x)^{(n)}=\\cos(x+\\frac{n\\pi}{2})$ $\\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\ldots+(-1)^{k-1}\\frac{x^{2k-2}}{(2k-2)!}+R_{2k-1}(x)$ $R_{2k-1}(x)=(-1)^k\\frac{\\cos\\theta x}{(2k)!}x^{2k}$ 指数函数$(e^x)^{(n)}=e^x$ $e^x=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\ldots+\\frac{x^n}{n!}+R_n(x)$ $R_n(x)=\\frac{e^{\\theta x}}{(n+1)!}x^{n+1},\\xi=\\theta x,0&lt;\\theta&lt;1$ 二元函数设$f(x,y)$在$P_0(x_0,y_0)$的某邻域$O(P_0)$内有直到$n+1$阶连续偏导数，则对$O(P_0)$内$\\forall(x_0+\\Delta x,y_0+\\Delta y),\\exists\\theta\\in(0,1)$，使得 $f(x_0+\\Delta x,y_0+\\Delta y)=\\sum_{k=0}^n\\frac{1}{k!}(\\frac{\\partial}{\\partial x}\\Delta x+\\frac{\\partial}{\\partial y}\\Delta y)^kf(x_0,y_0)+R_n$ 其中 $R_n=\\frac{1}{(n+1)!}(\\frac{\\partial}{\\partial x}\\Delta x+\\frac{\\partial}{\\partial y}\\Delta y)^{n+1}f(x_0+\\theta\\Delta x,y_0+\\theta\\Delta y)$ 级数部分和幂级数快速计算幂级数的部分和$\\sum_{i=1}^ni^k\\mod M$可借助伯努利数，详见组合数学模板。 $\\sum_{i=1}^ni^1=\\frac 1 2n(n+1)$ $\\sum_{i=1}^ni^2=\\frac 1 6n(n+1)(2n+1)$ $\\sum_{i=1}^ni^3=\\frac 1 4[n(n+1)]^2$ $\\sum_{i=1}^ni^4=\\frac 1{30}n(n+1)(2n+1)(3n^2+3n-1)$ $\\sum_{i=1}^ni^5=\\frac 1{12}[n(n+1)]^2(2n^2+2n-1)$ $\\sum_{i=1}^ni^6=\\frac 1{42}n(n+1)(2n+1)(3n^4+6n^3-3n+1)$ 调和级数$n\\to\\infty,\\sum_{i=1}^n\\frac 1 i\\to\\ln n+r,r\\approx0.5772156649015328\\ldots$ 二分求零点、三分求极值点需要$f(x)$在区间$[l,r]$上单调/凹凸性唯一。 1234567891011121314lf bs(lf l, lf r, lf f(lf x)){ if (r - l &lt; EPS) return l; lf m = (l + r) / 2; return sgn(f(l) * f(m)) &lt; 0 ? bs(l, m, f) : ts(m, r, f);}lf ts(lf l, lf r, lf f(lf x)){ if (r - l &lt; EPS) return l; lf d = (r - l) / 3, lm = l + d, rm = r - d; return f(lm) &lt; f(rm) ? ts(l, rm, f) : ts(lm, r, f); //极小值} 自适应辛普森求积分使用示例 这篇论文论证了加一个十五分之一的偏移收敛会比较快… 123456789101112struct Simpson{ lf simpson(lf a, lf b, lf f(lf x)) { return (f(a) + 4 * f((a + b) / 2) + f(b)) * (b - a) / 6; } lf ask(lf a, lf b, lf f(lf x), lf e = EPS) { lf c = (a + b) / 2, L = simpson(a, c, f), R = simpson(c, b, f), delta = (L + R - simpson(a, b, f)) / 15; return fabs(delta) &lt; e ? L + R + delta : ask(a, c, f, e / 2) + ask(c, b, f, e / 2); }}; 插值法拉格朗日插值法：插值多项式和插值基函数的形式对称，容易编程。但是，增加节点时，需要重新计算每一个插值基函数。要在$\\pmod p$意义下进行的话，那么p只能是质数。牛顿插值法：当插值节点增加时，之前已计算的结果仍然能用，每增加一个节点，只要再增加一项即可，从而避免了重复性计算。如果要mod非质数的话，那么就要用牛顿插值法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061typedef complex&lt;lf&gt; Coord;#define X real()#define Y imag()struct Lagrange{ lf ask(const vector&lt;Coord&gt; &amp;p, lf x) //返回p确定的多项式函数在x处的值 { lf ret = 0; for (int i = 0; i &lt; p.size(); ++i) { lf tmp = p[i].Y; for (int j = 0; j &lt; p.size(); ++j) if (i != j) tmp *= (x - p[j].X) / (p[i].X - p[j].X); ret += tmp; } return ret; } vector&lt;lf&gt; ask(vector&lt;Coord&gt; p) //返回p确定的多项式系数向量 { vector&lt;lf&gt; ret(p.size()), sum(p.size()); ret[0] = p[0].Y, sum[0] = 1; for (int i = 1; i &lt; p.size(); ++i) { for (int j = p.size() - 1; j &gt;= i; --j) p[j].Y = (p[j].Y - p[j - 1].Y) / (p[j].X - p[j - i].X); for (int j = i; ~j; --j) sum[j] = (j ? sum[j - 1] : 0) - sum[j] * p[i - 1].X, ret[j] += sum[j] * p[i].Y; } return ret; }};struct Newton{ lf differenceQuotient(const vector&lt;Coord&gt; &amp;p, int k) //计算差商 { lf ret = 0; for (int i = 0; i &lt;= k; ++i) { lf tmp = p[i].Y; for (int j = 0; j &lt;= k; ++j) if (i != j) tmp /= p[i].X - p[j].X; ret += tmp; } return ret; } lf ask(const vector&lt;Coord&gt; &amp;p, lf x) { lf ret = p[0].Y; for (int i = 1; i &lt; p.size(); ++i) { lf tmp = differenceQuotient(p, i); //多次求，可O(n^3)预处理优化 for (int j = 0; j &lt; i; ++j) tmp *= x - p[j].X; ret += tmp; } return ret; }};","link":"/2019/02/03/2019-02-03-数学分析/"},{"title":"数论","text":"辗转相除法123456789ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; } //a、b的最大公约数ll lcm(ll a, ll b) { return a / gcd(a, b) * b; } //a、b的最小公倍数ll gcd(ll a, ll b, ll &amp;x, ll &amp;y) //扩展欧几里得，引用返回a*x+b*y=gcd(a,b)绝对值之和最小的解{ if (!a) return x = 0, y = 1, b; ll d = gcd(b % a, a, y, x); return x -= b / a * y, d;} 裴蜀定理对任何$a,b\\in Z$和它们的最大公约数$d$，关于未知数$x,y$的线性不定方程（称为裴蜀等式）：$ax+by=c$当仅当$d|c$，可知有无穷多解。特别地，$ax+by=d$一定有解。 推论$a,b$互质的充要条件是$ax+by=1$有整数解。 同余系运算求乘法逆元的另外一种方法是用欧拉定理$x^{\\phi(m)}\\equiv1\\pmod m$，x的逆是$x^{\\phi(m)-1}$。特别地，m为素数时$\\phi(m)=m-1$，此时x的逆就是pow(x,m-2,m)。 log函数：m为素数时求解模方程$a^x\\equiv b\\pmod m$。设P为质数，G为P的原根，则$x^y\\equiv b\\pmod P$等价于$y\\ ind\\ x\\equiv b\\pmod{P-1}$，其中$G\\ ind\\ x\\equiv x\\pmod P$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct Mod{ const ll M; Mod(ll M) : M(M) {} ll add(ll a, ll b) const { return ((a + b) % M + M) % M; } ll sub(ll a, ll b) const { return add(a, M - b); } ll mul(ll a, ll b) const { return a * b % M; } /*//根据a*b是否爆ll替换a*b%m ll mul(ll a, ll b) const { ll r = 0; for (a %= M; b; b &gt;&gt;= 1, a = add(a, a)) if (b &amp; 1) r = add(r, a); return r; } */ ll pow(ll a, ll b) const { ll r = 1; for (a %= M; b; b &gt;&gt;= 1, a = mul(a, a)) if (b &amp; 1) r = mul(r, a); return r; } ll inv(ll a) const { return pow(a, M - 2); } //return pow(a, phi(m) - 1, m); /*//模m下a的乘法逆元，不存在返回-1（m为素数时a不为0必有逆元） ll inv(ll a) const { ll x, y, d = gcd(a, m, x, y); return d == 1 ? (x + m) % m : -1; } */ ll div(ll a, ll b) const { return mul(a, inv(b)); } ll log(ll a, ll b) const { ll n = ceil(sqrt(M + 0.5)); map&lt;ll, ll&gt; x; for (ll i = 0, e = 1; i &lt; n; e = mul(e, a), ++i) if (!x.count(e)) x[e] = i; for (ll i = 0, v = inv(pow(a, n)); i &lt; n; ++i, b = mul(b, v)) if (x.count(b)) return i * n + x[b]; return -1; } vector&lt;ll&gt; sol(ll a, ll b) //解同余方程，返回ax=b(mod M)循环节内所有解 { vector&lt;ll&gt; ans; ll x, y, d = gcd(a, M, x, y); if (b % d) return ans; ans.push_back((b / d) % (M / d) * (x = (x % M + M) % M)); for (int i = 1; i &lt; d; ++i) ans.push_back((ans[0] + i * M / d) % M); return ans; }}; 中国剩余定理解同余方程组使用示例 1234567891011ll crt(const vector&lt;pair&lt;ll, ll&gt;&gt; &amp;v) //同余方程组，x%v[i].first==v[i].second，不存在返回-1{ ll m = v[0].first, r = v[0].second, c, d, x, y, z; for (int i = 1; i &lt; v.size(); ++i) { if (c = v[i].second - r, d = gcd(m, v[i].first, x, y), c % d) return -1; gcd(m / d, z = v[i].first / d, x, y), r += c / d * x % z * m, r %= m *= z; } return r &lt; 0 ? r + m : r;} 欧拉筛欧拉函数$\\phi(n)$是小于n的正整数中与n互素的数的数目。特别地，规定$\\phi(1)=1$，易知n&gt;2时都为偶数。 欧拉函数是积性函数，即对任意素数$p,q$满足下列关系：$\\phi(pq)=\\phi(p)\\phi(q)=(p-1)(q-1)$对任何两个互质的正整数$x, m(m\\geq2)$有欧拉定理：$x^{\\phi(m)}\\equiv1\\pmod m$当m为素数p时，此式变为费马小定理：$x^{p-1}\\equiv1\\pmod p$利用欧拉函数和它本身不同质因数的关系，用筛法$O(N)$预处理某个范围内所有数的欧拉函数值，并求出素数表。同时，利用计算欧拉函数过程中求出的最小素因子m，可以实现$O(log N)$的素因数分解。 同时求莫比乌斯函数$\\mu(n)$，存在mu中。 123456789101112131415161718192021222324struct EulerSieve{ vector&lt;int&gt; p, m, phi, mu; //素数序列，最小素因子，欧拉函数，莫比乌斯函数 EulerSieve(int N) : m(N, 0), phi(N, 0), mu(N, 0) { phi[1] = mu[1] = 1; //m[1]=0,m[i]==i可判断i是素数 for (long long i = 2, k; i &lt; N; ++i) //防i*p[j]爆int { if (!m[i]) p.push_back(m[i] = i), phi[i] = i - 1, mu[i] = -1; //i是素数 for (int j = 0; j &lt; p.size() &amp;&amp; (k = i * p[j]) &lt; N; ++j) { phi[k] = phi[i] * p[j]; if ((m[k] = p[j]) == m[i]) { mu[k] = 0; break; } phi[k] -= phi[i]; mu[k] = -mu[i]; } } }}; 常见数论函数变换$\\sum_{d|n}\\mu(d)=[n=1]$ $\\phi(n)=\\sum_{i=1}^n[\\gcd(i,n)=1]=\\sum_{i=1}^n\\sum_{k\\mid i,k\\mid n}\\mu(k)=\\sum_{k\\mid n}\\frac nk\\mu(k)$ 前缀和欧拉函数前缀和$S_\\phi(n)=\\frac{(n+1)n}2-\\sum_{d=1}^nS_\\phi(\\frac{n}{d})$ 莫比乌斯函数前缀和$S_\\mu(n)=1-\\sum_{d=1}^nS_\\mu(\\frac{n}{d})$ 莫比乌斯反演若$f(n)=\\sum_{d|n}g(d)$，则$g(n)=\\sum_{d|n}\\mu(d)f(\\frac{n}{d})$ 若$f(n)=\\sum_{i=1}^nt(i)g(\\frac{n}{i})$，则$g(n)=\\sum_{i=1}^n\\mu(i)t(i)f(\\frac{n}{i})$（此时代$t(i)=[gcd(n,i)&gt;1]$可得上式） 举例（其中$T=kd$）： $\\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)$ $=\\sum_d d\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd (i,j)=d]$ $=\\sum_{d}d\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor}[\\gcd (i,j)=1]$ $=\\sum_{d}d\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor}\\sum_{k\\mid i,k\\mid j}\\mu(k)$ $=\\sum_d d\\sum_k\\mu(k)\\sum_{k\\mid i}^{\\lfloor\\frac nd\\rfloor}\\sum_{k\\mid j}^{\\lfloor\\frac md\\rfloor}$ $=\\sum_{d}d\\sum_k\\mu(k)\\lfloor\\frac n{kd}\\rfloor\\lfloor\\frac m{kd}\\rfloor$ $=\\sum_{T}\\lfloor\\frac nT\\rfloor\\lfloor\\frac mT\\rfloor\\sum_{k\\mid T}\\frac Tk\\mu(k)$ $=\\sum_{T}\\lfloor\\frac nT\\rfloor\\lfloor\\frac mT\\rfloor\\varphi(T)$ $\\varphi(T)$可以使用线性筛预处理处理，我们就可以枚举$T$求上式了，时间复杂度$O(n)$。多组数据$n,m$询问上式，时间复杂度就变成了$O(Tn)$。事实上，$\\lfloor\\frac{n}{T}\\rfloor$是不会轻易变化的，是过了连续的一段后才发生变化的，那么我们就可以计算出这一段的结束位置，对$\\varphi$函数作前缀和，就可以直接分块了，这样的时间复杂度是$O(T\\sqrt{n})$的。 PollardRho大数素因子分解时间复杂度$O(N^{1/4})$，数据多的时候可考虑欧拉筛优化。 12345678910111213141516171819202122232425262728293031323334struct PollardRho{ bool isPrime(ll n, int S = 12) //MillerRabin素数测试，S为测试次数，用前S个素数测一遍，S=12可保证unsigned long long范围内无错；n&lt;2请特判 { ll d, u, t, p[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}; for (d = n - 1; !(d &amp; 1);) d &gt;&gt;= 1; //未对0，1做特判！ for (int i = 0; i &lt; S; ++i) { if (n % p[i] == 0) return n == p[i]; for (u = d, t = pow(p[i], u, n); u != n - 1 &amp;&amp; t != n - 1 &amp;&amp; t != 1; u &lt;&lt;= 1) t = mul(t, t, n); if (t != n - 1 &amp;&amp; !(u &amp; 1)) return 0; } return 1; } void fac(ll n, vector&lt;ll&gt; &amp;factor) { if (isPrime(n)) return factor.push_back(n); for (ll c = 1;; ++c) for (ll i = 0, k = 1, x = rand() % (n - 1) + 1, y, p;;) { if (++i == k) y = x, k &lt;&lt;= 1; if (x = (mul(x, x, n) + c) % n, p = gcd(abs(x - y), n), p == n) break; if (p &gt; 1) return fac(p, factor), fac(n / p, factor); } }}; 快速变换蝴蝶变换（雷德变换）保存FTT和FNTT时交换的对应位置（即保存的是置换）。 123456789struct Rader : vector&lt;int&gt;{ Rader(int n) : vector&lt;int&gt;(1 &lt;&lt; int(ceil(log2(n)))) { for (int i = at(0) = 0; i &lt; size(); ++i) if (at(i) = at(i &gt;&gt; 1) &gt;&gt; 1, i &amp; 1) at(i) += size() &gt;&gt; 1; }}; 快速傅里叶变换使用示例，高精度乘法。 123456789101112131415161718192021222324252627282930313233343536struct FFT : Rader{ vector&lt;complex&lt;lf&gt;&gt; w; FFT(int n) : Rader(n), w(size(), polar(1.0, 2 * PI / size())) { w[0] = 1; for (int i = 1; i &lt; size(); ++i) w[i] *= w[i - 1]; } vector&lt;complex&lt;lf&gt;&gt; fft(const vector&lt;complex&lt;lf&gt;&gt; &amp;a) const { vector&lt;complex&lt;lf&gt;&gt; x(size()); for (int i = 0; i &lt; a.size(); ++i) x[at(i)] = a[i]; for (int i = 1; i &lt; size(); i &lt;&lt;= 1) for (int j = 0; j &lt; i; ++j) for (int k = j; k &lt; size(); k += i &lt;&lt; 1) { complex&lt;lf&gt; &amp;l = x[k], &amp;r = x[k + i], t = w[size() / (i &lt;&lt; 1) * j] * r; r = l - t, l += t; } return x; } vector&lt;ll&gt; ask(const vector&lt;ll&gt; &amp;a, const vector&lt;ll&gt; &amp;b) const { vector&lt;complex&lt;lf&gt;&gt; xa(a.begin(), a.end()), xb(b.begin(), b.end()); xa = fft(xa), xb = fft(xb); for (int i = 0; i &lt; size(); ++i) xa[i] *= xb[i]; vector&lt;ll&gt; ans(size()); xa = fft(xa), ans[0] = xa[0].real() / size() + 0.5; for (int i = 1; i &lt; size(); ++i) ans[i] = xa[size() - i].real() / size() + 0.5; return ans; }}; 快速数论变换原理和FFT相同，解决特殊情况下FFT的浮点误差，并且可以在同余系进行变换。 对于形如$m=2^nc+1$的费马素数，记其原根为g，则旋转因子为$g^{(m-1)/n}$，满足$g^{m-1}=1$且$2^n\\mid m-1$。 常见素数的原根。 使用示例 1234567891011121314151617181920212223242526272829303132333435363738struct FNTT : Rader, Mod{ ll G; vector&lt;ll&gt; w; FNTT(int N, ll M, ll G) : Rader(N), Mod(M), G(G), w(size(), pow(G, (M - 1) / size())) { for (int i = w[0] = 1; i &lt; size(); ++i) w[i] = mul(w[i], w[i - 1]); } vector&lt;ll&gt; fntt(const vector&lt;ll&gt; &amp;a) const { vector&lt;ll&gt; x(size()); for (int i = 0; i &lt; a.size(); ++i) x[at(i)] = a[i]; for (int i = 1; i &lt; size(); i &lt;&lt;= 1) for (int j = 0; j &lt; i; ++j) for (int k = j; k &lt; size(); k += i &lt;&lt; 1) { ll t = mul(w[size() / (i &lt;&lt; 1) * j], x[k + i]); if (x[k + i] = x[k] - t, x[k + i] &lt; 0) x[k + i] += M; if (x[k] += t, x[k] &gt;= M) x[k] -= M; } return x; } vector&lt;ll&gt; ask(vector&lt;ll&gt; a, vector&lt;ll&gt; b) const { a = fntt(a), b = fntt(b); for (int i = 0; i &lt; size(); ++i) a[i] = mul(a[i], b[i]); a = fntt(a), reverse(a.begin() + 1, a.end()); ll u = inv(size()); for (int i = 0; i &lt; size(); ++i) a[i] = mul(a[i], u); return a; }}; 快速沃尔什变换如果要在同余系中进行运算，则下面代码需要修改。 12345678910111213141516void fwt(vector&lt;ll&gt; &amp;x, void f(ll &amp;l, ll &amp;r)){ for (int i = 1; i &lt; x.size(); i &lt;&lt;= 1) for (int j = 0; j &lt; i; ++j) for (int k = j; k &lt; x.size(); k += i &lt;&lt; 1) f(x[k], x[k + i]);}void fwt(ll *b, ll *e, void f(ll &amp;l, ll &amp;r)) //再给一个递归二分的代码便于理解{ if (e - b &lt; 2) return; ll *m = b + (e - b) / 2; fwt(b, m, f), fwt(m, e, f); while (m &lt; e) f(*(b++), *(m++));} AND12void tf(ll &amp;l, ll &amp;r) { l += r; }void utf(ll &amp;l, ll &amp;r) { l -= r; } OR12void tf(ll &amp;l, ll &amp;r) { r += l; }void utf(ll &amp;l, ll &amp;r) { r -= l; } XOR123456void tf(ll &amp;l, ll &amp;r){ ll tl = l + r, tr = l - r; l = tl, r = tr;}void utf(ll &amp;l, ll &amp;r) { tf(l, r), l &gt;&gt;= 1, r &gt;&gt;= 1; } XNOR、NAND、NOR直接用异或运算、与运算、或运算的方法求出来，然后将互反的两位交换即可。 Pell方程形如$x^2-Dy^2=1$（D为任意正整数）的方程称为佩尔方程，必有最小正整数解$(x_0,y_0)$，用$x_n=x_0x_{n-1}+Dy_0y_{n-1},y_n=y_0x_{n-1}+x_0y_{n-1}$可递推方程的第n小整数解（可用矩阵快速幂求），同时还有 $2x_0x_n=x_{n-1}+x_{n+1},2x_0y_n=y_{n-1}+y_{n+1}$ Bertrand猜想$\\forall n&gt;3,\\exist n&lt;p&lt;n\\times 2$其中n为整数，p为质数。 威尔逊定理当且仅当p为素数时：$(p-1)!\\equiv -1\\pmod p$， Jacobi’s Four Square Theorem设$a^2+b^2+c^2+d^2=n$的自然数解个数为$r4(n)$，$d(n)$为$n$的约数和，由Jacobi’s Four Square Theorem可知，若$n$是奇数，则$r4(n)=8d(n)$，否则$r4(n)=24d(k)$，$k$是$n$去除所有$2$后的结果。","link":"/2019/02/03/2019-02-03-数论/"},{"title":"高精度","text":"## 无符号整数 [使用范例](https://vjudge.net/solution/16907599) vector自带大小比较为字典序比较， `!=` 、 `==` 运算，其余需要时一定记得重载！ 减法，当被减数小于减数时减为0。 undefined ## 分数 [使用示范](https://vjudge.net/solution/16733633)。 undefined ## bitset高精度 代替整型进行位运算，更方便并且可以处理超过最大整形范围大小的位集合。 你可以把bitset看作可以位运算的bool数组，换言之，bitset的大小是固定的。因此，用bitset做状态压缩是很方便的，也可以方便的实现集合的交并补操作。 bitset仅重载了相等不等和位运算符，原生不支持四则运算和大小比较，所以很少代替高精度数。 undefined","link":"/2019/02/03/2019-02-03-高精度/"},{"title":"矩形面积并、矩形面积交、矩形周长并（线段树、扫描线总结）","text":"跟着这篇博客复习扫描线+线段树… Atlantis题目链接 求矩形并，即平面上至少被一个矩形覆盖的面积。 离散化: 这些技巧都是老生常谈的了，不然浮点数怎么建树，离散化x坐标就可以了。 扫描线: 首先把矩形按y轴分成两条边，上边和下边，对x轴建树，扫描线可以看成一根平行于x轴的直线。从y=0开始往上扫，下边表示要计算面积+1，上边表示已经扫过了−1，直到扫到最后一条平行于xx轴的边但是真正在做的时候，不需要完全模拟这个过程，一条一条边地插入线段树就好了。 线段树: 用于动态维护扫描线在往上走时，x轴哪些区域是有合法面积的。这种线段树是不用懒标记的，因为没有查询操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef double ll;struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }};struct AreaUnion{ struct Seg { ll l, r, h; int f; bool operator&lt;(const Seg &amp;rhs) const { return h &lt; rhs.h; } }; struct Node { int cnt; ll sum; }; vector&lt;Seg&gt; s; vector&lt;Node&gt; v; Ranker rk; void add(ll l, ll b, ll r, ll t) { rk.push_back(l); rk.push_back(r); s.push_back({l, r, b, 1}); s.push_back({l, r, t, -1}); } void upd(int ql, int qr, int c, int l, int r, int rt = 1) { if (ql &lt;= l &amp;&amp; r &lt;= qr) v[rt].cnt += c; else { int m = l + r &gt;&gt; 1; if (ql &lt;= m) upd(ql, qr, c, l, m, rt &lt;&lt; 1); if (qr &gt; m) upd(ql, qr, c, m + 1, r, rt &lt;&lt; 1 | 1); } v[rt].sum = v[rt].cnt ? rk[r + 1] - rk[l] : l &lt; r ? v[rt &lt;&lt; 1].sum + v[rt &lt;&lt; 1 | 1].sum : 0; } ll ask() { rk.init(); sort(s.begin(), s.end()); v.assign(rk.size() * 4, Node()); ll ans = 0; for (int i = 0; i + 1 &lt; s.size(); ++i) { upd(rk.ask(s[i].l), rk.ask(s[i].r) - 1, s[i].f, 0, rk.size() - 1); ans += v[1].sum * (s[i + 1].h - s[i].h); } return ans; }};int main(){ for (int kase = 0, n; ~scanf(\"%d\", &amp;n) &amp;&amp; n;) { AreaUnion a; for (int i = 0; i &lt; n; ++i) { ll l, b, r, t; scanf(\"%lf%lf%lf%lf\", &amp;l, &amp;b, &amp;r, &amp;t); a.add(l, b, r, t); } printf(\"Test case #%d\\nTotal explored area: %.2lf\\n\\n\", ++kase, a.ask()); }} 覆盖的面积题目链接 求矩形交，即平面上至少被覆盖两次的面积。线段树上维护被覆盖一次的长度和被覆盖两次的长度。 前面的与矩形面积并类似，不同的是要考虑至少覆盖一次one和至少覆盖两次two的更新。 尤其是当前被覆盖了一次的时候，由于没有down操作，父亲节点的信息是没有同步到儿子节点的，这样的话up就要考虑了。 父亲被记录覆盖了一次，但是如果儿子被覆盖过，这些操作都是在这个父亲这个大区间上的，就相当于父亲区间被覆盖了至少两次，所以two和one都要更新。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;typedef double ll;struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }};struct AreaIntersection{ struct Seg { ll l, r, h; int f; bool operator&lt;(const Seg &amp;rhs) const { return h &lt; rhs.h; } }; struct Node { int cnt; ll one, two; }; vector&lt;Seg&gt; s; vector&lt;Node&gt; v; Ranker rk; void add(ll l, ll b, ll r, ll t) { rk.push_back(l); rk.push_back(r); s.push_back({l, r, b, 1}); s.push_back({l, r, t, -1}); } void upd(int ql, int qr, int c, int l, int r, int rt = 1) { if (ql &lt;= l &amp;&amp; r &lt;= qr) v[rt].cnt += c; else { int m = l + r &gt;&gt; 1; if (ql &lt;= m) upd(ql, qr, c, l, m, rt &lt;&lt; 1); if (qr &gt; m) upd(ql, qr, c, m + 1, r, rt &lt;&lt; 1 | 1); } if (v[rt].cnt == 0) { v[rt].one = l != r ? v[rt &lt;&lt; 1].one + v[rt &lt;&lt; 1 | 1].one : 0; v[rt].two = l != r ? v[rt &lt;&lt; 1].two + v[rt &lt;&lt; 1 | 1].two : 0; } else { v[rt].one = rk[r + 1] - rk[l]; if (v[rt].cnt &gt; 1) v[rt].two = rk[r + 1] - rk[l]; else v[rt].two = l != r ? v[rt &lt;&lt; 1].one + v[rt &lt;&lt; 1 | 1].one : 0; } } ll ask() { rk.init(); sort(s.begin(), s.end()); v.assign(rk.size() * 4, Node()); ll ans = 0; for (int i = 0; i + 1 &lt; s.size(); ++i) { upd(rk.ask(s[i].l), rk.ask(s[i].r) - 1, s[i].f, 0, rk.size() - 1); ans += v[1].two * (s[i + 1].h - s[i].h); } return ans; }};int main(){ int t, n; for (scanf(\"%d\", &amp;t); t--;) { AreaIntersection a; scanf(\"%d\", &amp;n); for (ll l, b, r, t; n--;) { scanf(\"%lf%lf%lf%lf\", &amp;l, &amp;b, &amp;r, &amp;t); a.add(l, b, r, t); } printf(\"%.2lf\\n\", a.ask()); }} Picture题目链接 求矩形周长并。 解法一 可以用类似矩形面积并的办法，不过这次我们，不算面积罢了。 需要注意的是，由于周长的线会被重复覆盖，每次需要和上一次的作差。 但是这样仅仅是x轴的，不过可以再对y轴做一次加起来就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }};struct HalfPerimeter{ struct Seg { ll l, r, h; int f; bool operator&lt;(const Seg &amp;rhs) const { return h != rhs.h ? h &lt; rhs.h : f &gt; rhs.f; } }; struct Node { int cnt; ll sum; }; vector&lt;Seg&gt; s; vector&lt;Node&gt; v; Ranker rk; ll add(ll l, ll b, ll r, ll t) { rk.push_back(l); rk.push_back(r); s.push_back({l, r, b, 1}); s.push_back({l, r, t, -1}); } void upd(int L, int R, int c, int l, int r, int rt = 1) { if (L &lt;= l &amp;&amp; r &lt;= R) v[rt].cnt += c; else { int m = l + r &gt;&gt; 1; if (L &lt;= m) upd(L, R, c, l, m, rt &lt;&lt; 1); if (R &gt; m) upd(L, R, c, m + 1, r, rt &lt;&lt; 1 | 1); } v[rt].sum = v[rt].cnt ? rk[r + 1] - rk[l] : l != r ? v[rt &lt;&lt; 1].sum + v[rt &lt;&lt; 1 | 1].sum : 0; } ll ask() { rk.init(); sort(s.begin(), s.end()); v.assign(rk.size() &lt;&lt; 2, Node()); ll ans = 0; for (int i = 0; i &lt; s.size(); ++i) { ll last = v[1].sum; upd(rk.ask(s[i].l), rk.ask(s[i].r) - 1, s[i].f, 0, rk.size() - 1); ans += abs(v[1].sum - last); } return ans; }};int main(){ for (int n; ~scanf(\"%d\", &amp;n);) { HalfPerimeter x, y; for (int i = 0, l, b, r, t; i &lt; n; ++i) { scanf(\"%d%d%d%d\", &amp;l, &amp;b, &amp;r, &amp;t); x.add(l, b, r, t); y.add(b, l, t, r); } printf(\"%d\\n\", x.ask() + y.ask()); }} 解法二 也可以只对x轴做一次扫描线，只要同时维护y轴竖线（就是求矩形面积并的时候的高）的个数vtl。 需要的注意的是竖线重合的情况，需要再开变量lbd、rbd来判断重合，避免重复计算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ll;struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }};struct Perimeter{ struct Seg { ll l, r, h; int f; bool operator&lt;(const Seg &amp;rhs) const { return h &lt; rhs.h; } }; struct Node { int cnt; ll sum, vtl, lbd, rbd; }; vector&lt;Seg&gt; s; vector&lt;Node&gt; v; Ranker rk; void add(ll l, ll b, ll r, ll t) { rk.push_back(l); rk.push_back(r); s.push_back({l, r, b, 1}); s.push_back({l, r, t, -1}); } void upd(int ql, int qr, int c, int l, int r, int rt = 1) { if (ql &lt;= l &amp;&amp; r &lt;= qr) v[rt].cnt += c; else { int m = l + r &gt;&gt; 1; if (ql &lt;= m) upd(ql, qr, c, l, m, rt &lt;&lt; 1); if (qr &gt; m) upd(ql, qr, c, m + 1, r, rt &lt;&lt; 1 | 1); } if (v[rt].cnt) { v[rt].lbd = v[rt].rbd = 1; v[rt].sum = rk[r + 1] - rk[l]; v[rt].vtl = 2; } else if (l == r) v[rt].sum = v[rt].vtl = v[rt].lbd = v[rt].rbd = 0; else { v[rt].lbd = v[rt &lt;&lt; 1].lbd; v[rt].rbd = v[rt &lt;&lt; 1 | 1].rbd; v[rt].sum = v[rt &lt;&lt; 1].sum + v[rt &lt;&lt; 1 | 1].sum; v[rt].vtl = v[rt &lt;&lt; 1].vtl + v[rt &lt;&lt; 1 | 1].vtl; if (v[rt &lt;&lt; 1].rbd &amp;&amp; v[rt &lt;&lt; 1 | 1].lbd) v[rt].vtl -= 2; } } ll ask() { rk.init(); sort(s.begin(), s.end()); v.assign(rk.size() &lt;&lt; 2, Node()); ll ans = 0; for (int i = 0; i + 1 &lt; s.size(); ++i) { ll pre = v[1].sum; upd(rk.ask(s[i].l), rk.ask(s[i].r) - 1, s[i].f, 0, rk.size() - 1); ans += v[1].vtl * (s[i + 1].h - s[i].h) + abs(v[1].sum - pre); } return ans + abs(v[1].sum); }};int main(){ for (int n; ~scanf(\"%d\", &amp;n);) { Perimeter p; for (int i = 0, l, b, r, t; i &lt; n; ++i) { scanf(\"%d%d%d%d\", &amp;l, &amp;b, &amp;r, &amp;t); p.add(l, b, r, t); } printf(\"%d\\n\", p.ask()); }}","link":"/2019/02/26/2019-02-26-矩形面积并、矩形面积交、矩形周长并（线段树、扫描线总结）/"},{"title":"2015-2016 Petrozavodsk Winter Training Camp, Nizhny Novgorod SU Contest","text":"Forcefield undefined Missing Part给你一个串S，这个S是环状的，给你另外一个字符串S1，然后你需要定义一种大写的ABCDE到小写的abcde对应关系，使得失配数最小。 假设只有两种字符，那么1个卷积就行了。5个字符，最莽的做法是120个卷积，那得超时，预处理一下就是25个卷积。卷积当然要FFT啦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;using namespace std;typedef int ll;typedef double lf;const int N = 65535;const lf PI = acos(-1);struct Rader : vector&lt;int&gt;{ Rader(int n) : vector&lt;int&gt;(1 &lt;&lt; int(ceil(log2(n)))) { for (int i = at(0) = 0; i &lt; size(); ++i) if (at(i) = at(i &gt;&gt; 1) &gt;&gt; 1, i &amp; 1) at(i) += size() &gt;&gt; 1; }};struct FFT : Rader{ vector&lt;complex&lt;lf&gt;&gt; w; FFT(int n) : Rader(n), w(size(), polar(1.0, 2 * PI / size())) { w[0] = 1; for (int i = 1; i &lt; size(); ++i) w[i] *= w[i - 1]; } vector&lt;complex&lt;lf&gt;&gt; fft(const vector&lt;complex&lt;lf&gt;&gt; &amp;a) { vector&lt;complex&lt;lf&gt;&gt; x(size()); for (int i = 0; i &lt; a.size(); ++i) x[at(i)] = a[i]; for (int i = 1; i &lt; size(); i &lt;&lt;= 1) for (int j = 0; j &lt; i; ++j) for (int k = j; k &lt; size(); k += i &lt;&lt; 1) { complex&lt;lf&gt; &amp;l = x[k], &amp;r = x[k + i], t = w[size() / (i &lt;&lt; 1) * j] * r; r = l - t, l += t; } return x; } vector&lt;ll&gt; mul(vector&lt;complex&lt;lf&gt;&gt; xa, const vector&lt;complex&lt;lf&gt;&gt; &amp;xb) { for (int i = 0; i &lt; size(); ++i) xa[i] *= xb[i]; vector&lt;ll&gt; ans(size()); xa = fft(xa), ans[0] = xa[0].real() / size() + 0.5; for (int i = 1; i &lt; size(); ++i) ans[i] = xa[size() - i].real() / size() + 0.5; return ans; }};char a[N], b[N];int main(){ scanf(\"%s%s\", a, b); int n = strlen(a), ans = 0, p[5]; FFT f(n * 2); vector&lt;ll&gt; sum[5][5]; vector&lt;vector&lt;complex&lt;lf&gt;&gt;&gt; xa(5, vector&lt;complex&lt;lf&gt;&gt;(n * 2)), xb(5, vector&lt;complex&lt;lf&gt;&gt;(n * 2)); for (int i = 0; i &lt; 5; ++i) { for (int j = 0; j &lt; n; ++j) { if (a[j] == 'A' + i) xa[i][j] = xa[i][j + n] = 1; if (b[j] == 'a' + i) xb[i][n - j - 1] = 1; } xa[i] = f.fft(xa[i]), xb[i] = f.fft(xb[i]), p[i] = i; } for (int i = 0; i &lt; 5; ++i) for (int j = 0; j &lt; 5; ++j) sum[i][j] = f.mul(xa[i], xb[j]); do for (int j = 0, tmp; j &lt; n * 2; ++j) { for (int i = tmp = 0; i &lt; 5; ++i) tmp += sum[i][p[i]][j]; ans = max(ans, tmp); } while (next_permutation(p, p + 5)); printf(\"%d\", n - ans);} Cryptographic Argument折纸的过程就是蝴蝶变换。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll M = 1e9 + 7;struct Rader : vector&lt;int&gt;{ Rader(int n) : vector&lt;int&gt;(1 &lt;&lt; int(ceil(log2(n)))) { for (int i = at(0) = 0; i &lt; size(); ++i) if (at(i) = at(i &gt;&gt; 1) &gt;&gt; 1, i &amp; 1) at(i) += size() &gt;&gt; 1; }} rev0(1), rev1(1);ll h, k, m, l, r, a, b, c;ll ask(ll u){ ll p = u &gt;&gt; (k &gt;&gt; 1) + 1, q = p &lt;&lt; (k &gt;&gt; 1) ^ u &gt;&gt; 1; p = rev1[p], q = rev0[q]; if (u &amp; 1) p ^= rev1.size() - 1, q ^= rev0.size() - 1; return (q * rev1.size() | p) &lt;&lt; 1 | u &amp; 1;}int main(){ scanf(\"%lld%lld%lld%lld%lld%lld%lld\", &amp;k, &amp;m, &amp;l, &amp;r, &amp;a, &amp;b, &amp;c); rev0 = Rader(1 &lt;&lt; (k &gt;&gt; 1)), rev1 = Rader(1 &lt;&lt; k - (k &gt;&gt; 1) - 1); for (ll i = 0, n = 1LL &lt;&lt; k; i &lt; m; ++i) { if (l &amp; 1) { if (r &amp; 1) h ^= (r - l &gt;&gt; 1) * (n - 1) + ask(l); else h ^= (r - l - 1 &gt;&gt; 1) * (n - 1) + ask(l) + ask(r); } else { if (r &amp; 1) h ^= (r - l + 1 &gt;&gt; 1 &amp; 1) * (n - 1); else h ^= (r - l &gt;&gt; 1 &amp; 1) * (n - 1) ^ ask(r); } h = ((l ^ r ^ h) + c) % M; l = (l ^ a ^ h) % (n + 1) % n; r = (r ^ b ^ h) % (n - l) + l; } printf(\"%lld\", h);} The Jedi Killer28、29行的EPS不能用sgn去掉，暂时不知道为啥…改了之后WA4（猜测是浮点数做减法的时候的对齐操作丢了精度）。 启示是浮点数比较大小的时候不能作差判sgn… 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define X real()#define Y imag()using namespace std;typedef double lf;typedef complex&lt;lf&gt; Coord;const lf EPS = 1e-9;int sgn(lf d) { return (d &gt; EPS) - (d &lt; -EPS); }lf Cross(const Coord &amp;A, const Coord &amp;B) { return A.X * B.Y - B.X * A.Y; }int main(){ int t, lm, lg, ans; for (scanf(\"%d\", &amp;t); t--; printf(ans ? \"YES\\n\" : \"NO\\n\")) { scanf(\"%d%d\", &amp;lm, &amp;lg); vector&lt;Coord&gt; p; for (int i = 0, x, y; i &lt; 3; ++i) scanf(\"%d%d\", &amp;x, &amp;y), p.emplace_back(x, y); if (!sgn(Cross(p[0] - p[1], p[1] - p[2]))) ans = sgn(max(max(abs(p[0] - p[1]), abs(p[1] - p[2])), abs(p[2] - p[0])) - max(lm, lg * 2)) &lt;= 0; else for (int i = ans = 0; !ans &amp;&amp; i &lt; 3; ++i) { lf d0 = abs(p[(i + 1) % 3] - p[(i + 2) % 3]), h = fabs(Cross(p[(i + 1) % 3] - p[i], p[(i + 2) % 3] - p[i]) / d0), d1 = sqrt(norm(p[i] - p[(i + 1) % 3]) - h * h), d2 = sqrt(norm(p[i] - p[(i + 2) % 3]) - h * h); ans = sgn(h - lm) &lt;= 0 &amp;&amp; max(d1, d2) &lt;= lg + EPS || sgn(h - lg) &lt;= 0 &amp;&amp; max(d1, d2) &lt;= lm + EPS &amp;&amp; sgn(h * h + d0 * d0 - max(norm(p[i] - p[(i + 1) % 3]), norm(p[i] - p[(i + 2) % 3]))) &lt;= 0; } }} Youngling Tournament给你n个数，然后从大到小排序，如果这个数不小于他后面的数的和，那么这个数就是胜利者。 单点修改，问你每次胜利者有多少个。 树状数组+multiset瞎几把做即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 7;struct BaseFenwick{ vector&lt;ll&gt; v; BaseFenwick(int n) : v(n, 0) {} void add(int x, ll w) { for (; x &lt; v.size(); x += x &amp; -x) v[x] += w; } ll ask(int x) { ll ans = 0; for (; x; x -= x &amp; -x) ans += v[x]; return ans; }};struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }} rk;ll n, m, a[N], b[N], c[N];int main(){ scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", &amp;a[i]), rk.push_back(a[i]); scanf(\"%lld\", &amp;m); for (int i = 0; i &lt; m; ++i) scanf(\"%lld%lld\", &amp;b[i], &amp;c[i]), rk.push_back(c[i]); rk.init(); multiset&lt;ll&gt; s; BaseFenwick t(rk.size() + 1); for (int i = 1; i &lt;= n; ++i) s.insert(a[i]), t.add(rk.ask(a[i]) + 1, a[i]); for (int i = 0;; ++i) { int res = 1; multiset&lt;ll&gt;::iterator p = s.begin(), q = p++; if (*p == *q) ++res; while (1) { p = s.lower_bound(t.ask(rk.ask(*q) + 1)); if (p == s.begin()) ++p; if (p == s.end()) break; q = p--; if (*q &gt;= t.ask(rk.ask(*p) + 1)) ++res; } printf(\"%d\\n\", res); if (i == m) break; s.erase(s.find(a[b[i]])); t.add(rk.ask(a[b[i]]) + 1, -a[b[i]]); s.insert(a[b[i]] = c[i]); t.add(rk.ask(a[b[i]]) + 1, a[b[i]]); }} Garland Checking不做路径压缩的并查集，增加一个splay操作，用于把某个点旋转到并查集的顶点。 正解是LCT…待学习。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;struct UnionFindSet{ vector&lt;int&gt; fa; UnionFindSet(int n) : fa(n) { for (int i = 0; i &lt; n; ++i) fa[i] = i; } void splay(int u, int f) { if (fa[u] != u) splay(fa[u], u); fa[u] = f; } int ask(int u) { return fa[u] != u ? ask(fa[u]) : u; }};char s[9];int n, a, b;int main(){ scanf(\"%d\", &amp;n); for (UnionFindSet ufs(n + 1); ~scanf(\"%s\", s) &amp;&amp; s[0] != 'E';) { scanf(\"%d%d\", &amp;a, &amp;b), ufs.splay(a, a), ufs.splay(b, b); if (s[0] == 'T') printf(ufs.ask(a) == b ? \"YES\\n\" : \"NO\\n\"), fflush(stdout); else ufs.fa[a] = s[0] == 'D' ? a : b; }}","link":"/2019/03/03/2019-03-03-2015-2016 Petrozavodsk Winter Training Camp, Nizhny Novgorod SU Contest/"},{"title":"","text":"实验题目Echo实验 实验目的掌握套节字的基本使用方法 参考资料 https://www.cnblogs.com/hgwang/p/6074038.html （套接字） https://www.jb51.net/article/37410.htm （字符串） https://docs.microsoft.com/en-us/c/c-runtime-library/stream-i-o?view=vs-2017 （字符串） https://docs.microsoft.com/en-us/c/c-runtime-library/reference/crt-alphabetical-function-reference?view=vs-2017#s （字符串） http://www.runoob.com/cprogramming/ （字符串） 实验环境 Windows + VS 2012 http://172.18.187.9/netdisk/default.aspx?vm=17net 对于VS2015和VS2017默认使用安全周期检查，如果不关闭VS的安全周期检查，很多字符串函数都不能用。 Linux + gcc 这里我使用的环境是Windows 10 + VSCode + gcc version 8.1.0 (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project) 实验内容编写TCP Echo增强程序实验要求：服务器把客户端发送来的任何消息都返回给客户端，返回的消息前面要加上服务器的当前时间。客户端把返回的消息显示出来。客户端每输入一条消息就建立TCP连接，并把消息发送给服务器，在收到服务器回应后关闭连接。在这一基础上，服务器在收到客户端的消息时显示服务器的当前时间、客户端的IP地址、客户端的端口号和客户端发来的信息，并把它们一并返回给客户端。客户端在发送消息后把服务器发回给它的消息显示出来。要求服务器直接从accept()的参数fsin中得到客户端的IP地址和端口号。服务器获取IP地址后要求直接使用s_un_b的四个分量得到IP地址，不能使用函数inet_ntoa()转换IP地址。 只运行客户端程序而不运行服务器程序会出现什么错误，截屏并说明原因。如图，退出了服务器程序后再运行客户端程序，得到了10057的报错。 服务器如何可以退出循环？kbhit()在执行时,检测是否有按键按下,有按下返回非0值，没有按下则返回0，是非阻塞函数；因此，预期在监听的过程中将服务器程序从后台激活并按下键盘按键即可退出循环。 然而，在实际运行中这样是失效的，正是因为他是非阻塞函数，而下面收发信息却是阻塞的。因此退出循环只有我们在命令行中手动按Ctrl+C了。 截屏（ctrl+alt+PrintScreen）服务器和客户端的运行结果（注明客户端和服务器）客户端：服务器： 服务器的全部源代码（或自选主要代码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;winsock2.h&gt;#include &lt;conio.h&gt;#define BUFLEN 2000#define WSVERS MAKEWORD(2, 0)#pragma comment(lib, \"ws2_32.lib\") //使用winsock 2.2 libraryint main(int argc, char *argv[]) // argc: 命令行参数个数，例如：C:\\&gt; TCPServer 8080 argc=2 argv[0]=“TCPServer\", argv[1]=\"8080\"{ struct sockaddr_in fsin; // the from address of a client SOCKET msock, ssock; // master &amp; slave sockets WSADATA wsadata; char service[] = \"50500\"; struct sockaddr_in sin; // an Internet endpoint address int alen; // from-address length char pts[BUFLEN + 1]; // pointer to time string time_t now; // current time WSAStartup(WSVERS, &amp;wsadata); // 加载winsock library，WSVERS为请求版本，wsadata返回系统实际支持的最高版本 msock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); // 创建套接字。 参数：因特网协议簇(family)，字节流，TCP协议号。 返回：要监听套接字的描述符或INVALID_SOCKET memset(&amp;sin, 0, sizeof(sin)); //从&amp;sin开始的长度为sizeof(sin)的内存清0 , sin为一个地址结构 sin.sin_family = AF_INET; //因特网地址簇(INET-Internet) sin.sin_addr.s_addr = INADDR_ANY; //监听所有(接口的)IP地址(32位)，// 0.0.0.0 sin.sin_port = htons((u_short)atoi(service)); //监听的端口号(16位) 。atoi--把ascii转化为int，htons—主机序到网络序 bind(msock, (struct sockaddr *)&amp;sin, sizeof(sin)); // 通过sin把要监听的IP地址和端口号绑定到套接字上 listen(msock, 5); // 建立长度为5的连接请求队列，并开始监听是否有连接请求到来，来了则放入队列 printf(\"Server Start to listen.\\n\"); while (!_kbhit()) // 检测是否有按键 (什么时候执行？) { alen = sizeof(struct sockaddr); ssock = accept(msock, (struct sockaddr *)&amp;fsin, &amp;alen); // accept：如果有新的连接请求，返回连接套接字，否则，被阻塞，fsin包含客户端IP地址和端口号 time(&amp;now); // 取得系统时间 int cnt = sprintf(pts, \"Accept Time:\\n\" \"%s\" \"sin_port:\\n\" \"%u\\n\" \"sin_addr:\\n\" \"%d.%d.%d.%d\\n\" \"Receive Message:\\n\", ctime(&amp;now), fsin.sin_port, fsin.sin_addr.S_un.S_un_b.s_b1, fsin.sin_addr.S_un.S_un_b.s_b2, fsin.sin_addr.S_un.S_un_b.s_b3, fsin.sin_addr.S_un.S_un_b.s_b4); // 把时间转换为字符串 int cc = recv(ssock, pts + cnt, BUFLEN - cnt, 0); pts[cnt + cc] = 0; printf(\"\\n%s\\n\", pts); send(ssock, pts, cnt + cc, 0); closesocket(ssock); // 关闭连接套接字 } closesocket(msock); WSACleanup(); system(\"pause\");} 客户端的全部源代码（或自选主要代码）123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;winsock2.h&gt;#define BUFLEN 2000#define WSVERS MAKEWORD(2, 0)#pragma comment(lib, \"ws2_32.lib\")int main(int argc, char *argv[]){ char host[] = \"127.0.0.1\"; // server IP to connect，127.0.0.1指本机 char service[] = \"50500\"; // server port to connect struct sockaddr_in sin; // an Internet endpoint address char buf[BUFLEN + 1], msg[BUFLEN + 1]; // buffer for one line of text SOCKET sock; // socket descriptor int cc; // recv character count WSADATA wsadata; WSAStartup(WSVERS, &amp;wsadata); sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); memset(&amp;sin, 0, sizeof(sin)); // sin的内存清0 sin.sin_family = AF_INET; // 因特网地址簇 sin.sin_addr.s_addr = inet_addr(host); // 服务器IP地址(32位) sin.sin_port = htons((u_short)atoi(service)); // 服务器端口号(16位) printf(\"Send the Message:\\n\"); gets(msg); int ret = connect(sock, (struct sockaddr *)&amp;sin, sizeof(sin)); // 连接到服务器.无错时，返回0， // 否则，返回SOCKET_ERROR ，可以调用 // 函数WSAGetLastError取得错误代码 cc = send(sock, msg, strlen(msg), 0); //把缓冲区pts的数据发送出去，len为要发送的字节数， // 返回值：(&gt;0) 实际发送的字节数(≤len), (=0) 对方正常关闭， // （=SOCKET_ERROR) 出错，用函数WSAGetLastError取错误码。 cc = recv(sock, buf, BUFLEN, 0); // BUFLEN为缓冲区buf的长度。 // 返回值：接收的字符数(&gt;0)、对方已关闭(=0) 或连接出错(&lt;0) if (cc == SOCKET_ERROR) printf(\"Error:\\n%d.\\n\", GetLastError()); else if (cc == 0) printf(\"Server closed.\\n\"); else if (cc &gt; 0) { buf[cc] = '\\0'; // ensure null-termination printf(\"\\n%s\\n\", buf); // 显示所接收的字符串 } closesocket(sock); // 关闭套接字 WSACleanup(); // 卸载winsock library system(\"pause\");} 编写UDP Echo增强程序实验要求修改UDP例程，完成Echo功能，即当客户端发来消息时，服务器显示出服务器的当前时间、客户端的IP、客户端的端口号和客户发来的信息，并把它们一并发回给客户端，客户端然后把它们显示出来。服务器可以直接从recvfrom()的参数from中得到客户端的IP地址和端口号，并且服务器用sendto()发回给客户端消息时可以直接用该参数from作为参数toAddr。可以使用inet_ntoa()转换客户端IP地址。客户端程序的recvfrom()可以直接使用原来sendto使用的sock。该sock已经绑定了客户端的IP地址和端口号，客户端可以直接用来接收数据。 只运行客户端程序而不运行服务器程序会出现什么错误，截屏并说明原因如图，在发送时没有报错，但是试图从服务器获得信息时获得了10054的报错。 截屏服务器和客户端的运行结果（注明客户端和服务器）服务器： 服务器的全部源代码（或自选主要代码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;#include &lt;winsock2.h&gt;#define BUFLEN 2000 // 缓冲区大小#define WSVERS MAKEWORD(2, 2) // 指明版本2.2#pragma comment(lib, \"ws2_32.lib\") // 加载winsock 2.2 Llibraryvoid main(int argc, char *argv[]){ char host[] = \"127.0.0.1\"; // server IP Address to connect char service[] = \"50500\"; // server port to connect struct sockaddr_in sin; // an Internet endpoint address struct sockaddr_in from; // sender address int fromsize = sizeof(from); char buf[BUFLEN + 1], pts[BUFLEN + 1]; // buffer for one line of text SOCKET sock; // socket descriptor int cc; // recv character count WSADATA wsadata; WSAStartup(WSVERS, &amp;wsadata); // 加载winsock library，WSVERS为请求版本,wsadata返回系统实际支持的最高版本。 sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); // 创建UDP套接字, 参数：因特网协议簇(family)，数据报套接字，UDP协议号， 返回：要监听套接字的描述符或INVALID_SOCKET memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = INADDR_ANY; // 绑定(监听)所有的接口。 sin.sin_port = htons((u_short)atoi(service)); // 绑定指定接口。atoi--把ascii转化为int，htons -- 主机序(host)转化为网络序(network), 为short类型。 bind(sock, (struct sockaddr *)&amp;sin, sizeof(sin)); // 绑定本地端口号（和本地IP地址) printf(\"UDPServer Start.\\n\"); while (!_kbhit()) { //检测是否有按键 cc = recvfrom(sock, buf, BUFLEN, 0, (SOCKADDR *)&amp;from, &amp;fromsize); //接收客户数据。返回结果：cc为接收的字符数，from中将包含客户IP地址和端口号。 if (cc == SOCKET_ERROR) { printf(\"recvfrom() failed; %d\\n\", WSAGetLastError()); break; } else if (cc == 0) break; else { buf[cc] = 0; time_t now; time(&amp;now); // 取得系统时间 sprintf(pts, \"Accept Time:\\n\" \"%s\" \"sin_port:\\n\" \"%u\\n\" \"sin_addr:\\n\" \"%d.%d.%d.%d\\n\" \"Receive Message:\\n\" \"%s\\n\", ctime(&amp;now), from.sin_port, from.sin_addr.S_un.S_un_b.s_b1, from.sin_addr.S_un.S_un_b.s_b2, from.sin_addr.S_un.S_un_b.s_b3, from.sin_addr.S_un.S_un_b.s_b4, buf); printf(\"%s\", pts); cc = sendto(sock, pts, strlen(pts), 0, (SOCKADDR *)&amp;from, fromsize); } } closesocket(sock); WSACleanup(); // 卸载某版本的DLL system(\"pause\");} 客户端的全部源代码（或自选主要代码）123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;winsock2.h&gt;#define BUFLEN 2000 // 缓冲区大小#define WSVERS MAKEWORD(2, 2) // 指明版本2.2#pragma comment(lib, \"ws2_32.lib\") // 加载winsock 2.2 Llibraryvoid main(int argc, char *argv[]){ char host[] = \"127.0.0.1\"; // server IP to connect char service[] = \"50500\"; // server port to connect struct sockaddr_in toAddr, from; // an Internet endpoint address int fromsize = sizeof(from); char buf[BUFLEN + 1]; // buffer for one line of text SOCKET sock; // socket descriptor int cc; // recv character count WSADATA wsadata; WSAStartup(WSVERS, &amp;wsadata); // 启动某版本Socket的DLL sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP); memset(&amp;toAddr, 0, sizeof(toAddr)); toAddr.sin_family = AF_INET; toAddr.sin_port = htons((u_short)atoi(service)); //atoi：把ascii转化为int. htons：主机序(host)转化为网络序(network), s--short toAddr.sin_addr.s_addr = inet_addr(host); //如果host为域名，需要先用函数gethostbyname把域名转化为IP地址 printf(\"Send the Message:\\n\"); gets(buf); cc = sendto(sock, buf, strlen(buf), 0, (SOCKADDR *)&amp;toAddr, sizeof(toAddr)); if (cc == SOCKET_ERROR) printf(\"Error:\\n%d\\n\", WSAGetLastError()); else { cc = recvfrom(sock, buf, BUFLEN, 0, (SOCKADDR *)&amp;from, &amp;fromsize); if (cc == SOCKET_ERROR) printf(\"Receive Error:\\n%d\\n\", WSAGetLastError()); else printf(\"%s\", buf); } closesocket(sock); WSACleanup(); // 卸载某版本的DLL system(\"pause\");} 实验体会在Windows下使用gcc编译，需要加编译指令-lwsock32来引入套接字的库，于是写了如下脚本帮助编译： 12gcc TCPServer.c -o TCPServer -lwsock32gcc TCPClient.c -o TCPClient -lwsock32 节省了不少时间。 服务器对收到的消息进行处理这里使用了sprintf这个函数，感觉相比别的方法简化了很多代码。 想当然的认为服务器程序只需要按下键盘就会退出，说明一开始对阻塞的理解还不透彻啊。","link":"/2019/04/11/2019-03-11-Echo实验/"},{"title":"","text":"实验题目Chat实验 实验目的掌握套节字的多线程编程方法。 实验介绍利用客户/服务器(Client/Sever或CS)模式实现一个多人聊天(群聊)程序。其功能是每个客户发送给服务器的消息都会传送给所有的客户端。 123456graph TB服务器--Hello--&gt;AA==Hello==&gt;服务器服务器--Hello--&gt;B服务器--Hello--&gt;C服务器--Hello--&gt;D 参考资料 https://docs.microsoft.com/en-us/windows/desktop/WinSock/getting-started-with-winsock （套接字） https://www.cnblogs.com/hgwang/p/6074038.html （套接字） https://www.jb51.net/article/37410.htm （字符串） https://docs.microsoft.com/en-us/cpp/c-runtime-library/stream-i-o?view=vs-2017 （字符串） https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/crt-alphabetical-function-reference?view=vs-2017#s （字符串） http://www.runoob.com/cprogramming/ （字符串） 例程“_beginthreadex” （创建线程） 例程“TCPServer和TCPClient” （传送服务器时间） 课件“套接字并发编程.PDF” Chat实验的课件 实验环境 Windows + VS 2012 对于VS2015和VS2017默认使用安全周期检查，如果不关闭VS的安全周期检查，很多字符串函数都不能用。 Linux + gcc 这里我使用的环境是Windows 10 + VSCode + gcc version 8.1.0 (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project) 实验内容先阅读课件“套接字并发编程.PDF”。重点是读懂课件中“chat并发编程(服务器)”和“chat并发编程(客户端)”的流程图。 然后，完成下面步骤（截屏要同时显示服务器和至少两个客户端）： 编写多人聊天程序，要求客户端和服务器都采用多线程方式进行编程。每个客户端都采用TCP协议连接服务器并保持连接。服务器同时与所有客户端建立和保持连接。每个客户端输入的消息都会通过服务器转发给所有客户。 服务器程序转发某个客户端发来的消息时都在消息前面加上该客户端的IP地址和端口号以及服务器的当前时间。要求服务器程序把转发的 消息也显示出来。 新客户刚连接时服务器端把“enter”消息（包含客户端IP地址和端口号）发送给所有客户端。 客户端输入exit时退出客户端程序（正常退出），或者客户端直接关闭窗口退出（异常退出），服务器都会把该客户leave的消息广播给所有客户。 客户端程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;process.h&gt;#include &lt;winsock2.h&gt;#define BUFLEN 2000#define WSVERS MAKEWORD(2, 0)#pragma comment(lib, \"ws2_32.lib\")int finish = 0;unsigned __stdcall recvMessage(SOCKET *p){ for (char buf[BUFLEN];;) { int cc = recv(*p, buf, BUFLEN, 0); // BUFLEN为缓冲区buf的长度，返回值：接收的字符数(&gt;0)、对方已关闭(=0) 或连接出错(&lt;0) if (finish) return 0; if (cc &gt; 0) { buf[cc] = '\\0'; // ensure null-termination printf(\"%s\", buf); // 显示所接收的字符串 } else if (cc == SOCKET_ERROR) printf(\"Recv Error:\\n%d\\n\", GetLastError()); else if (cc == 0) printf(\"Recv connect closed.\\n\"); }}int main(){ char buf[BUFLEN]; WSADATA wsadata; WSAStartup(WSVERS, &amp;wsadata); struct sockaddr_in sin; // an Internet endpoint address memset(&amp;sin, 0, sizeof(sin)); sin.sin_family = AF_INET; // 因特网地址簇 printf(\"Input the IP address:\\n\"); gets(buf); sin.sin_addr.s_addr = inet_addr(buf); // 服务器IP地址(32位) printf(\"Input the IP port:\\n\"); gets(buf); sin.sin_port = htons(atoi(buf)); // 服务器端口号(16位) SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); // socket descriptor int ret = connect(sock, &amp;sin, sizeof(sin)); // 连接到服务器.无错时，返回0；否则，返回SOCKET_ERROR ，可以调用函数WSAGetLastError取得错误代码 HANDLE h = _beginthreadex(NULL, 0, &amp;recvMessage, &amp;sock, 0, NULL); for (;;) { gets(buf); if (!strcmp(buf, \"exit\")) break; int cc = send(sock, buf, strlen(buf), 0); //把缓冲区buf的数据发送出去，len为要发送的字节数，返回值：(&gt;0) 实际发送的字节数(≤len), (=0) 对方正常关闭，（=SOCKET_ERROR) 出错，用函数WSAGetLastError取错误码。 if (cc == SOCKET_ERROR) printf(\"Send Error:\\n%d\\n\", GetLastError()); else if (cc == 0) printf(\"Send connect closed.\\n\"); } finish = 1; CloseHandle(h); closesocket(sock); // 关闭套接字 WSACleanup(); // 卸载winsock library system(\"pause\");} 服务器端程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;process.h&gt;#include &lt;winsock2.h&gt;#define BUFLEN 2000#define WSVERS MAKEWORD(2, 0)#pragma comment(lib, \"ws2_32.lib\") //使用winsock 2.2 librarySOCKET ssock[BUFLEN]; //master &amp; *p socketsstruct sockaddr_in ssin[BUFLEN];int sbadd[BUFLEN], ssock_size = 0;unsigned __stdcall server(int *p){ for (char msg[BUFLEN] = \"Enter!\", pts[BUFLEN];;) { time_t now = time(NULL); sprintf(pts, \"ip: %d.%d.%d.%d port: %u\\n\" \"time: %s\" \"message: %s\\n\" \"\\n&gt;&gt;\", ssin[*p].sin_addr.S_un.S_un_b.s_b1, ssin[*p].sin_addr.S_un.S_un_b.s_b2, ssin[*p].sin_addr.S_un.S_un_b.s_b3, ssin[*p].sin_addr.S_un.S_un_b.s_b4, ssin[*p].sin_port, ctime(&amp;now), msg); printf(pts); for (int i = 0; i &lt; ssock_size; ++i) send(ssock[i], pts, strlen(pts), 0); if (!strcmp(msg, \"Leave!\")) return closesocket(ssock[*p]), 0; //关闭连接套接字 int cc = recv(ssock[*p], msg, BUFLEN, 0); if (cc &gt; 0) msg[cc] = 0; else sprintf(msg, \"Leave!\"); }}int main(){ WSADATA wsadata; WSAStartup(WSVERS, &amp;wsadata); //加载winsock library，WSVERS为请求版本，wsadata返回系统实际支持的最高版本 struct sockaddr_in msin; //an Internet endpoint addresss memset(&amp;msin, 0, sizeof(msin)); //从&amp;sin开始的长度为sizeof(sin)的内存清0 , sin为一个地址结构 msin.sin_family = AF_INET; //因特网地址簇(INET-Internet) msin.sin_addr.s_addr = INADDR_ANY; //监听所有(接口的)IP地址(32位)，0.0.0.0 msin.sin_port = htons(atoi(\"50500\")); //监听的端口号(16位) 。atoi--把ascii转化为int，htons—主机序到网络序 SOCKET msock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); //创建套接字。参数：因特网协议簇(family)，字节流，TCP协议号。 返回：要监听套接字的描述符或INVALID_SOCKET bind(msock, (struct sockaddr *)&amp;msin, sizeof(msin)); //通过msin把要监听的IP地址和端口号绑定到套接字上 listen(msock, 5); //建立长度为5的连接请求队列，并开始监听是否有连接请求到来，来了则放入队列 printf(\"Server Start to listen.\\n\"); while (!_kbhit()) //检测是否有按键 (什么时候执行？) { int alen = sizeof(struct sockaddr); //from-address length ssock[ssock_size] = accept(msock, (struct sockaddr *)&amp;ssin[ssock_size], &amp;alen); //accept：如果有新的连接请求，返回连接套接字，否则，被阻塞，ssin包含客户端IP地址和端口号 sbadd[ssock_size] = ssock_size; _beginthreadex(NULL, 0, &amp;server, &amp;sbadd[ssock_size++], 0, NULL); } closesocket(msock); WSACleanup(); system(\"pause\");} 运行效果如下： 测试一下客户端是否能够连上老师在校园网搭的服务器（172.18.187.9:50500）：运行截屏（客户端）： 和同学互测一下看看，作为服务器运行截屏：作为客户端运行截屏： 实验体会 在服务端的程序中，一开始传新连接的下标的指针到子线程的时候直接传了一个局部变量过去，结果在新开的线程里就会出错；原因是局部变量已经被析构。随后使用一个全局数组作为过渡。为什么是数组？因为假设只用一个变量进行过渡的话，在有多人同时连接，新开多个线程时可能该变量的变化早于新开线程的参数传递。 在和同学测试时没有关掉本机防火墙，导致接收不到同学发来的消息。 客户端输入exit下线时，如果不接受的线程不同时关闭的话会不断报错。于是额外用一个全局变量finish来中转，子线程在finish值变化的时候不再接受消息。","link":"/2019/04/11/2019-03-19-Chat实验/"},{"title":"Homework 2 MPI编程直方图","text":"题目链接 第一次做不是ACM的题解了。 使用MPI实现2.7.1节讨论的直方图程序，进程0读取输入的数据，并将它们分配到其余进程，最后进程0打印该直方图。请根据提供的代码，将代码补充完整！ 需要补充的部分见注释 PLEASE ADD THE RIGHT CODES 部分。可直接点击下方作业题目跳转至在线编程平台，点击参考代码，补充完整后提交。（或下载附件 prog3.1_mpi_histo(blank).zip） 在参考代码的基础上加了155行和168~175行就解决问题了。这里找对应下标的时候使用了二分，其实是可以直接算出来的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309/* * File: prog3.1_mpi_histo.c * * Purpose: Use MPI to implement a program that creates a histogram * * Compile: mpicc -g -Wall -o prog3.1_mpi_histo prog3.1_mpi_histo.c * Run: mpiexec -n &lt;comm_sz&gt; ./prog3.1_mpi_histo * * Input: Number of bins * Minimum measurement * Maximum measurement * Number of data items * * Output: Histogram of the data. If DEBUG flag is set, the data * generated. * * Notes: * 1. The number of data must be evenly divisible by the number of processes * 2. The program generates random floats x in the range * * min measurement &lt;= x &lt; max measurement * * 3. If i &gt;= 1, the ith bin contains measurements x in the * range * * bin_maxes[i-1] &lt;= x &lt; bin_maxes[i] * * Bin 0 will contain measurements x in the range * * min measurement &lt;= x &lt; bin_maxes[0] * * * IPP: Programming Assignment 3.1 */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;mpi.h&gt;void Get_input(int *bin_count_p, float *min_meas_p, float *max_meas_p, int *data_count_p, int *local_data_count_p, int my_rank, int comm_sz, MPI_Comm comm);void Check_for_error(int local_ok, char fname[], char message[], MPI_Comm comm);void Gen_data(float local_data[], int local_data_count, int data_count, float min_meas, float max_meas, int my_rank, MPI_Comm comm);void Set_bins(float bin_maxes[], int loc_bin_cts[], float min_meas, float max_meas, int bin_count, int my_rank, MPI_Comm comm);void Find_bins(int bin_counts[], float local_data[], int loc_bin_cts[], int local_data_count, float bin_maxes[], int bin_count, float min_meas, MPI_Comm comm);int Which_bin(float data, float bin_maxes[], int bin_count, float min_meas);void Print_histo(float bin_maxes[], int bin_counts[], int bin_count, float min_meas);/*---------------------------------------------------------------------*/int main(void){ int bin_count; float min_meas, max_meas; float *bin_maxes; int *bin_counts; int *loc_bin_cts; int data_count; int local_data_count; float *data; float *local_data; int my_rank, comm_sz; MPI_Comm comm; MPI_Init(NULL, NULL); comm = MPI_COMM_WORLD; MPI_Comm_size(comm, &amp;comm_sz); MPI_Comm_rank(comm, &amp;my_rank); // get user inputs for bin_count, max_meas, min_meas, and data_count Get_input(&amp;bin_count, &amp;min_meas, &amp;max_meas, &amp;data_count, &amp;local_data_count, my_rank, comm_sz, comm); // allocate arrays bin_maxes = malloc(bin_count * sizeof(float)); bin_counts = malloc(bin_count * sizeof(int)); loc_bin_cts = malloc(bin_count * sizeof(int)); data = malloc(data_count * sizeof(float)); local_data = malloc(local_data_count * sizeof(float)); Set_bins(bin_maxes, loc_bin_cts, min_meas, max_meas, bin_count, my_rank, comm); Gen_data(local_data, local_data_count, data_count, min_meas, max_meas, my_rank, comm); Find_bins(bin_counts, local_data, loc_bin_cts, local_data_count, bin_maxes, bin_count, min_meas, comm); if (my_rank == 0) Print_histo(bin_maxes, bin_counts, bin_count, min_meas); free(bin_maxes); free(bin_counts); free(loc_bin_cts); free(data); free(local_data); MPI_Finalize(); return 0;} /* main *//*---------------------------------------------------------------------*/void Print_histo( float bin_maxes[] /* in */, int bin_counts[] /* in */, int bin_count /* in */, float min_meas /* in */){ int i, j; float bin_max, bin_min; for (i = 0; i &lt; bin_count; i++) { bin_max = bin_maxes[i]; bin_min = (i == 0) ? min_meas : bin_maxes[i - 1]; printf(\"%.3f-%.3f:\\t\", bin_min, bin_max); for (j = 0; j &lt; bin_counts[i]; j++) printf(\"X\"); printf(\"\\n\"); }} /* Print_histo *//*---------------------------------------------------------------------*/void Find_bins( int bin_counts[] /* out */, float local_data[] /* in */, int loc_bin_cts[] /* out */, int local_data_count /* in */, float bin_maxes[] /* in */, int bin_count /* in */, float min_meas /* in */, MPI_Comm comm){ int i, bin; for (i = 0; i &lt; local_data_count; i++) { bin = Which_bin(local_data[i], bin_maxes, bin_count, min_meas); loc_bin_cts[bin]++; } /*******************************************************************/ //PLEASE ADD THE RIGHT CODES MPI_Reduce(loc_bin_cts, bin_counts, bin_count, MPI_INT, MPI_SUM, 0, comm); /******************************************************************/} /* Find_bins *//*---------------------------------------------------------------------*/int Which_bin(float data, float bin_maxes[], int bin_count, float min_meas){ /*******************************************************************/ //PLEASE ADD THE RIGHT CODES int b = 0, e = bin_count; while (e - b &gt; 1) { int m = b + (e - b) / 2; data &lt; bin_maxes[m] ? (b = m) : (e = m); } if (b) return b; /******************************************************************/ printf(\"Uh oh . . .\\n\"); return 0;} /* Which_bin *//*---------------------------------------------------------------------*/void Set_bins( float bin_maxes[] /* out */, int loc_bin_cts[] /* out */, float min_meas /* in */, float max_meas /* in */, int bin_count /* in */, int my_rank /* in */, MPI_Comm comm /* in */){ if (my_rank == 0) { int i; float bin_width; bin_width = (max_meas - min_meas) / bin_count; for (i = 0; i &lt; bin_count; i++) { loc_bin_cts[i] = 0; bin_maxes[i] = min_meas + (i + 1) * bin_width; } } // set bin_maxes for each proc MPI_Bcast(bin_maxes, bin_count, MPI_FLOAT, 0, comm); // reset loc_bin_cts of each proc MPI_Bcast(loc_bin_cts, bin_count, MPI_INT, 0, comm);} /* Set_bins *//*---------------------------------------------------------------------*/void Gen_data( float local_data[] /* out */, int local_data_count /* in */, int data_count /* in */, float min_meas /* in */, float max_meas /* in */, int my_rank /* in */, MPI_Comm comm /* in */){ int i; float *data = NULL; if (my_rank == 0) { data = malloc(data_count * sizeof(float)); srandom(1); for (i = 0; i &lt; data_count; i++) data[i] = min_meas + (max_meas - min_meas) * random() / ((double)RAND_MAX);#ifdef DEBUG printf(\"Generated data:\\n \"); for (i = 0; i &lt; data_count; i++) printf(\"%.3f \", data[i]); printf(\"\\n\\n\");#endif MPI_Scatter(data, local_data_count, MPI_FLOAT, local_data, local_data_count, MPI_FLOAT, 0, comm); free(data); } else { MPI_Scatter(data, local_data_count, MPI_FLOAT, local_data, local_data_count, MPI_FLOAT, 0, comm); }} /* Gen_data *//*---------------------------------------------------------------------*/void Get_input(int *bin_count_p, float *min_meas_p, float *max_meas_p, int *data_count_p, int *local_data_count_p, int my_rank, int comm_sz, MPI_Comm comm){ int local_ok = 1; if (my_rank == 0) { printf(\"Enter the number of bins\\n\"); scanf(\"%d\", bin_count_p); printf(\"Enter the minimum measurement\\n\"); scanf(\"%f\", min_meas_p); printf(\"Enter the maximum measurement\\n\"); scanf(\"%f\", max_meas_p); printf(\"Enter the number of data\\n\"); scanf(\"%d\", data_count_p); } MPI_Bcast(bin_count_p, 1, MPI_INT, 0, comm); MPI_Bcast(min_meas_p, 1, MPI_INT, 0, comm); MPI_Bcast(max_meas_p, 1, MPI_INT, 0, comm); MPI_Bcast(data_count_p, 1, MPI_INT, 0, comm); if (*data_count_p % comm_sz != 0) local_ok = 0; Check_for_error(local_ok, \"Get_input\", \"data_count must be evenly divisible by comm_sz\", comm); *local_data_count_p = *data_count_p / comm_sz;} /* Get_input *//*---------------------------------------------------------------------*/void Check_for_error( int local_ok /* in */, char fname[] /* in */, char message[] /* in */, MPI_Comm comm /* in */){ int ok; MPI_Allreduce(&amp;local_ok, &amp;ok, 1, MPI_INT, MPI_MIN, comm); if (ok == 0) { int my_rank; MPI_Comm_rank(comm, &amp;my_rank); if (my_rank == 0) { fprintf(stderr, \"Proc %d &gt; In %s, %s\\n\", my_rank, fname, message); fflush(stderr); } MPI_Finalize(); exit(-1); }} /* Check_for_error */","link":"/2019/04/11/2019-03-25-Homework 2 MPI编程直方图/"},{"title":"","text":"实验题目中断处理与系统调用 实验目的 学习中断机制知识，掌握中断处理程序设计的要求 设计一个汇编程序，实现时钟中断处理程序 扩展MyOS2，增加时钟中断服务，利用时钟中断实现与时间有关的操作 实验要求 操作系统工作期间，利用时钟中断，在屏幕24行79列位置轮流显示|、/和\\，适当控制显示速度，以方便观察效果。 编写键盘中断响应程序，原有的你设计的用户程序运行时，键盘事件会做出有事反应：当键盘有按键时，屏幕适当位置显示OUCH!OUCH!。 在内核中，对33号、34号、35号和36号中断编写中断服务程序，分别在屏幕1/4区域内显示一些个性化信息。再编写一个汇编语言的程序，作为用户程序，利用int 33、int 34、int 35和int 36产生中断调用你这4个服务程序。 实验方案实验环境软件 Windows 10, 64-bit (Build 17763) 10.0.17763 Windows Subsystem for Linux [Ubuntu 18.04.2 LTS]：WSL是以软件的形式运行在Windows下的Linux子系统，是近些年微软推出来的新工具，可以在Windows系统上原生运行Linux。 gcc version 7.3.0 (Ubuntu 7.3.0-27ubuntu1~18.04)：C语言程序编译器，Ubuntu自带。 NASM version 2.13.02：汇编程序编译器，通过sudo apt install nasm安装在WSL上。 Oracle VM VirtualBox 6.0.4 r128413 (Qt5.6.2)：轻量开源的虚拟机软件。 VSCode - Insiders v1.33.0：好用的文本编辑器，有丰富的插件。 hexdump for VSCode 1.7.2: VSCode中一个好用的十六进制显示插件。 GNU Make 4.1：安装在Ubuntu下，一键编译并连接代码，生成最终的文件。 大部分开发环境安装在WSL上，较之于双系统、虚拟机等其他开发方案，更加方便，也方便直接使用Linux下的一些指令。 硬件开发环境配置所用机器型号为VAIO Z Flip 2016 Intel(R) Core(TM) i7-6567U CPU @3.30GHZ 3.31GHz 8.00GB RAM 虚拟机配置 处理器内核总数：1 RAM：4MB 实验原理本次实验的关键在于写中断向量表。x86计算机在启动时会自动进入实模式状态。系统的BIOS初始化8259A的各中断线的类型（参见前图），在内存的低位区（地址为0~1023[3FFH]，1KB）创建含256个中断向量的表IVT （每个向量[地址]占4个字节，格式为：16位段值:16位偏移值）。 要实现“无敌风火轮”，可以利用时钟中断，对8号中断进行编程。在屏幕固定位置显示风火轮的字符，随后将字符修改为下一个。随后将0x08放入0x20的位置，处理时钟中断函数的入口放入0x22。最后需要告诉硬件端口已经处理完中断，并正常返回。 在实验过程中，还遇到了进入操作系统时显示风火轮但是没有转起来的问题。经过思考，发现上一个实验中写的getch是阻塞函数。于是，重新写了这个函数，重复扫描键盘缓冲区，有字符键入时再读进来。 实验过程实验代码bootloader.asm和上一个实验中的程序完全相同，不再放出。 kernel.asm操作系统内核的汇编部分代码，提供int 33~int 36中断在屏幕的四个象限上显示自定义信息，检测到Ctrl + C时返回。 同时，提供了如下的全局函数供C语言部分调用。 _getch从屏幕上无回显地读入一个字符。 _getCursor返回屏幕光标的位置。 _setCursor设置屏幕光标的位置。 _putC向光标位置写入一个字符。 _pageUP屏幕内容向上滚动。 _loadProgram加载用户程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282%macro print 5 ; string, length, x, y, color pusha push ax push bx push cx push dx push bp push ds push es mov ax, 0b800H mov gs, ax mov ax, cs mov ds, ax mov bp, %1 mov ax, ds mov es, ax mov cx, %2 mov ax, 1300H mov dh, %3 mov dl, %4 mov bx, %5 int 10H pop es pop ds pop bp pop dx pop cx pop bx pop ax popa%endmacro%macro setIVT 2 push es push ds push si pusha mov ax, 0000H mov es, ax mov ax, %1 mov bx, 4 mul bx mov si, ax mov ax, %2 mov [es:si], ax add si, 2 mov ax, cs mov [es:si], ax popa pop si pop ds pop es%endmacro bits 16 UserPrgOffset equ 0a100H PrgSectorOffset equ 0 extern terminal global _start global _getch global _getCursor global _setCursor global _putC global _pageUP global _loadProgram_start: setIVT 8, int8 setIVT 33, int33 setIVT 34, int34 setIVT 35, int35 setIVT 36, int36 call terminal ret_getCursor: push ebp mov ebp, esp push ebx sub esp, 4 mov eax, 768 mov edx, 0 mov ebx, edx int 0x10 mov eax, edx mov dword [ebp-8], eax mov eax, dword [ebp-8] add esp, 4 pop ebx pop ebp ret_getch: mov ah, 01H int 16H jz _getch mov ah, 00H int 16H ret_setCursor: push ebp mov ebp, esp push ebx mov eax, 512 mov ecx, 0 mov edx, dword [ebp+8] mov ebx, ecx int 0x10 pop ebx pop ebp ret_putC: push ebp mov ebp, esp push ebx mov eax, dword [ebp+8] or ah, 9 mov edx, dword [ebp+12] mov ecx, 1 mov ebx, edx int 0x10 pop ebx pop ebp ret_pageUP: push ebp mov ebp, esp mov eax, dword [ebp+8] or ah, 6 mov ecx, 0 mov edx, 184fh int 0x10 pop ebp ret_loadProgram: push ebp mov ebp, esp push ax push bx push cx push dx push es mov ax, cs mov es, ax mov bx, UserPrgOffset mov ah, 2 mov al, 2 mov dl, 0 mov dh, 1 mov ch, 0 mov cl, byte [ebp+8] add cl, PrgSectorOffset int 13H call UserPrgOffset pop es pop dx pop cx pop bx pop ax mov esp, ebp pop ebp retint8: cli pusha push eax call draw_slash mov al, 20H out 20H, al out 0a0H, al pop eax popa sti iretint33: mov word[n], 12 mov word[m], 30 mov word[top], 2 mov word[left], 40 mov word[length], 8 mov word[msg], msg1 call show iretint34: mov word[n], 12 mov word[m], 30 mov word[top], 2 mov word[left], 0 mov word[length], 10 mov word[msg], msg2 call show iretint35: mov word[n], 12 mov word[m], 20 mov word[top], 13 mov word[left], 0 mov word[length], 20 mov word[msg], msg3 call show iretint36: mov word[n], 12 mov word[m], 14 mov word[top], 13 mov word[left], 40 mov word[length], 26 mov word[msg], msg4 call show iretdraw_slash: print bar,1,24,78,7 cmp byte[bar],&apos;|&apos; jne rslash mov byte[bar],&apos;/&apos; retrslash: cmp byte[bar],&apos;/&apos; jne hslash mov byte[bar],&apos;-&apos; rethslash: cmp byte[bar],&apos;-&apos; jne lslash mov byte[bar],&apos;\\&apos; retlslash: mov byte[bar],&apos;|&apos; retshow: dec dword[cnt] jnz show mov dword[cnt],99999999 mov word ax, [t] mov word bx, [n] add bx, bx sub bx, 2 xor dx, dx div bx cmp dx, [n] jb xok sub bx, dx mov dx, bxxok: add dx, [top] mov word[x], dx mov word ax, [t] mov word bx, [m] add bx,bx sub bx,2 xor dx, dx div bx cmp dx, [m] jb yok sub bx, dx mov dx, bxyok: add dx,[left] mov word [y],dx inc word[t] print [msg],[length],[x],[y],[x] mov ah, 01H int 16H jz show print msgouch,10,[x],[y],[x] mov ah, 00H int 16H cmp ax, 2e03H jne show retdatadef: cnt dd 1 t dw 0 x dw 1 y dw 0 n dw 12 m dw 32 top dw 2 left dw 40 length dw 8 msg dw 1 msg1 db &apos; wu-kan &apos; msg2 db &apos; 17341163 &apos; msg3 db &apos; wu.kan@foxmail.com &apos; msg4 db &apos; https://wu-kan.github.io &apos; msgouch db &apos;Ouch!Ouch!&apos; bar db &apos;|&apos; kerner.c操作系统内核C语言部分的代码。 和上一实验相比： 去掉了全部的内嵌汇编，改为调用外部汇编函数 修改了clear清屏的逻辑，原来是写若干个回车，现在是屏幕向上滚动一页并将光标移至首行首列 修改了显示回车的逻辑，原来是写若干个空格直至光标移动到下一行，现在直接移动光标 函数不能传字符变量的问题仍然没有解决。 undefined link.ld将wukos.asm和kernel.c两个文件编译出来的内容连接起来。和上一个实验中的完全相同，不再放出。 prg1.asm~prg4.asm直接调用int 33、int 34、int 35和int 36四个中断实现（编译出来的大小仅有3bytes）。 123org 0a100Hint 33ret 上面是prg1.asm的内容，其余同理，不再放出。 Makefile和上一个实验完全相同，不再放出。 运行结果如上图，进入操作系统后开始了“无敌风火轮”（右下角）。如上图，使用exec指令轮流运行我的四个程序，分别调用软中断int 33~int 36。按下Ctrl+C可以退出程序。程序检测到键盘输入，因此显示Ouch!Ouch! 风火轮仍然在转。输入若干指令。 风火轮仍然在转。继续输入若干指令，此时超出屏幕显示范围，自动滚屏。 风火轮仍然在转。 实验总结这次实验让我深入理解了中断服务程序的工作原理。中断响应后，先到内存指定位置找到中断向量表，然后跳转到中断服务程序。中断服务程序需先保存寄存器。中断服务程序完成后，需先还原寄存器，然后调用中断返回指令。所以在做实验的时候，就需要修改操作系统内核，使操作系统内核修改中断向量表，才能实现自定义中断服务程序。 在实验中，因为乱用宏以及没有恢复寄存器出了挺多问题，好在最终一一解决了。这也让我意识到之前的代码写的有多差、有多少隐患。因此，几乎将原先的代码完全重构了一遍。希望自己还是要多多注意一下这方面的问题。","link":"/2019/04/11/2019-03-31-中断处理与系统调用/"},{"title":"","text":"实验题目应用层实验 实验目的掌握应用层的基本工作原理和实现方法 实验工具telnet如果在命令行不能运行telnet，则需要安装telnet客户端程序。telnet的安装方法见https://jingyan.baidu.com/article/3ea51489ba79e252e61bba97.html在控制台可以采用鼠标右键菜单粘贴,拷贝要点击图标菜单“编辑/标记”控制台修改缓冲区：属性/布局/屏幕缓冲区大小/高度:9999窗口大小的宽度：200 SecureCRT SecureCRT 下载: http://172.18.187.9/netdisk/default.aspx?vm=17net (软件下载)SecureCRT下载解压后直接可以使用。 采用SecureCRT中的telnet：连接/sessions/点击右键/新建会话/协议：telnet/下一步/主机名:域名或IP地址 端口号:80或21或110或25/下一步/取名会话/完成。 SecureCRT设置中文显示：选项/会话选项/外观/字体：新宋体；字符集：中文GB2312 字符编码：utf-8 为了可以看到更多的响应信息，需要增加缓冲区大小。 secureCRT:会话选项/终端/仿真/回滚缓冲区：10000 控制台:属性/布局/屏幕缓冲区大小/高度：9000 SecureCRT的SSL配置–在SecureCRT中会话配置/连接/协议：Telnet/SSL 注意事项 截屏时注意遮盖掉自己的邮箱密码 sina.com的邮箱的客户端访问设置： QQ邮箱需要在Web访问方式下开启POP3和SMTP服务才允许在客户端访问(设置/账号/开启POP3/SMTP)，否则会出现错误“454 Authentication failed, please open smtp flag first!”要在客户端访问，QQ邮箱可能还会要求设置独立密码，即可以设置与QQ登录不同的密码。QQ Web邮箱查看源码的方法：QQ邮箱编程必须使用Telnet/SSL协议(加密模式)：SecureCRT的SSL配置–在SecureCRT中会话配置/连接/协议：Telnet/SSLQQ邮箱的接收邮件服务器：pop.qq.com，端口号为995QQ邮箱的发送邮件服务器：smtp.qq.com，端口号为465客户端登录的用户名为QQ号的base64编码客户端登录的密码也采用base64编码 实验内容先认真阅读课件“Chapter2-applicaton-layer.pdf”,再完成下面内容。注意：协议标准可以查阅RFC；选取的内容不要与课件相同；响应内容太长时自己选取截取前后部分以及其中重点部分。 参考视频：http://172.18.187.9/video/ 使用自己编写的TcpClient，采用聊天程序的客户端。该客户端采用两个进程实现：一个输入和发送线程，一个接收线程。（选做）如果不自己编写TcpClient，可以尝试使用老师给的TcpClient.exe完成步骤一~步骤四，如果不愿意尝试，可以使用telnet来完成实验。源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;process.h&gt;#include &lt;ws2tcpip.h&gt; //gcc Client.c -lWs2_32 -o Client#pragma comment(lib, \"ws2_32.lib\")#define BUFLEN 20 &lt;&lt; 20 //20MBint finish = 0;unsigned __stdcall recvMessage(SOCKET *p){ static char buf[BUFLEN]; while (!finish) { int c = recv(*p, buf, BUFLEN, 0); if (c &gt; 0) buf[c] = 0, printf(\"%s\", buf); else if (!c) printf(\"Recv connect closed.\\n\"), finish = 1; else if (c == SOCKET_ERROR) printf(\"Recv Error:\\n%d\\n\", GetLastError()); }}int main(int argc, char **argv){ if (argc &lt; 3) return 0; WSADATA wsadata; WSAStartup(MAKEWORD(2, 0), &amp;wsadata); struct addrinfo *host; getaddrinfo(argv[1], argv[2], NULL, &amp;host); SOCKET sock = socket(host-&gt;ai_family, host-&gt;ai_socktype, host-&gt;ai_protocol); if (connect(sock, host-&gt;ai_addr, host-&gt;ai_addrlen)) printf(\"Connect unsuccessfully.\\n\"); HANDLE h = _beginthreadex(NULL, 0, &amp;recvMessage, &amp;sock, 0, NULL); static char buf[BUFLEN]; while (!finish) { int len = 0; for (printf(\"Input the message(end by EOF, Ctrl+Z in Windows) :\\n\"); !finish &amp;&amp; gets(buf + len);) buf[len += strlen(buf + len)] = '\\r', buf[++len] = '\\n', buf[++len] = 0; int c = send(sock, buf, len, 0); if (!c) printf(\"Send connect closed.\\n\"), finish = 1; else if (c == SOCKET_ERROR) printf(\"Send Error:\\n%d\\n\", GetLastError()); } CloseHandle(h); closesocket(sock); freeaddrinfo(host); WSACleanup(); getch();} HTTP协议看完HTTP协议的课件后完成以下实验： 从学院网站（sdcs.sysu.edu.cn）找一网页下载。下载一个老师的个人主页。 http请求： 12GET /content/2564.html HTTP/1.1Host: sdcs.sysu.edu.cn http响应： 从学院网站（sdcs.sysu.edu.cn）找一图片下载。天河二号镇楼。http请求： 12GET /sites/sdcs.live1.dpcms8.sysu.edu.cn/files/styles/slideshow/public/slideshow/frontpic2.jpg HTTP/1.1Host: sdcs.sysu.edu.cn http响应： 在http请求的头部行中加入If-Modified-Since: Fri, 16 Jan 2019 13:22:17 GMT从学院网站下载(2)的图片。http请求： 123GET /sites/sdcs.live1.dpcms8.sysu.edu.cn/files/styles/slideshow/public/slideshow/frontpic2.jpg HTTP/1.1If-Modified-Since: Fri, 16 Jan 2019 13:22:17 GMTHost: sdcs.sysu.edu.cn http响应： 用流水线方式实现前面（1）（2），即把它们的请求拷贝到一起后发送出去（可能太长，第一部分可以只有看到末尾）。http请求： 12345GET /content/2564.html HTTP/1.1Host: sdcs.sysu.edu.cnGET /sites/sdcs.live1.dpcms8.sysu.edu.cn/files/styles/slideshow/public/slideshow/frontpic2.jpg HTTP/1.1Host: sdcs.sysu.edu.cn http响应： FTP协议看完FTP协议的课件后完成以下实验（测试服务器上的目录结构和文件见“参考资料”）：FTP服务器：IP地址为172.18.187.10，端口号为 21 （用户名：abc，密码：123666） 上传用学号命名的一个文本文件(学号.txt)控制连接的请求响应信息： 数据连接的截屏： 查看当前目录内容(太多则选择一些)，并标注出(1)中自己上传的文件控制连接的请求响应信息： 数据连接的截屏：下载(1)中自己上传的文本文件控制连接的请求响应信息： 数据连接的截屏：下载/ebook下的一个二进制文件(例如，.pdf文件)控制连接的请求响应信息： 数据连接的截屏： 采用断点续传下载一个/text下的一个文本文件的一部分控制连接的请求响应信息： 数据连接的截屏： 编写一个程序（聊天程序的客户端），用FTP协议下载指定文件（选做）参考运行截屏： 参考字符串函数：strchr();strrchr();sprintf(buf, “retr %s\\r\\n”, filename);sscanf(st, “%d,%d,%d,%d,%d,%d”, &amp;ip1, &amp;ip2, &amp;ip3, &amp;ip4, &amp;port1, &amp;port2); 参考自编函数：SOCKET dataConn() { … } 建立数据连接unsigned __stdcall myrecv(void *p){…} 接收服务器的消息（线程函数）void sendmsg(SOCKET sock, char *msg){ … } 发送控制消息int saveFile(SOCKET sock, char * fileName) { … } 通过数据连接接收数据并保存为文件参考程序：ftpDownload.exe源代码： 运行截屏： SMTP协议邮箱zsusender3@sina.com的用户名zsusender3，密码：123456Aa看完SMTP协议的课件后做以下实验： 通过zsusender3@sina.com发一封没有附件的邮件到你的邮箱。注意更改时间为当前时间。请求和响应信息：老师的邮箱因为被太多人发了邮件所以被封了… 12345678910111213141516HELO zsusender3AUTH LOGINenN1c2VuZGVyMw==MTIzNDU2QWE=MAIL FROM:&lt;zsusender3@sina.com&gt;RCPT TO:&lt;wu.kan@qq.com&gt;dataDate:Tue, 25 Mar 2019 14:24:01 +0800From: &quot;zsusender3&quot; &lt;zsusender3@sina.com&gt;To: &quot;WuK&quot;&lt;wu.kan@qq.com&gt;Subject: SDCS 17 isszymThis is a SDCS message in MIME format. Hello! SDCS 17 from isszym.QUIT 通过zsusender3@sina.com发一封带附件(二进制文件)的邮件(MIME.txt)到你的邮箱。参考课件“MIME.pdf”和观看MIME的视频。请求和响应信息： 通过zsusender3@sina.com发送另一个带附件的邮件给自己。可以先给你自己发一封带附件的邮件,再通过查看源码截取该响应报文的一部分，参见MIME.txt。(选做)从你的邮箱发一份邮件到同学的邮箱。QQ邮箱见【注意事项】。请求和响应信息： POP3协议邮箱zsureceiver3@sina.com的用户名zsureceiver3，密码：123456Aa看完POP3协议的课件后做以下实验： 查看zsureceiver3@sina.com中每个邮件大小。请求和响应信息： 取回zsureceiver3@sina.com最后一封邮件的邮件唯一标识符。请求和响应信息： 取回zsureceiver3@sina.com最后一封邮件。请求和响应信息： 取回三(1)中发到你邮箱的邮件。QQ邮件见【注意事项】。请求和响应信息： 实验体会","link":"/2019/04/11/2019-03-31-应用层实验/"},{"title":"Ubuntu MongoDB数据库的安装和使用","text":"本博文介绍了MongoDB，并详细指引读者在Ubuntu下MongoDB的安装和使用。本教程在Ubuntu14.04下测试通过。 一、MongoDB介绍MongoDB 是一个是一个基于分布式文件存储的数据库，介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 二、安装MongoDBMongoDB安装很简单，无需下载源文件，可以直接用apt-get命令进行安装。打开终端，输入以下命令： 1sudo apt-get install mongodb 1.安装完成后，在终端输入以下命令查看MongoDB版本： 1mongo -version 输出版本信息，表明安装成功，截图如下： 2.启动和关闭mongodb命令如下： 12service mongodb startservice mongodb stop 截图如下： 3.默认设置MongoDB是随Ubuntu启动自动启动的。输入以下命令查看是否启动成功： 1pgrep mongo -l #注意：-l是英文字母l，不是阿拉伯数字1 截图如下：卸载MongoDB 1sudo apt-get --purge remove mongodb mongodb-clients mongodb-server 三、使用MongoDBshell命令模式输入mongo进入shell命令模式，默认连接的数据库是test数据库，在此之前一定要确保你已经启动了MongoDB，否则会出现错误，启动之后运行成功，如下截图：常用操作命令：数据库相关 123456show dbs:显示数据库列表 show collections：显示当前数据库中的集合（类似关系数据库中的表table） show users：显示所有用户 use yourDB：切换当前数据库至yourDB db.help() ：显示数据库操作命令 db.yourCollection.help() ：显示集合操作命令，yourCollection是集合名 MongoDB没有创建数据库的命令，如果你想创建一个“School”的数据库，先运行use School命令，之后做一些操作（如：创建聚集集合db.createCollection(‘teacher’)）,这样就可以创建一个名叫“School”的数据库。截图如下： 下面以一个School数据库为例，在School数据库中创建两个集合teacher和student，并对student集合中的数据进行增删改查基本操作（集合Collection相当于关系型数据库中的表table）。1、切换到School数据库 1use School #切换到School数据库。MongoDB 无需预创建School数据库，在使用时会自动创建 2、创建Collection 1db.createCollection(&apos;teacher&apos;) #创建一个聚集集合。MongoDB 其实在插入数据的时候，也会自动创建对应的集合，无需预定义集合 截图如下：3、插入数据与数据库创建类似，插入数据时也会自动创建集合。插入数据有两种方式：insert和save。 12db.student.insert({_id:1, sname: &apos;zhangsan&apos;, sage: 20}) #_id可选db.student.save({_id:1, sname: &apos;zhangsan&apos;, sage: 22}) #_id可选 这两种方式，其插入的数据中_id字段均可不写，会自动生成一个唯一的_id来标识本条数据。而insert和save不同之处在于：在手动插入_id字段时，如果_id已经存在，insert不做操作，save做更新操作；如果不加_id字段，两者作用相同都是插入数据。截图如下： 添加的数据其结构是松散的，只要是bson格式均可，列属性均不固定，根据添加的数据为准。先定义数据再插入，就可以一次性插入多条数据，截图如下：运行完以上例子，student 已自动创建，这也说明 MongoDB 不需要预先定义 collection ，在第一次插入数据后，collection 会自动的创建。截图如下： 4、查找数据 1db.youCollection.find(criteria, filterDisplay) criteria ：查询条件，可选filterDisplay：筛选显示部分数据，如显示指定列数据，可选（当选择时，第一个参数不可省略，若查询条件为空，可用{}做占位符，如下例第三句） 12345db.student.find() #查询所有记录。相当于：select * from studentdb.student.find({sname: &apos;lisi&apos;}) #查询sname=&apos;lisi&apos;的记录。相当于： select * from student where sname=&apos;lisi&apos;db.student.find({},{sname:1, sage:1}) #查询指定列sname、sage数据。相当于：select sname,sage from student。sname:1表示返回sname列，默认_id字段也是返回的，可以添加_id:0（意为不返回_id）写成{sname: 1, sage: 1,_id:0}，就不会返回默认的_id字段了db.student.find({sname: &apos;zhangsan&apos;, sage: 22}) #and 与条件查询。相当于：select * from student where sname = &apos;zhangsan&apos; and sage = 22db.student.find({$or: [{sage: 22}, {sage: 25}]}) #or 条件查询。相当于：select * from student where sage = 22 or sage = 25 查询操作类似，这里只给出db.student.find({sname: ‘lisi’})查询的截图，如下： 5、修改数据 123456db.youCollection.update(criteria, objNew, upsert, multi ) criteria: update的查询条件，类似sql update查询内where后面的 objNew : update的对象和一些更新的操作符（如$set）等，也可以理解为sql update查询内set后面的。 upsert : 如果不存在update的记录，是否插入objNew，true为插入，默认是false，不插入。 multi: mongodb默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。默认false，只修改匹配到的第一条数据。 其中criteria和objNew是必选参数，upsert和multi可选参数 举例如下： 1db.student.update({sname: &apos;lisi&apos;}, {$set: {sage: 30}}, false, true) #相当于：update student set sage =30 where sname = &apos;lisi&apos;; 操作截图如下：6、删除数据 1db.student.remove({sname: &apos;chenliu&apos;}) #相当于：delete from student where sname=&apos;chenliu&apos; 操作截图如下： 7、退出shell命令模式输入exit或者Ctrl+C退出shell命令模式 参考MongoDB官方文档： 1https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/?_ga=2.38644067.1704633038.1522762185-1747967431.1522762185","link":"/2018/08/12/Ubuntu安装MongoDB和使用/"},{"title":"pymysql远程连接被拒绝问题解决方法","text":"pymysql远程连接被拒绝问题解决方法 pymysql.err.OperationalError: (2003, “Can’t connect to MySQL server on ‘172.16.112.136’ ([Errno 61] Connection refused)”) 一、 环境信息 123456服务器系统：Ubuntu16.04服务器MySQL版本：mysql Ver 14.14 Distrib 5.7.26, for Linux (x86_64) using EditLine wrapper本地系统：MAC本地客户端：Pycharm本地开发环境：python(3.7.3)，PyMySQL(0.9.3)假设：登录用户名为:root，密码为:mysql ，MySQL连接端口:3306 二、问题描述 python连接MySQL报错 本地客户端及代码连接均失败： 2003, &quot;Can't connect to MySQL server on ‘172.16.112.136 ’ 12345678910111213141516171819202122/usr/local/bin/python3.7 /Users/jiazhixiang/Desktop/Preparation/03-demo/demo.pyTraceback (most recent call last): File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pymysql/connections.py&quot;, line 583, in connect **kwargs) File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/socket.py&quot;, line 727, in create_connection raise err File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/socket.py&quot;, line 716, in create_connection sock.connect(sa)ConnectionRefusedError: [Errno 61] Connection refusedDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;/Users/jiazhixiang/Desktop/Preparation/03-demo/demo.py&quot;, line 9, in &lt;module&gt; conn = pymysql.connect(host=&apos;172.16.112.136&apos;, port=3306, user=&apos;root&apos;, password=&apos;mysql&apos;,database=&apos;school&apos;, charset=&apos;utf8&apos;) File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pymysql/__init__.py&quot;, line 94, in Connect return Connection(*args, **kwargs) File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pymysql/connections.py&quot;, line 325, in __init__ self.connect() File &quot;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages/pymysql/connections.py&quot;, line 630, in connect raise excpymysql.err.OperationalError: (2003, &quot;Can&apos;t connect to MySQL server on &apos;172.16.112.136&apos; ([Errno 61] Connection refused)&quot;) 如下图所示 三、官方文档描述 123&quot;The error (2003) Can&apos;t connect to MySQL server on &apos;server&apos; (10061) indicates that the network connection has been refused. You should check that there is a MySQL server running, that it has network connections enabled, and that the network port you specified is the one configured on the server.&quot;谷歌译文：“错误（2003）无法连接到&apos;服务器&apos;上的MySQL服务器（10061）表示网络连接已被拒绝。您应检查是否有MySQL服务器正在运行，是否已启用网络连接，以及您指定的网络端口是服务器上配置的网络端口。“ 四、解决过程 授权法。 需要注意mysql数据库配置文件中的bindaddress 的参数和skip-networking 配置 12bindaddress : 设定哪些ip地址被配置，使得mysql服务器只回应哪些ip地址的请求),最好注释掉该参数或设置成为127.0.0.1以外的值skip-networking : 如果设置了该参数项，将导致所有TCP/IP端口没有被监听,也就是说出了本机，其他客户端都无法用网络连接到本mysql服务器，所以应该注释掉该参数 使用ps aux|grep mysql命令查看，MySQL服务是否已启动: 使用vim my.cnf命令查看my.cnf文件(在MySQL安装目录下，我的位置是/u/etc/mysql/mysql.conf.d),修改其对应的值并重启MySQL。对应内容如下： 修改如下 123[mysqld]bind-address = 0.0.0.0 # 表示允许任何主机登陆MySQLport=3306 # 表示MySQL运行端口为3306(我的是3306，所以不用修改) 用mysql -u root -p命令，回车后输入密码mysql能正常登陆服务器MySQL 1234567mysql&gt; show global variables like &apos;port&apos;; # 查看MySQL运行的实际端口+---------------+-------| Variable_name | Value |+---------------+-------+| port | 3306 |+---------------+-------+1 row in set (0.01 sec) 123456789101112131415 mysql&gt; use mysql; Reading table information for completion of table and column names You can turn off this feature to get a quicker startup with -A Database changed mysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+------------------+4 rows in set (0.01 sec) 12# 如果上述查询结果，root用户对应的host不为%，则修改用户权限# 此处需注意的是，修改权限时要带上密码(IDENTIFIED BY &apos;mysql&apos;),没加密码之前客户端还是不能远程访问MySQL。 12345678mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;mysql&apos; WITH GRANT OPTION;Query OK, 0 rows affected, 1 warning (0.00 sec) # 表示修改成功# sql语句不区分大小写# grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;mysql&apos; with grant option;mysql&gt; FLUSH PRIVILEGES; # 刷新数据库命令必须执行！！Query OK, 0 rows affected (0.00 sec) 12345678910mysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys |+-----------+------------------+4 rows in set (0.00 sec) 重启mysql服务 123456789101112131415161718python@ubuntu:~$ sudo service mysql stop[sudo] python 的密码： python@ubuntu:~$ sudo service mysql startpython@ubuntu:~$ ps aux | grep mysqlmysql 32273 3.0 6.6 1173600 134308 ? Ssl 13:09 0:00 /usr/sbin/mysqldpython 32316 0.0 0.0 15984 936 pts/1 S+ 13:09 0:00 grep --color=auto mysqlpython@ubuntu:~$ sudo service mysql status● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since 五 2019-05-24 13:09:32 CST; 1min 9s ago Process: 32274 ExecStartPost=/usr/share/mysql/mysql-systemd-start post (code=exited, status=0/SUCCESS) Process: 32266 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exited, status=0/SUCCESS) Main PID: 32273 (mysqld) CGroup: /system.slice/mysql.service └─32273 /usr/sbin/mysqld5月 24 13:09:30 ubuntu systemd[1]: Starting MySQL Community Server...5月 24 13:09:32 ubuntu systemd[1]: Started MySQL Community Server. 启动代码，问题已经解决 另一种方式：改表法 五、改表法。 可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%” 12345678登录数据库：mysql -u root -pmysqlmysql&gt;use mysql;mysql&gt;update user set host = &apos;%&apos; where user = &apos;root&apos;;mysql&gt;select host, user from user;mysql&gt;FLUSH PRIVILEGES; 删除用户 删除数据库中的其他用户 方法一 delete from user where user='root' and host='localhost'; 123456789101112131415161718192021222324252627282930mysql&gt;use mysqlDatabase changedmysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+------------------+5 rows in set (0.00 sec)mysql&gt;delete from user where user=&apos;root&apos; and host=&apos;localhost&apos;;Query OK, 1 row affected (0.01 sec)mysql&gt;select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys |+-----------+------------------+4 rows in set (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.02 sec) 方法二 1drop user root@&apos;localhost&apos;; 删除用户的数据库1drop database school; 修改指定用户密码12345mysql -u root -p # 进入数据库update mysql.user set password=password(&apos;新密码&apos;) where User=&quot;phplamp&quot; and Host=&quot;localhost&quot;;flush privileges;","link":"/2019/07/23/pymysql远程连接被拒绝问题解决方法/"},{"title":"函数程序设计实验十：车牌竞价信息处理","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354{-文件bids_201711.txt 是广州市某月车牌竞价信息，包含若干行，每行形如“1234198004118085 29570”，表示一位竞价人的身份证号和出价。假设本月有10个车牌竞拍。你的任务是统计相关信息，包括最高成交价、最低成交价、平均成交价、按照出价从高到低列车前十位出价人身份证号和出价，并存入另一个文件bidResults.txt中。例如，统计结果可能如文件bidResults1.txt 所示。要求：1. 提交你的代码文件；2. 提交统计结果文件，或者将结果粘贴在提交窗口。提示：需要排序函数，请hoogle :: [a] -&gt; [a]，或者自定义排序。-}--代码写的太丑了，以后重写吧……import Data.Charimport System.IOimport Text.Printfmain::IO()main= do txt&lt;-readFile \"bids_201711.txt\" let dat=lines txt let mi=getmin dat let ma=getmax dat let sum=getsum dat let len=length dat let aftersort=getsort dat writeFile \"bidResults.txt\" (printf \"最高成交价：%d\\n最低成交价：%d\\n平均成交价：%d\\n总共有%d参与竞价成交名单：\\n%s\" ma mi (div sum len) len (unlines (take 10 aftersort)))digit::String-&gt;Int-&gt;Intdigit s n=(ord (s!!n))-(ord '0')getval::String-&gt;Intgetval s=(digit s 23)*10000+(digit s 24)*1000+(digit s 25)*100+(digit s 26)*10+(digit s 27)getmin::[String]-&gt;Intgetmin [a]=getval agetmin (x:xs)=if a&lt;b then a else b where a=getmin [x] b=getmin xsgetmax::[String]-&gt;Intgetmax [a]=getval agetmax (x:xs)=if a&gt;b then a else b where a=getmax [x] b=getmax xsgetsum::[String]-&gt;Intgetsum [a]=getval agetsum (x:xs)=(getmax [x])+(getmax xs)getsort::[String]-&gt;[String]getsort []=[]getsort (x:xs)=(getsort [y|y&lt;-xs,(getval y)&gt;(getval x)])++[x]++(getsort [y|y&lt;-xs,(getval y)&lt;(getval x)]) 下面是bidResults.txt的内容。 1234567891011121314最高成交价：29995最低成交价：10008平均成交价：111总共有491参与竞价成交名单：1234198610248103 299951535198004062143 299481334197907229015 299221435198110019109 299161535198412072052 298221533198811246245 298201633197706227256 298151234198205229019 297991533198710186071 297771536198405206083 29727 下面是bids_201711.txt的内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904911230197812061080 245961230197210049047 112931331197708184092 263871331198509014173 219911331198702174176 137781333197808181338 296861333197812025146 279551333198709276233 124951334197907229015 299221334197205049158 104161430198708181002 251861430197102201027 240901430197912121030 193671431198402182064 116821431197303143010 206601431197711224092 131961431197512184190 120691432197703132181 284241433197902071057 119851433198810041098 187541433198111221148 259941433197311121198 250651433197711041206 211151433197412131354 131461434199006226012 173991434198808016016 254301434198112246017 260061434197106257001 121931434199012017087 226981434198612107099 277051434197910097116 209441434198205257149 234451434197105058037 145071434197511068057 239531434197410198061 159661434199001168083 214561434197712158085 254481434198912018117 204201434198807048125 254691435198609050022 124471435198409016106 231011435198110019109 299161436198306186113 108061436197501287048 139041530198810111127 160781530199002261200 159931530198304086034 266301530198411268038 141591530197408019037 217501530199002079054 100571531198401270053 247361531198101252040 265141531198110182065 124181531197704223007 131751531198708234191 252751532198206021061 123521532197309044084 211311532198206094108 200761533198402091046 163921533197405231092 255071533197510141097 134821533199006061403 223901533197905261404 220591533198303111443 259061533198508036001 180091533197512086002 276271533197906156007 258811533197504206011 138981533198007276012 270951533198004256027 277611533197606026083 187851533197702066114 186181533197910176205 126491533198811246245 298201534198403103001 257021534198403183043 180331534197007193054 282381534199004133073 220041534198701103076 268111534198606093104 121591534199008033108 192851534197412013119 213021534198610178012 112101534198406018015 222461534198507278026 195471534198702279031 226791534198002219036 295971534198605189050 117961534198007209121 196541535198702061054 253421535198212101059 228191535197503131117 193771535198803255119 229371535197608028311 157101535197501128369 245911536197405270013 155261536198402134004 183261536197312034015 217551536197901275016 291581536198405206083 297271234199004029001 146201234198002169002 128311234198611199003 132831234198012199004 124021234198706219005 248861234197812129006 232301234197701239007 196111234197906209008 138971234197304129009 102311234197003259010 246071234198701079011 295181234198405169012 214161234198610119013 247901234198907069014 131581234198405109015 222601234198106179016 248181234198107099017 249401234197708199018 169611234198708199019 159291234198201239020 184821234198207069021 134671234197312119022 220461234198912069023 293571234198311129024 138161234198811099025 224641234197104079026 103511234197512268070 269061234197504178071 185041234197301168073 256731234198605098074 165611234198509118075 239561234197511198076 158311234198302028077 265721234198708238078 236111234197312088079 280831234197406148080 142681234197703048081 117231234198001208082 205411234198510168083 205431234197608078084 225971234199001118085 256431234198203158086 168791234197110178087 258501234199003188088 276791234197405268089 109671234197311178090 106461234198204058091 240141234198603198092 138001234199012078093 268131234197006098094 111381234197108058095 242781234198505268096 232811234197809078097 179681234198012038098 222951234198508078099 167721234197907098100 200251234197707098101 113141234198808118102 276581234198610248103 299951234197409128104 272861234197303158105 206181234198311088106 271551234198701048107 286561234198304078108 134941234198401198109 109781234197611088110 217601234198602148111 115631234198311048112 225741234197701268113 127251234198802128114 260761234197303028115 264011234197509058116 283881234198410288117 275581234199007158118 166831234197510248119 155521234197208068120 132561234197201068121 209771234197712098122 134041234197912258123 213811234197307058124 271651234197811128125 252321234197003078126 234241234197907048127 218591234197807218128 268431234197303148130 165501234198609288131 180641234198501128132 232141234197005068133 145211234197508028134 128301234198402278135 119771234197504218136 289621234197709228137 133771234198107108138 262201230197405203218 266981233197007050058 249421233198104060178 210901233198811040364 274341233197412030414 113191236198803025088 126971234197906138139 286171234198102238140 201041234198709218141 142661234198503118142 254581234198207178143 128791234197612018144 250471234197702038145 124431234197107148146 265261234198710258147 278441234198103128148 219731234197207278149 296731234197310038150 257351234197512218151 224711234197211258152 117521234199004238153 286431234198009078154 271581234198911248155 103111234198611138156 166541234197808048157 244941234197510278158 215391234197506208159 137431234197309158160 128021234198505258161 121261234198302098162 106941234197710248163 129441234198610148164 120651234197005198165 100081234197404238166 106341234198007278167 214251234197001168168 228611234197303168169 274181234197307178170 223621234197905168171 199471234197903208172 116901234198106068173 112651234198904278174 103891234198903268175 265151234197304078176 171381234197402198177 188441234197207068178 206391234198205098179 163271234198902268180 275631234198102138181 101791131198902092008 279361131197304108030 284461233198109040089 174611233198508200203 100121235197601273174 127511235198209173224 232751235198609203285 220811236197907235026 168041234198801289001 277861234199006189002 190191234197205039003 286721234198810089004 154171234197703039005 243181234197409279006 199741234199002139007 279191234197506069008 117591234197205049009 167361234198002269010 178381234198402049011 130501234199006149012 285971234198503069013 223841234199004229014 106731234198903089015 112291234198711169016 235581234197910059017 165951234198402219018 178321234198205229019 297991234197411019020 259891234198410169021 186881234197905169022 180171234198507059023 115641234198002149024 187231234198303269025 145151234199005239026 145591330198201289011 207171331198702114240 231121332198107013008 112281431198511154103 248901432198409062084 220221432197202204037 132561433198009085060 236351433198709255216 143481434197611098044 123961434197504148184 215701435197411122073 119901435198202033142 110091435198406073430 273991530197111248009 104331530199005108029 248671530197411288030 261991530198312158054 241541531198209102002 141231531197802104121 187701531197002204204 234001533198607241042 139041533197706121311 139041533198407216057 291641533197507106058 205371533198710186071 297771533198307256264 271221533199004286269 195161534197908203047 151041534199009228014 193711534198602109107 122431534197608149108 104781535198607190037 129041535198704112045 252961535197511282065 226321535197707192081 125371535197602022083 110641535198407222087 158851535198002172088 281721535198802082089 240581535198909192091 121711535199012282144 227351535199008232161 254741535198603242229 244081535198503042296 261621535197811082354 267631535198609192434 176751535198808143011 282011536198105154006 276901630197409082111 240521630198811038030 257831630198205108032 272121630198603098044 264891630199008068110 281121630197410128114 190991630198607238144 221381630199006139005 146121631198907150001 195961631197601170011 182181631198401250022 159891631199003230055 178741631198711140072 247811631198203040077 287171631197809172009 162021631198708074019 118211631197202127017 141731631199008057090 202101631198001288124 190471631197802238243 120791631198709038263 209991631198508158280 269141632198506218013 241261632198707018035 109311633198412267019 263851633198611277075 191481633198101057101 258441633197504057210 127731633197307177216 112461633197202067229 175801633197706227256 298151633198908247269 193641633197607047270 279941633197310259025 179671633198004039028 168541633198805169035 166061633198707129053 166451634197601010006 178061634197906140030 276741634198202280069 189671634197202120078 180591634197606150098 195781634197501180121 239821634197501210147 287221634198406230150 161011634197304190152 152671634198707190170 128561634197409120218 151951635197407271010 278691636198202023012 292851636198112105041 150661636198811265174 191741535198109102012 154111535199008052069 259311535197407192001 165981535198509162002 160511535198009242004 109391535199003172005 115521535197510072006 142081535197405222007 169811535198412282008 234461535197511042009 143071535198404182010 118771535197812232011 148991535198403162013 260551535197012092014 158001535197612022015 160391535197104142016 196421535198905182017 132931535197610112018 254281535197502022019 271111535198904032020 252131535198111102021 289991535198310102022 139161535198112272023 172171535197208162047 116131535198406272048 134501535197312272049 217791535197902132050 106351535197106262051 181081535198412072052 298221535197408102053 236181535198402212054 186871535199012262055 288321535197408082056 115691535198206132057 254211535198604132058 226431535198904032059 292291535198101022060 263791535197002222061 143901535197902082062 222431535198903102063 227341535198808062064 188471535197203162065 162161535198507172066 171101535197509042067 180211535198612162068 247461535198203182093 182661535198010192094 161641535197607212095 150461535198404092096 255561535198108172097 184031535198308012098 129401535197510222099 295601535197512162100 176831535198805042101 121121535198807282102 233891535198310102103 116221535198407272104 110651535197507192105 156751535198503152106 157691535198307062107 206251535198106262108 296491535197903262109 286891535198204132110 136391535198808202111 276141535197603152112 181661535198612242113 123611535197010172114 170721535198802232115 153971535198301082139 132141535198202242140 187281535199002222141 160271535197208212142 287021535198004062143 299481535197005102144 164071535197301202145 185381535198407192146 115671535198012082147 237551535198007192148 194941535197812202149 142651535198803082150 222511535197904252151 205121535197709052152 216231535197106102153 148121535198906052154 208071535198702182155 127711535198606092156 226961535198905172157 255931535197807262158 277201535197911262159 240901535197204142160 133281535198004112161 142771535197106272186 279981535197306042188 124921535198512242189 152351535198308152190 206901535198106072191 191631535198903072192 168721535198811022193 157601535198301262194 155361535198801212195 125841535198908052197 135971535198901142198 294181535199004132199 166501535197411172200 293931535198309082201 231861535197508192202 100211535198911232203 157741535197808032204 176271535197812152205 286731535197204162206 279911535198808112207 181161535197411142208 290561535197409232003 146561535197012152187 117781535198107162196 17291","link":"/2018/11/26/2018-11-26-车牌竞价信息处理/"},{"title":"数学分析","text":"数学分析增长趋势$n\\to+\\infty,\\forall p,q&gt;0,a&gt;1,{(\\ln n)}^q\\ll n^p\\ll a^n\\ll n!\\ll n^n$ 积分表反读可得导数表，此处略。$\\int k,\\mathrm{d}x=kx+C$$\\int x^a,dx=\\frac{x^{a+1} }{a+1}+C$$\\int\\frac{1}{x},dx=\\ln|x|+C$$\\int e^x,dx=e^x + C$$\\int a^x,dx=\\frac{a^x}{\\ln a}+C$$\\int\\cos x,dx=\\sin x+C$$\\int\\sin x,dx=-\\cos x+C$$\\int\\frac{1}{cos^2x},dx=\\int\\sec^2 x,dx=\\tan x+C$$\\int\\frac{1}{sin^2x},dx=\\int\\csc^2 x,dx=-\\cot x+C$$\\int\\frac{1}{\\sqrt{1-x^2} },dx=\\arcsin x+C=-\\arccos x + C$$\\int\\frac{1}{1+x^2},dx=\\arctan x+C=-arccot,x+C$$\\int\\sec x\\tan x,dx=\\sec x+C$$\\int\\csc x\\cot x,dx=-\\csc x+C$$\\int\\tan x,dx=-\\ln|\\cos x|+C$$\\int\\cot x,dx=\\ln|\\sin x|+C$$\\int\\sec x,dx=\\ln|\\sec x+\\tan x|+C$$\\int\\csc x,dx=\\ln|\\csc x-\\cot x|+C$$\\int sh,x,dx=ch,x+C$$\\int ch,x,dx=sh,x+C$$\\int\\frac{1}{x^2+a^2},dx=\\frac{1}{a}\\arctan\\frac{x}{a}+C$$\\int\\frac{1}{x^2-a^2},dx=\\frac{1}{2a}\\ln|\\frac{x-a}{x+a}| + C$$\\int\\frac{1}{\\sqrt{a^2-x^2} },dx=\\arcsin\\frac{x}{a}+C$$\\int\\frac{1}{\\sqrt{x^2-a^2} },dx=\\ln|x+\\sqrt{x^2-a^2}|+C$$\\int\\frac{1}{\\sqrt{x^2+a^2} },dx=\\ln|x+\\sqrt{x^2+a^2}|+C$ 积分求几何量面积若简单闭曲线$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$端点处连续（$x(\\alpha)=x(\\beta),y(\\alpha)=y(\\beta)$）且其他地方不自交，$x(t),y(t)$都逐段有连续微商，则此闭合曲线围起来的有界区域面积$S=-\\int_\\alpha^\\beta x’(t)y(t),dt=-\\int_\\alpha^\\beta y(t),dx(t)=-\\oint_\\Gamma y,dx=\\oint_\\Gamma x,dy$等式右边称为曲线$\\Gamma$上的积分，其计算方法是带入参数方程到定积分计算式中，积分上下限为始点与终点对应的参数值。下限并不总是小于上限，参数从下限到上限变化时对应曲线的正向（沿正向观察时，曲线所围的区域永远在左侧）。极坐标下，连续非负曲线$r=r(\\theta)$与向径$\\theta=\\alpha,\\theta=\\beta$，其中$0\\leq\\beta-\\alpha\\leq2\\pi$所围成的平面图形面积$S=\\frac{1}{2}\\int_\\alpha^\\beta r^2(\\theta),d\\theta$ 体积记立体过x点且垂直于x轴的截面面积为$S(x)$，则其体积$V=\\int_a^bS(x),dx$连续曲线$y=f(x)\\ge 0,x\\in[a,b]$绕x轴旋转一周产生的旋转体体积$V=\\pi\\int_a^by^2,dx$ 弧长若简单闭曲线$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$端点处重合（$x(\\alpha)=x(\\beta),y(\\alpha)=y(\\beta)$）且其他地方不自交，$x(t),y(t)$连续且满足$[x’(t)]^2+[y’(t)]^2\\ne0,\\forall t\\in[\\alpha,\\beta]$此时称曲线光滑，其长度$s=\\int_\\alpha^\\beta\\sqrt{[x’(t)]^2+[y’(t)]^2},dt$此式可对称推广到高维空间曲线。极坐标下，$r=r(\\theta),\\theta\\in[\\alpha,\\beta]$的长度为$s=\\int_\\alpha^\\beta\\sqrt{[r(\\theta)]^2+[r’(\\theta)]^2},d\\theta$ 曲率若曲线由参数方程$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$给出且有二阶微商，则其在一点的曲率$K=\\frac{|y’’x’-y’x’’|}{[x’^2+y’^2]^{\\frac{3}{2} } }$若$y=f(x)$，则$K=\\frac{|y’’|}{(1+y’^2)^\\frac{3}{2} }$同时记$\\frac{1}{K}$为曲率半径。 旋转体侧面积若曲线由参数方程$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$给出，则其绕x轴旋转体的侧面积$s=2\\pi\\int_\\alpha^\\beta y(t)\\sqrt{[x’(t)]^2+[y’(t)]^2},dt$ 空间曲线的切线与法平面若已知曲线上一点$P(x_0,y_0,z_0)$处的切向量为$\\tau(x_0,y_0,z_0)=(A,B,C)$则曲线在该点的切线方程为$\\frac{x-x_0}A=\\frac{y-y_0}B=\\frac{z-z_0}C$法平面方程为$A(x-x_0)+B(y-y_0)+C(z-z_0)=0$当曲线由参数方程$\\begin{cases}x=x(t),\\y=y(t),\\z=z(t),\\end{cases}t\\in[\\alpha,\\beta]$给出时，曲线在P点的切向量为$\\tau=\\pm(x’(t_0),y’(t_0),z’(t_0))$更一般地，若曲线用两曲面的交线给出$\\begin{cases}F(x,y,z)=0,\\G(x,y,z)=0,\\end{cases}$且在P点的某邻域能确定函数组$y=y(x),z=z(x)$满足$y_0=y(x_0),z_0=z(x_0)$，且$y’(x),z’(x)$存在，则曲线在P点的切向量$\\tau=\\pm(\\frac{\\partial(F,G)}{\\partial(y,z)},\\frac{\\partial(F,G)}{\\partial(z,x)},\\frac{\\partial(F,G)}{\\partial(x,y)})$ 空间曲面的切平面与法线若已知曲面上一点$P(x_0,y_0,z_0)$处的切平面的法向量为$\\vec n=(A’,B’,C’)$则曲线在该点的法线方程为$\\frac{x-x_0}{A’}=\\frac{y-y_0}{B’}=\\frac{z-z_0}{C’}$切平面方程为$A’(x-x_0)+B’(y-y_0)+C’(z-z_0)=0$当曲面方程为$\\pi:F(x,y,z)=0$在曲面上任取一条过P的曲线，设其方程为$\\begin{cases}x=x(t),\\y=y(t),\\z=z(t),\\end{cases}t\\in[\\alpha,\\beta]$此时有$F(x(t),y(t),z(t))=0$令$t=t_0$两边对t求导，并写成向量的内积式，得$(F_x,F_y,F_z)_P\\cdot(x’(t_0),y’(t_0),z’(t_0))=0$则曲线在P点的法向量为$\\vec{n}=\\pm(F_x,F_y,F_z)_P$若曲线由参数方程给出$\\begin{cases}x=x(u,v),\\y=y(u,v),\\z=z(u,v),\\end{cases}$则曲线在P点的法向量$\\vec{n}=\\pm(\\frac{\\partial(y,z)}{\\partial(u,v)},\\frac{\\partial(z,x)}{\\partial(u,v)},\\frac{\\partial(x,y)}{\\partial(u,v)})$ 方向导数设三元函数$u=f(x,y,z)$在点$P_0(x_0,y_0,z_0)$的某邻域内有定义，任意给定始于点$P_0$的射线$l$，$P(x,y,z)$为l上且含于定义域内的点。若极限$\\lim_{r(p,p_0)\\to0^+}\\frac{f(P)-f(P_0)}{r(P,P_0)}=\\lim_{r(p,p_0)\\to0^+}\\frac{\\Delta_lf(P_0)}{r(P,P_0)}$存在，则称该极限值为函数$f$在点$P_0$沿方向$l$的方向导数，记为$\\frac{\\partial f}{\\partial l}|{P_0}$或$\\frac{\\partial f(P_0)}{\\partial l}$，$\\frac{\\Delta_lf(P_0)}{r(P,P_0)}$称为函数在$P_0$点沿$l$方向的增量。特别地，$\\frac{\\partial f(P_0)}{\\partial x}$就是函数在$P_0$点沿$x$轴正向的方向导数，$y,z$轴上的方向导数同理。若函数在$P_0$点可微，则其在$P_0$沿任何方向$l$的方向导数都存在，则有以下公式$\\frac{\\partial f(P_0)}{\\partial l}=(\\frac{\\partial f}{\\partial x},\\frac{\\partial f}{\\partial y},\\frac{\\partial f}{\\partial z})|{P_0}\\cdot\\vec{l_0}$其中$\\vec{l_0}=(\\cos\\alpha,\\cos\\beta,cos\\gamma)=\\frac{1}{\\rho}(\\Delta x,\\Delta y,\\Delta z)$为$l$的方向余弦。 泰勒公式用$f^{(n)}(x)$表示f(x)的n阶导数。只要让余项&lt;EPS即可计算指定函数到任意精确度。特别取a=0时称为麦克劳林公式。$f(x)=f(a)+f^{(1)}(a)(x-a)+\\frac{f^{(2)}(a)}{2!}(x-a)^2+\\ldots+\\frac{f^{(n)}(a)}{n!}(x-a)^n+R_n(x)$$R_n(x)=o((x-a)^n)$，佩亚诺余项$R_n(x)=\\frac{1}{n!}\\int_a^x(x-t)^nf^{(n+1)}(t),dt$，积分余项$R_n(x)=\\frac{f^{(n+1)}(\\xi)}{(n+1)!}(x-a)^{n+1},a&lt;\\xi&lt;x$，拉格朗日余项$R_n(x)=\\frac{(x-a)^{n+1} }{n!}(1-\\theta)^nf^{(n+1)}(a+\\theta(x-a)),0&lt;\\theta&lt;1$，柯西余项 指数函数$(e^x)^{(n)}=e^x$$e^x=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\ldots+\\frac{x^n}{n!}+R_n(x)$$R_n(x)=\\frac{e^{\\theta x} }{(n+1)!}x^{n+1},\\xi=\\theta x,0&lt;\\theta&lt;1$ 三角函数$(\\sin x)^{(n)}=\\sin(x+\\frac{n\\pi}{2})$$\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\ldots+(-1)^{k-1}\\frac{x^{2k-1} }{(2k-1)!}+R_{2k}(x)$$R_{2k}(x)=(-1)^k\\frac{\\cos\\theta x}{(2k+1)!}x^{2k+1}$$(\\cos x)^{(n)}=\\cos(x+\\frac{n\\pi}{2})$$\\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\ldots+(-1)^{k-1}\\frac{x^{2k-2} }{(2k-2)!}+R_{2k-1}(x)$$R_{2k-1}(x)=(-1)^k\\frac{\\cos\\theta x}{(2k)!}x^{2k}$ 对数函数$[\\ln(1+x)]^{(n)}=(-1)^{n-1}(n-1)!(1+x)^{-n}$$\\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+\\ldots+(-1)^{n-1}\\frac{x^n}{n}+R_n(x)$ 幂函数$[(1+x)^a]^{(n)}=a(a-1)\\ldots(a-n+1)(1+x)^{a-n}$$(1+x)^a=1+ax+\\frac{a(a-1)}{2!}x^2+\\dots+\\frac{a(a-1)\\ldots(a-n+1)}{n!}x^n+R_n(x)$ 二元函数设$f(x,y)$在$P_0(x_0,y_0)$的某邻域$O(P_0)$内有直到$n+1$阶连续偏导数，则对$O(P_0)$内$\\forall(x_0+\\Delta x,y_0+\\Delta y),\\exists\\theta\\in(0,1)$，使得$f(x_0+\\Delta x,y_0+\\Delta y)=\\sum_{k=0}^n\\frac{1}{k!}(\\frac{\\partial}{\\partial x}\\Delta x+\\frac{\\partial}{\\partial y}\\Delta y)^kf(x_0,y_0)+R_n$其中$R_n=\\frac{1}{(n+1)!}(\\frac{\\partial}{\\partial x}\\Delta x+\\frac{\\partial}{\\partial y}\\Delta y)^{n+1}f(x_0+\\theta\\Delta x,y_0+\\theta\\Delta y)$ 级数部分和调和级数$n\\to\\infty,\\sum_{i=1}^n\\frac 1 i\\to\\ln n+r,r\\approx0.5772156649015328\\ldots$ 幂级数快速计算幂级数的部分和$\\sum_{i=1}^ni^k\\mod M$可借助伯努利数，详见模板·组合数学。$\\sum_{i=1}^ni^1=\\frac 1 2n(n+1)$$\\sum_{i=1}^ni^2=\\frac 1 6n(n+1)(2n+1)$$\\sum_{i=1}^ni^3=\\frac 1 4[n(n+1)]^2$$\\sum_{i=1}^ni^4=\\frac 1{30}n(n+1)(2n+1)(3n^2+3n-1)$$\\sum_{i=1}^ni^5=\\frac 1{12}[n(n+1)]^2(2n^2+2n-1)$$\\sum_{i=1}^ni^6=\\frac 1{42}n(n+1)(2n+1)(3n^4+6n^3-3n+1)$ 二分求零点、三分求极值点需要$f(x)$在区间$[l,r]$上单调/凹凸性唯一。 123456789101112double bs(double l,double r,double f(double x)){ if(r-l&lt;EPS)return l; double m=(l+r)/2; return sgn(f(l)*f(m))&lt;0?bs(l,m,f):ts(m,r,f);}double ts(double l,double r,double f(double x)){ if(r-l&lt;EPS)return l; double d=(r-l)/3,lm=l+d,rm=r-d; return f(lm)&lt;f(rm)?ts(l,rm,f):ts(lm,r,f);//极小值} 自适应辛普森求函数积分123456789101112struct Simpson{ lf simpson(lf a,lf b,lf f(lf x)) { return (f(a)+4*f((a+b)/2)+f(b))*(b-a)/6; } lf ask(lf a,lf b,lf f(lf x),lf e=EPS) { lf c=(a+b)/2,L=simpson(a,c,f),R=simpson(c,b,f),A=simpson(a,b,f); return fabs(L+R-A)&lt;EPS*15?L+R+(L+R-A)/15:ask(a,c,f,e/2)+ask(c,b,f,e/2); }}; 插值法拉格朗日插值法：插值多项式和插值基函数的形式对称，容易编程。但是，增加节点时，需要重新计算每一个插值基函数。要在$\\pmod p$意义下进行的话，那么p只能是质数。牛顿插值法：当插值节点增加时，之前已计算的结果仍然能用，每增加一个节点，只要再增加一项即可，从而避免了重复性计算。如果要mod非质数的话，那么就要用牛顿插值法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152typedef complex&lt;double&gt; Coord;#define X real()#define Y imag()double lagrange(const vector&lt;Coord&gt; &amp;p,double x)//返回p确定的多项式函数在x处的值{ double ret=0; for(int i=0; i&lt;p.size(); ++i) { double tmp=p[i].Y; for(int j=0; j&lt;p.size(); ++j) if(i!=j)tmp*=(x-p[j].X)/(p[i].X-p[j].X); ret+=tmp; } return ret;}vector&lt;double&gt; lagrange(vector&lt;Coord&gt; p)//返回p确定的多项式系数向量{ vector&lt;double&gt; ret(p.size()),sum(p.size()); ret[0]=p[0].Y,sum[0]=1; for(int i=1; i&lt;p.size(); ++i) { for(int j=p.size()-1; j&gt;=i; --j) p[j].Y=(p[j].Y-p[j-1].Y)/(p[j].X-p[j-i].X); for(int j=i; ~j; --j) sum[j]=(j?sum[j-1]:0)-sum[j]*p[i-1].X, ret[j]+=sum[j]*p[i].Y; } return ret;}double differenceQuotient(const vector&lt;Coord&gt; &amp;p,int k)//计算差商{ double ret=0; for(int i=0; i&lt;=k; ++i) { double tmp=p[i].Y; for(int j=0; j&lt;=k; ++j) if(i!=j)tmp/=p[i].X-p[j].X; ret+=tmp; } return ret;}double newton(const vector&lt;Coord&gt; &amp;p,double x){ double ret=p[0].Y; for(int i=1; i&lt;p.size(); ++i) { double tmp=differenceQuotient(p,i);//多次求，可O(n^3)预处理优化 for(int j=0; j&lt;i; ++j)tmp*=x-p[j].X; ret+=tmp; } return ret;} 转载 以下转载自斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 导数定义导数和微分的概念 $f’({ {x}{0} })=\\underset{\\Delta x\\to 0}{\\mathop{\\lim } },\\frac{f({ {x}{0} }+\\Delta x)-f({ {x}_{0} })}{\\Delta x}$ （1） 或者： $f’({ {x}{0} })=\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{f(x)-f({ {x}{0} })}{x-{ {x}{0} } }$ （2） 左右导数导数的几何意义和物理意义函数$f(x)$在$x_0$处的左、右导数分别定义为： 左导数：${ { {f}’}{-} }({ {x}{0} })=\\underset{\\Delta x\\to { {0}^{-} } }{\\mathop{\\lim } },\\frac{f({ {x}{0} }+\\Delta x)-f({ {x}{0} })}{\\Delta x}=\\underset{x\\to x_{0}^{-} }{\\mathop{\\lim } },\\frac{f(x)-f({ {x}{0} })}{x-{ {x}{0} } },(x={ {x}_{0} }+\\Delta x)$ 右导数：${ { {f}’}{+} }({ {x}{0} })=\\underset{\\Delta x\\to { {0}^{+} } }{\\mathop{\\lim } },\\frac{f({ {x}{0} }+\\Delta x)-f({ {x}{0} })}{\\Delta x}=\\underset{x\\to x_{0}^{+} }{\\mathop{\\lim } },\\frac{f(x)-f({ {x}{0} })}{x-{ {x}{0} } }$ 函数的可导性与连续性之间的关系Th1函数$f(x)$在$x_0$处可微$\\Leftrightarrow f(x)$在$x_0$处可导 Th2若函数在点$x_0$处可导，则$y=f(x)$在点$x_0$处连续，反之则不成立。即函数连续不一定可导。 Th3${f}’({ {x}{0} })$存在$\\Leftrightarrow { { {f}’}{-} }({ {x}{0} })={ { {f}’}{+} }({ {x}_{0} })$ 平面曲线的切线和法线切线方程 : $y-{ {y}{0} }=f’({ {x}{0} })(x-{ {x}{0} })$法线方程：$y-{ {y}{0} }=-\\frac{1}{f’({ {x}{0} })}(x-{ {x}{0} }),f’({ {x}_{0} })\\ne 0$ 四则运算法则设函数$u=u(x)，v=v(x)$]在点$x$可导则(1) $(u\\pm v{)}’={u}’\\pm {v}’$ $d(u\\pm v)=du\\pm dv$(2)$(uv{)}’=u{v}’+v{u}’$ $d(uv)=udv+vdu$(3) $(\\frac{u}{v}{)}’=\\frac{v{u}’-u{v}’}{ { {v}^{2} } }(v\\ne 0)$ $d(\\frac{u}{v})=\\frac{vdu-udv}{ { {v}^{2} } }$ 基本导数与微分表(1) $y=c$（常数） ${y}’=0$ $dy=0$(2) $y={ {x}^{\\alpha } }$($\\alpha $为实数) ${y}’=\\alpha { {x}^{\\alpha -1} }$ $dy=\\alpha { {x}^{\\alpha -1} }dx$(3) $y={ {a}^{x} }$ ${y}’={ {a}^{x} }\\ln a$ $dy={ {a}^{x} }\\ln adx$ 特例: $({ { {e} }^{x} }{)}’={ { {e} }^{x} }$ $d({ { {e} }^{x} })={ { {e} }^{x} }dx$ (4) ${y}’=\\frac{1}{x\\ln a}$ $dy=\\frac{1}{x\\ln a}dx$ 特例:$y=\\ln x$ $(\\ln x{)}’=\\frac{1}{x}$ $d(\\ln x)=\\frac{1}{x}dx$ (5) $y=\\sin x$ ${y}’=\\cos x$ $d(\\sin x)=\\cos xdx$ (6) $y=\\cos x$ ${y}’=-\\sin x$ $d(\\cos x)=-\\sin xdx$ (7) $y=\\tan x$ ${y}’=\\frac{1}{ { {\\cos }^{2} }x}={ {\\sec }^{2} }x$ $d(\\tan x)={ {\\sec }^{2} }xdx$(8) $y=\\cot x$ ${y}’=-\\frac{1}{ { {\\sin }^{2} }x}=-{ {\\csc }^{2} }x$ $d(\\cot x)=-{ {\\csc }^{2} }xdx$(9) $y=\\sec x$ ${y}’=\\sec x\\tan x$ $d(\\sec x)=\\sec x\\tan xdx$(10) $y=\\csc x$ ${y}’=-\\csc x\\cot x$ $d(\\csc x)=-\\csc x\\cot xdx$(11) $y=\\arcsin x$ ${y}’=\\frac{1}{\\sqrt{1-{ {x}^{2} } } }$ $d(\\arcsin x)=\\frac{1}{\\sqrt{1-{ {x}^{2} } } }dx$(12) $y=\\arccos x$ ${y}’=-\\frac{1}{\\sqrt{1-{ {x}^{2} } } }$ $d(\\arccos x)=-\\frac{1}{\\sqrt{1-{ {x}^{2} } } }dx$ (13) $y=\\arctan x$ ${y}’=\\frac{1}{1+{ {x}^{2} } }$ $d(\\arctan x)=\\frac{1}{1+{ {x}^{2} } }dx$ (14) $y=\\operatorname{arc}\\cot x$ ${y}’=-\\frac{1}{1+{ {x}^{2} } }$ $d(\\operatorname{arc}\\cot x)=-\\frac{1}{1+{ {x}^{2} } }dx$(15) $y=shx$ ${y}’=chx$ $d(shx)=chxdx$ (16) $y=chx$ ${y}’=shx$ $d(chx)=shxdx$ 复合函数，反函数，隐函数以及参数方程所确定的函数的微分法(1) 反函数的运算法则: 设$y=f(x)$在点$x$的某邻域内单调连续，在点$x$处可导且${f}’(x)\\ne 0$，则其反函数在点$x$所对应的$y$处可导，并且有$\\frac{dy}{dx}=\\frac{1}{\\frac{dx}{dy} }$(2) 复合函数的运算法则:若$\\mu =\\varphi (x)$在点$x$可导,而$y=f(\\mu )$在对应点$\\mu $($\\mu =\\varphi (x)$)可导,则复合函数$y=f(\\varphi (x))$在点$x$可导,且${y}’={f}’(\\mu )\\cdot {\\varphi }’(x)$(3) 隐函数导数$\\frac{dy}{dx}$的求法一般有三种方法：1)方程两边对$x$求导，要记住$y$是$x$的函数，则$y$的函数是$x$的复合函数.例如$\\frac{1}{y}$，${ {y}^{2} }$，$ln y$，${ { {e} }^{y} }$等均是$x$的复合函数.对$x$求导应按复合函数连锁法则做.2)公式法.由$F(x,y)=0$知 $\\frac{dy}{dx}=-\\frac{ { { { {F}’} }{x} }(x,y)}{ { { { {F}’} }{y} }(x,y)}$,其中，${ { {F}’}{x} }(x,y)$，${ { {F}’}{y} }(x,y)$分别表示$F(x,y)$对$x$和$y$的偏导数3)利用微分形式不变性 常用高阶导数公式（1）$({ {a}^{x} }){ {,}^{(n)} }={ {a}^{x} }{ {\\ln }^{n} }a\\quad (a&gt;{0})\\quad \\quad ({ { {e} }^{x} }){ {,}^{(n)} }={e}{ {,}^{x} }$（2）$(\\sin kx{)}{ {,}^{(n)} }={ {k}^{n} }\\sin (kx+n\\cdot \\frac{\\pi }{ {2} })$（3）$(\\cos kx{)}{ {,}^{(n)} }={ {k}^{n} }\\cos (kx+n\\cdot \\frac{\\pi }{ {2} })$（4）$({ {x}^{m} }){ {,}^{(n)} }=m(m-1)\\cdots (m-n+1){ {x}^{m-n} }$（5）$(\\ln x){ {,}^{(n)} }={ {(-{1})}^{(n-{1})} }\\frac{(n-{1})!}{ { {x}^{n} } }$（6）莱布尼兹公式：若$u(x),,v(x)$均$n$阶可导，则 ${ {(uv)}^{(n)} }=\\sum\\limits_{i={0} }^{n}{c_{n}^{i}{ {u}^{(i)} }{ {v}^{(n-i)} } }$，其中${ {u}^{({0})} }=u$，${ {v}^{({0})} }=v$ 微分中值定理，泰勒公式Th1(费马定理)若函数$f(x)$满足条件：(1)函数$f(x)$在${ {x}{0} }$的某邻域内有定义，并且在此邻域内恒有$f(x)\\le f({ {x}{0} })$或$f(x)\\ge f({ {x}_{0} })$, (2) $f(x)$在${ {x}{0} }$处可导,则有 ${f}’({ {x}{0} })=0$ Th2(罗尔定理)设函数$f(x)$满足条件：(1)在闭区间$[a,b]$上连续； (2)在$(a,b)$内可导； (3)$f(a)=f(b)$； 则在$(a,b)$内一存在个$\\xi $，使 ${f}’(\\xi )=0$ Th3(拉格朗日中值定理)设函数$f(x)$满足条件：(1)在$[a,b]$上连续； (2)在$(a,b)$内可导； 则在$(a,b)$内一存在个$\\xi $，使 $\\frac{f(b)-f(a)}{b-a}={f}’(\\xi )$ Th4(柯西中值定理) 设函数$f(x)$，$g(x)$满足条件：(1) 在$[a,b]$上连续； (2) 在$(a,b)$内可导且${f}’(x)$，${g}’(x)$均存在，且${g}’(x)\\ne 0$ 则在$(a,b)$内存在一个$\\xi $，使 $\\frac{f(b)-f(a)}{g(b)-g(a)}=\\frac{ {f}’(\\xi )}{ {g}’(\\xi )}$ 洛必达法则法则Ⅰ ($\\frac{0}{0}$型)设函数$f\\left( x \\right),g\\left( x \\right)$满足条件： $\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },f\\left( x \\right)=0,\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },g\\left( x \\right)=0$; $f\\left( x \\right),g\\left( x \\right)$在${ {x}{0} }$的邻域内可导，(在${ {x}{0} }$处可除外)且${g}’\\left( x \\right)\\ne 0$; $\\underset{x\\to { {x}_{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$存在(或$\\infty $)。 则:$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$。法则${ {I}’}$ ($\\frac{0}{0}$型)设函数$f\\left( x \\right),g\\left( x \\right)$满足条件：$\\underset{x\\to \\infty }{\\mathop{\\lim } },f\\left( x \\right)=0,\\underset{x\\to \\infty }{\\mathop{\\lim } },g\\left( x \\right)=0$; 存在一个$X&gt;0$,当$\\left| x \\right|&gt;X$时,$f\\left( x \\right),g\\left( x \\right)$可导,且${g}’\\left( x \\right)\\ne 0$;$\\underset{x\\to { {x}_{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$存在(或$\\infty $)。 则:$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$法则Ⅱ($\\frac{\\infty }{\\infty }$型) 设函数$f\\left( x \\right),g\\left( x \\right)$满足条件：$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },f\\left( x \\right)=\\infty ,\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },g\\left( x \\right)=\\infty $; $f\\left( x \\right),g\\left( x \\right)$在${ {x}{0} }$ 的邻域内可导(在${ {x}{0} }$处可除外)且${g}’\\left( x \\right)\\ne 0$;$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}$存在(或$\\infty $)。则$\\underset{x\\to { {x}{0} } }{\\mathop{\\lim } },\\frac{f\\left( x \\right)}{g\\left( x \\right)}=\\underset{x\\to { {x}_{0} } }{\\mathop{\\lim } },\\frac{ {f}’\\left( x \\right)}{ {g}’\\left( x \\right)}.$同理法则${I{I}’}$($\\frac{\\infty }{\\infty }$型)仿法则${ {I}’}$可写出。 泰勒公式设函数$f(x)$在点${ {x}{0} }$处的某邻域内具有$n+1$阶导数，则对该邻域内异于${ {x}{0} }$的任意点$x$，在${ {x}{0} }$与$x$之间至少存在一个$\\xi $，使得：$f(x)=f({ {x}{0} })+{f}’({ {x}{0} })(x-{ {x}{0} })+\\frac{1}{2!}{f}’’({ {x}{0} }){ {(x-{ {x}{0} })}^{2} }+\\cdots $$+\\frac{ { {f}^{(n)} }({ {x}{0} })}{n!}{ {(x-{ {x}{0} })}^{n} }+{ {R}{n} }(x)$ 其中 ${ {R}{n} }(x)=\\frac{ { {f}^{(n+1)} }(\\xi )}{(n+1)!}{ {(x-{ {x}{0} })}^{n+1} }$称为$f(x)$在点${ {x}{0} }$处的$n$阶泰勒余项。 令${ {x}{0} }=0$，则$n$阶泰勒公式$f(x)=f(0)+{f}’(0)x+\\frac{1}{2!}{f}’’(0){ {x}^{2} }+\\cdots +\\frac{ { {f}^{(n)} }(0)}{n!}{ {x}^{n} }+{ {R}{n} }(x)$……(1)其中 ${ {R}_{n} }(x)=\\frac{ { {f}^{(n+1)} }(\\xi )}{(n+1)!}{ {x}^{n+1} }$，$\\xi $在0与$x$之间.(1)式称为麦克劳林公式 常用五种函数在${ {x}_{0} }=0$处的泰勒公式(1) ${ { {e} }^{x} }=1+x+\\frac{1}{2!}{ {x}^{2} }+\\cdots +\\frac{1}{n!}{ {x}^{n} }+\\frac{ { {x}^{n+1} } }{(n+1)!}{ {e}^{\\xi } }$ 或 $=1+x+\\frac{1}{2!}{ {x}^{2} }+\\cdots +\\frac{1}{n!}{ {x}^{n} }+o({ {x}^{n} })$ (2) $\\sin x=x-\\frac{1}{3!}{ {x}^{3} }+\\cdots +\\frac{ { {x}^{n} } }{n!}\\sin \\frac{n\\pi }{2}+\\frac{ { {x}^{n+1} } }{(n+1)!}\\sin (\\xi +\\frac{n+1}{2}\\pi )$ 或 $=x-\\frac{1}{3!}{ {x}^{3} }+\\cdots +\\frac{ { {x}^{n} } }{n!}\\sin \\frac{n\\pi }{2}+o({ {x}^{n} })$ (3) $\\cos x=1-\\frac{1}{2!}{ {x}^{2} }+\\cdots +\\frac{ { {x}^{n} } }{n!}\\cos \\frac{n\\pi }{2}+\\frac{ { {x}^{n+1} } }{(n+1)!}\\cos (\\xi +\\frac{n+1}{2}\\pi )$ 或 $=1-\\frac{1}{2!}{ {x}^{2} }+\\cdots +\\frac{ { {x}^{n} } }{n!}\\cos \\frac{n\\pi }{2}+o({ {x}^{n} })$ (4) $\\ln (1+x)=x-\\frac{1}{2}{ {x}^{2} }+\\frac{1}{3}{ {x}^{3} }-\\cdots +{ {(-1)}^{n-1} }\\frac{ { {x}^{n} } }{n}+\\frac{ { {(-1)}^{n} }{ {x}^{n+1} } }{(n+1){ {(1+\\xi )}^{n+1} } }$ 或 $=x-\\frac{1}{2}{ {x}^{2} }+\\frac{1}{3}{ {x}^{3} }-\\cdots +{ {(-1)}^{n-1} }\\frac{ { {x}^{n} } }{n}+o({ {x}^{n} })$ (5) ${ {(1+x)}^{m} }=1+mx+\\frac{m(m-1)}{2!}{ {x}^{2} }+\\cdots +\\frac{m(m-1)\\cdots (m-n+1)}{n!}{ {x}^{n} }$$+\\frac{m(m-1)\\cdots (m-n+1)}{(n+1)!}{ {x}^{n+1} }{ {(1+\\xi )}^{m-n-1} }$ 或 ${ {(1+x)}^{m} }=1+mx+\\frac{m(m-1)}{2!}{ {x}^{2} }+\\cdots $ $+\\frac{m(m-1)\\cdots (m-n+1)}{n!}{ {x}^{n} }+o({ {x}^{n} })$ 函数单调性的判断Th1: 设函数$f(x)$在$(a,b)$区间内可导，如果对$\\forall x\\in (a,b)$，都有$f,‘(x)&gt;0$（或$f,‘(x)&lt;0$），则函数$f(x)$在$(a,b)$内是单调增加的（或单调减少） Th2: （取极值的必要条件）设函数$f(x)$在${ {x}{0} }$处可导，且在${ {x}{0} }$处取极值，则$f,‘({ {x}_{0} })=0$。 Th3: （取极值的第一充分条件）设函数$f(x)$在${ {x}{0} }$的某一邻域内可微，且$f,‘({ {x}{0} })=0$（或$f(x)$在${ {x}{0} }$处连续，但$f,‘({ {x}{0} })$不存在。）(1)若当$x$经过${ {x}{0} }$时，$f,‘(x)$由“+”变“-”，则$f({ {x}{0} })$为极大值；(2)若当$x​$经过${ {x}{0} }​$时，$f,‘(x)$由“-”变“+”，则$f({ {x}{0} })$为极小值；(3)若$f,‘(x)$经过$x={ {x}{0} }$的两侧不变号，则$f({ {x}{0} })$不是极值。 Th4: (取极值的第二充分条件)设$f(x)$在点${ {x}{0} }$处有$f’’(x)\\ne 0$，且$f,‘({ {x}{0} })=0$，则 当$f’,‘({ {x}{0} })&lt;0$时，$f({ {x}{0} })$为极大值；当$f’,‘({ {x}{0} })&gt;0$时，$f({ {x}{0} })$为极小值。注：如果$f’,‘({ {x}_{0} })&lt;0$，此方法失效。 渐近线的求法(1)水平渐近线 若$\\underset{x\\to +\\infty }{\\mathop{\\lim } },f(x)=b$，或$\\underset{x\\to -\\infty }{\\mathop{\\lim } },f(x)=b$，则 $y=b$称为函数$y=f(x)$的水平渐近线。 (2)铅直渐近线 若$\\underset{x\\to x_{0}^{-} }{\\mathop{\\lim } },f(x)=\\infty $，或$\\underset{x\\to x_{0}^{+} }{\\mathop{\\lim } },f(x)=\\infty $，则 $x={ {x}_{0} }$称为$y=f(x)$的铅直渐近线。 (3)斜渐近线 若$a=\\underset{x\\to \\infty }{\\mathop{\\lim } },\\frac{f(x)}{x},\\quad b=\\underset{x\\to \\infty }{\\mathop{\\lim } },[f(x)-ax]$，则$y=ax+b$称为$y=f(x)$的斜渐近线。 函数凹凸性的判断Th1: (凹凸性的判别定理）若在I上$f’’(x)&lt;0$（或$f’’(x)&gt;0$），则$f(x)$在I上是凸的（或凹的）。 Th2: (拐点的判别定理1)若在${ {x}{0} }$处$f’’(x)=0$，（或$f’’(x)$不存在），当$x$变动经过${ {x}{0} }$时，$f’’(x)$变号，则$({ {x}{0} },f({ {x}{0} }))$为拐点。 Th3: (拐点的判别定理2)设$f(x)$在${ {x}{0} }$点的某邻域内有三阶导数，且$f’’(x)=0$，$f’’’(x)\\ne 0$，则$({ {x}{0} },f({ {x}_{0} }))$为拐点。 弧微分$dS=\\sqrt{1+y{ {‘}^{2} } }dx$ 曲率若曲线由参数方程$\\begin{cases}x=x(t),\\y=y(t),\\end{cases}t\\in[\\alpha,\\beta]$给出且有二阶微商，则其在一点的曲率$K=\\frac{|y’’x’-y’x’’|}{[x’^2+y’^2]^{\\frac{3}{2} } }$若$y=f(x)$，则$K=\\frac{|y’’|}{(1+y’^2)^\\frac{3}{2} }$同时记$\\frac{1}{K}$为曲率半径。 曲率半径曲线在点$M$处的曲率$k(k\\ne 0)$与曲线在点$M$处的曲率半径$\\rho $有如下关系：$\\rho =\\frac{1}{k}$。","link":"/2018/11/30/2018-11-30-数学分析/"},{"title":"线性代数","text":"转载自斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 线性代数行列式1.行列式按行（列）展开定理 (1) 设$A = ( a_{ {ij} } ){n \\times n}$，则：$a{i1}A_{j1} +a_{i2}A_{j2} + \\cdots + a_{ {in} }A_{ {jn} } = \\begin{cases}|A|,i=j\\ 0,i \\neq j\\end{cases}$ 或$a_{1i}A_{1j} + a_{2i}A_{2j} + \\cdots + a_{ {ni} }A_{ {nj} } = \\begin{cases}|A|,i=j\\ 0,i \\neq j\\end{cases}$即 $AA^{} = A^{}A = \\left| A \\right|E,$其中：$A^{*} = \\begin{pmatrix} A_{11} &amp; A_{12} &amp; \\ldots &amp; A_{1n} \\ A_{21} &amp; A_{22} &amp; \\ldots &amp; A_{2n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ A_{n1} &amp; A_{n2} &amp; \\ldots &amp; A_{ {nn} } \\ \\end{pmatrix} = (A_{ {ji} }) = {(A_{ {ij} })}^{T}$ $D_{n} = \\begin{vmatrix} 1 &amp; 1 &amp; \\ldots &amp; 1 \\ x_{1} &amp; x_{2} &amp; \\ldots &amp; x_{n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ x_{1}^{n - 1} &amp; x_{2}^{n - 1} &amp; \\ldots &amp; x_{n}^{n - 1} \\ \\end{vmatrix} = \\prod_{1 \\leq j &lt; i \\leq n}^{},(x_{i} - x_{j})$ (2) 设$A,B$为$n$阶方阵，则$\\left| {AB} \\right| = \\left| A \\right|\\left| B \\right| = \\left| B \\right|\\left| A \\right| = \\left| {BA} \\right|$，但$\\left| A \\pm B \\right| = \\left| A \\right| \\pm \\left| B \\right|$不一定成立。 (3) $\\left| {kA} \\right| = k^{n}\\left| A \\right|$,$A$为$n$阶方阵。 (4) 设$A$为$n$阶方阵，$|A^{T}| = |A|;|A^{- 1}| = |A|^{- 1}$（若$A$可逆），$|A^{*}| = |A|^{n - 1}$ $n \\geq 2$ (5) $\\left| \\begin{matrix} &amp; {A\\quad O} \\ &amp; {O\\quad B} \\ \\end{matrix} \\right| = \\left| \\begin{matrix} &amp; {A\\quad C} \\ &amp; {O\\quad B} \\ \\end{matrix} \\right| = \\left| \\begin{matrix} &amp; {A\\quad O} \\ &amp; {C\\quad B} \\ \\end{matrix} \\right| =| A||B|$，$A,B$为方阵，但$\\left| \\begin{matrix} {O} &amp; A_{m \\times m} \\ B_{n \\times n} &amp; { O} \\ \\end{matrix} \\right| = ({- 1)}^{ {mn} }|A||B|$ 。 (6) 范德蒙行列式$D_{n} = \\begin{vmatrix} 1 &amp; 1 &amp; \\ldots &amp; 1 \\ x_{1} &amp; x_{2} &amp; \\ldots &amp; x_{n} \\ \\ldots &amp; \\ldots &amp; \\ldots &amp; \\ldots \\ x_{1}^{n - 1} &amp; x_{2}^{n 1} &amp; \\ldots &amp; x_{n}^{n - 1} \\ \\end{vmatrix} = \\prod_{1 \\leq j &lt; i \\leq n}^{},(x_{i} - x_{j})$ 设$A$是$n$阶方阵，$\\lambda_{i}(i = 1,2\\cdots,n)$是$A$的$n$个特征值，则$|A| = \\prod_{i = 1}^{n}\\lambda_{i}​$ 矩阵矩阵：$m \\times n$个数$a_{ {ij} }$排成$m$行$n$列的表格$\\begin{bmatrix} a_{11}\\quad a_{12}\\quad\\cdots\\quad a_{1n} \\ a_{21}\\quad a_{22}\\quad\\cdots\\quad a_{2n} \\ \\quad\\cdots\\cdots\\cdots\\cdots\\cdots \\ a_{m1}\\quad a_{m2}\\quad\\cdots\\quad a_{ {mn} } \\ \\end{bmatrix}$ 称为矩阵，简记为$A$，或者$\\left( a_{ {ij} } \\right)_{m \\times n}$ 。若$m = n$，则称$A$是$n$阶矩阵或$n$阶方阵。 矩阵的线性运算 1.矩阵的加法 设$A = (a_{ {ij} }),B = (b_{ {ij} })$是两个$m \\times n$矩阵，则$m \\times n$ 矩阵$C = c_{ {ij} }) = a_{ {ij} } + b_{ {ij} }$称为矩阵$A$与$B$的和，记为$A + B = C$ 。 2.矩阵的数乘 设$A = (a_{ {ij} })$是$m \\times n$矩阵，$k$是一个常数，则$m \\times n$矩阵$(ka_{ {ij} })$称为数$k$与矩阵$A$的数乘，记为${kA}$。 3.矩阵的乘法 设$A = (a_{ {ij} })$是$m \\times n$矩阵，$B = (b_{ {ij} })$是$n \\times s$矩阵，那么$m \\times s$矩阵$C = (c_{ {ij} })$，其中$c_{ {ij} } = a_{i1}b_{1j} + a_{i2}b_{2j} + \\cdots + a_{ {in} }b_{ {nj} } = \\sum_{k =1}^{n}{a_{ {ik} }b_{ {kj} } }$称为${AB}$的乘积，记为$C = AB$ 。 4. $\\mathbf{A}^{\\mathbf{T} }$、$\\mathbf{A}^{\\mathbf{-1} }$、$\\mathbf{A}^{\\mathbf{} }$*三者之间的关系** (1) ${(A^{T})}^{T} = A,{(AB)}^{T} = B^{T}A^{T},{(kA)}^{T} = kA^{T},{(A \\pm B)}^{T} = A^{T} \\pm B^{T}$ (2) $\\left( A^{- 1} \\right)^{- 1} = A,\\left( {AB} \\right)^{- 1} = B^{- 1}A^{- 1},\\left( {kA} \\right)^{- 1} = \\frac{1}{k}A^{- 1},$ 但 ${(A \\pm B)}^{- 1} = A^{- 1} \\pm B^{- 1}$不一定成立。 (3) $\\left( A^{} \\right)^{} = |A|^{n - 2}\\ A\\ \\ (n \\geq 3)$，$\\left({AB} \\right)^{} = B^{}A^{},$ $\\left( {kA} \\right)^{} = k^{n -1}A^{*}{\\ \\ }\\left( n \\geq 2 \\right)$ 但$\\left( A \\pm B \\right)^{} = A^{} \\pm B^{*}$不一定成立。 (4) ${(A^{- 1})}^{T} = {(A^{T})}^{- 1},\\ \\left( A^{- 1} \\right)^{} ={(AA^{})}^{- 1},{(A^{})}^{T} = \\left( A^{T} \\right)^{}$ 5.有关$\\mathbf{A}^{\\mathbf{} }$*的结论** (1) $AA^{} = A^{}A = |A|E$ (2) $|A^{}| = |A|^{n - 1}\\ (n \\geq 2),\\ \\ \\ \\ {(kA)}^{} = k^{n -1}A^{},{ {\\ \\ }\\left( A^{} \\right)}^{*} = |A|^{n - 2}A(n \\geq 3)$ (3) 若$A$可逆，则$A^{} = |A|A^{- 1},{(A^{})}^{*} = \\frac{1}{|A|}A$ (4) 若$A​$为$n​$阶方阵，则： $r(A^*)=\\begin{cases}n,\\quad r(A)=n\\ 1,\\quad r(A)=n-1\\ 0,\\quad r(A)&lt;n-1\\end{cases}$ 6.有关$\\mathbf{A}^{\\mathbf{- 1} }$的结论 $A$可逆$\\Leftrightarrow AB = E; \\Leftrightarrow |A| \\neq 0; \\Leftrightarrow r(A) = n;$ $\\Leftrightarrow A$可以表示为初等矩阵的乘积；$\\Leftrightarrow A;\\Leftrightarrow Ax = 0$。 7.有关矩阵秩的结论 (1) 秩$r(A)$=行秩=列秩； (2) $r(A_{m \\times n}) \\leq \\min(m,n);$ (3) $A \\neq 0 \\Rightarrow r(A) \\geq 1$； (4) $r(A \\pm B) \\leq r(A) + r(B);$ (5) 初等变换不改变矩阵的秩 (6) $r(A) + r(B) - n \\leq r(AB) \\leq \\min(r(A),r(B)),$特别若$AB = O$则：$r(A) + r(B) \\leq n$ (7) 若$A^{- 1}$存在$\\Rightarrow r(AB) = r(B);$ 若$B^{- 1}$存在$\\Rightarrow r(AB) = r(A);$ 若$r(A_{m \\times n}) = n \\Rightarrow r(AB) = r(B);$ 若$r(A_{m \\times s}) = n\\Rightarrow r(AB) = r\\left( A \\right)$。 (8) $r(A_{m \\times s}) = n \\Leftrightarrow Ax = 0$只有零解 8.分块求逆公式 $\\begin{pmatrix} A &amp; O \\ O &amp; B \\ \\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{-1} &amp; O \\ O &amp; B^{- 1} \\ \\end{pmatrix}$； $\\begin{pmatrix} A &amp; C \\ O &amp; B \\\\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{- 1}&amp; - A^{- 1}CB^{- 1} \\ O &amp; B^{- 1} \\ \\end{pmatrix}$； $\\begin{pmatrix} A &amp; O \\ C &amp; B \\ \\end{pmatrix}^{- 1} = \\begin{pmatrix} A^{- 1}&amp;{O} \\ - B^{- 1}CA^{- 1} &amp; B^{- 1} \\\\end{pmatrix}$； $\\begin{pmatrix} O &amp; A \\ B &amp; O \\ \\end{pmatrix}^{- 1} =\\begin{pmatrix} O &amp; B^{- 1} \\ A^{- 1} &amp; O \\ \\end{pmatrix}$ 这里$A$，$B$均为可逆方阵。 向量1.有关向量组的线性表示 (1)$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性相关$\\Leftrightarrow$至少有一个向量可以用其余向量线性表示。 (2)$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$，$\\beta$线性相关$\\Leftrightarrow \\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$唯一线性表示。 (3) $\\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性表示$\\Leftrightarrow r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}) =r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s},\\beta)$ 。 2.有关向量组的线性相关性 (1)部分相关，整体相关；整体无关，部分无关. (2) ① $n$个$n$维向量$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{n}$线性无关$\\Leftrightarrow \\left|\\left\\lbrack \\alpha_{1}\\alpha_{2}\\cdots\\alpha_{n} \\right\\rbrack \\right| \\neq0$， $n$个$n$维向量$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{n}$线性相关$\\Leftrightarrow |\\lbrack\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}\\rbrack| = 0$。 ② $n + 1$个$n$维向量线性相关。 ③ 若$\\alpha_{1},\\alpha_{2}\\cdots\\alpha_{S}$线性无关，则添加分量后仍线性无关；或一组向量线性相关，去掉某些分量后仍线性相关。 3.有关向量组的线性表示 (1) $\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性相关$\\Leftrightarrow$至少有一个向量可以用其余向量线性表示。 (2) $\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$，$\\beta$线性相关$\\Leftrightarrow\\beta$ 可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$唯一线性表示。 (3) $\\beta$可以由$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性表示$\\Leftrightarrow r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}) =r(\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s},\\beta)$ 4.向量组的秩与矩阵的秩之间的关系 设$r(A_{m \\times n}) =r$，则$A$的秩$r(A)$与$A$的行列向量组的线性相关性关系为： (1) 若$r(A_{m \\times n}) = r = m$，则$A$的行向量组线性无关。 (2) 若$r(A_{m \\times n}) = r &lt; m$，则$A$的行向量组线性相关。 (3) 若$r(A_{m \\times n}) = r = n$，则$A$的列向量组线性无关。 (4) 若$r(A_{m \\times n}) = r &lt; n$，则$A$的列向量组线性相关。 5.$\\mathbf{n}$维向量空间的基变换公式及过渡矩阵 若$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$与$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$是向量空间$V$的两组基，则基变换公式为： $(\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}) = (\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n})\\begin{bmatrix} c_{11}&amp; c_{12}&amp; \\cdots &amp; c_{1n} \\ c_{21}&amp; c_{22}&amp;\\cdots &amp; c_{2n} \\ \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\ c_{n1}&amp; c_{n2} &amp; \\cdots &amp; c_{ {nn} } \\\\end{bmatrix} = (\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n})C$ 其中$C$是可逆矩阵，称为由基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$到基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的过渡矩阵。 6.坐标变换公式 若向量$\\gamma$在基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$与基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的坐标分别是$X = {(x_{1},x_{2},\\cdots,x_{n})}^{T}$， $Y = \\left( y_{1},y_{2},\\cdots,y_{n} \\right)^{T}$ 即： $\\gamma =x_{1}\\alpha_{1} + x_{2}\\alpha_{2} + \\cdots + x_{n}\\alpha_{n} = y_{1}\\beta_{1} +y_{2}\\beta_{2} + \\cdots + y_{n}\\beta_{n}$，则向量坐标变换公式为$X = CY$ 或$Y = C^{- 1}X$，其中$C$是从基$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$到基$\\beta_{1},\\beta_{2},\\cdots,\\beta_{n}$的过渡矩阵。 7.向量的内积 $(\\alpha,\\beta) = a_{1}b_{1} + a_{2}b_{2} + \\cdots + a_{n}b_{n} = \\alpha^{T}\\beta = \\beta^{T}\\alpha$ 8.Schmidt正交化 若$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$线性无关，则可构造$\\beta_{1},\\beta_{2},\\cdots,\\beta_{s}$使其两两正交，且$\\beta_{i}$仅是$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{i}$的线性组合$(i= 1,2,\\cdots,n)$，再把$\\beta_{i}$单位化，记$\\gamma_{i} =\\frac{\\beta_{i} }{\\left| \\beta_{i}\\right|}$，则$\\gamma_{1},\\gamma_{2},\\cdots,\\gamma_{i}$是规范正交向量组。其中$\\beta_{1} = \\alpha_{1}$， $\\beta_{2} = \\alpha_{2} -\\frac{(\\alpha_{2},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1}$ ， $\\beta_{3} =\\alpha_{3} - \\frac{(\\alpha_{3},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1} -\\frac{(\\alpha_{3},\\beta_{2})}{(\\beta_{2},\\beta_{2})}\\beta_{2}$ ， ………… $\\beta_{s} = \\alpha_{s} - \\frac{(\\alpha_{s},\\beta_{1})}{(\\beta_{1},\\beta_{1})}\\beta_{1} - \\frac{(\\alpha_{s},\\beta_{2})}{(\\beta_{2},\\beta_{2})}\\beta_{2} - \\cdots - \\frac{(\\alpha_{s},\\beta_{s - 1})}{(\\beta_{s - 1},\\beta_{s - 1})}\\beta_{s - 1}$ 9.正交基及规范正交基 向量空间一组基中的向量如果两两正交，就称为正交基；若正交基中每个向量都是单位向量，就称其为规范正交基。 线性方程组1．克莱姆法则 线性方程组$\\begin{cases} a_{11}x_{1} + a_{12}x_{2} + \\cdots +a_{1n}x_{n} = b_{1} \\ a_{21}x_{1} + a_{22}x_{2} + \\cdots + a_{2n}x_{n} =b_{2} \\ \\quad\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots\\cdots \\ a_{n1}x_{1} + a_{n2}x_{2} + \\cdots + a_{ {nn} }x_{n} = b_{n} \\ \\end{cases}$，如果系数行列式$D = \\left| A \\right| \\neq 0$，则方程组有唯一解，$x_{1} = \\frac{D_{1} }{D},x_{2} = \\frac{D_{2} }{D},\\cdots,x_{n} =\\frac{D_{n} }{D}$，其中$D_{j}$是把$D$中第$j$列元素换成方程组右端的常数列所得的行列式。 2. $n$阶矩阵$A$可逆$\\Leftrightarrow Ax = 0$只有零解。$\\Leftrightarrow\\forall b,Ax = b$总有唯一解，一般地，$r(A_{m \\times n}) = n \\Leftrightarrow Ax= 0$只有零解。 3.非奇次线性方程组有解的充分必要条件，线性方程组解的性质和解的结构 (1) 设$A$为$m \\times n$矩阵，若$r(A_{m \\times n}) = m$，则对$Ax =b$而言必有$r(A) = r(A \\vdots b) = m$，从而$Ax = b$有解。 (2) 设$x_{1},x_{2},\\cdots x_{s}$为$Ax = b$的解，则$k_{1}x_{1} + k_{2}x_{2}\\cdots + k_{s}x_{s}$当$k_{1} + k_{2} + \\cdots + k_{s} = 1$时仍为$Ax =b$的解；但当$k_{1} + k_{2} + \\cdots + k_{s} = 0$时，则为$Ax =0$的解。特别$\\frac{x_{1} + x_{2} }{2}$为$Ax = b$的解；$2x_{3} - (x_{1} +x_{2})$为$Ax = 0$的解。 (3) 非齐次线性方程组${Ax} = b$无解$\\Leftrightarrow r(A) + 1 =r(\\overline{A}) \\Leftrightarrow b$不能由$A$的列向量$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{n}$线性表示。 4.奇次线性方程组的基础解系和通解，解空间，非奇次线性方程组的通解 (1) 齐次方程组${Ax} = 0$恒有解(必有零解)。当有非零解时，由于解向量的任意线性组合仍是该齐次方程组的解向量，因此${Ax}= 0$的全体解向量构成一个向量空间，称为该方程组的解空间，解空间的维数是$n - r(A)$，解空间的一组基称为齐次方程组的基础解系。 (2) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$是${Ax} = 0$的基础解系，即： 1) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$是${Ax} = 0$的解； 2) $\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$线性无关； 3) ${Ax} = 0$的任一解都可以由$\\eta_{1},\\eta_{2},\\cdots,\\eta_{t}$线性表出.$k_{1}\\eta_{1} + k_{2}\\eta_{2} + \\cdots + k_{t}\\eta_{t}$是${Ax} = 0$的通解，其中$k_{1},k_{2},\\cdots,k_{t}$是任意常数。 矩阵的特征值和特征向量1.矩阵的特征值和特征向量的概念及性质 (1) 设$\\lambda$是$A$的一个特征值，则 ${kA},{aA} + {bE},A^{2},A^{m},f(A),A^{T},A^{- 1},A^{*}$有一个特征值分别为${kλ},{aλ} + b,\\lambda^{2},\\lambda^{m},f(\\lambda),\\lambda,\\lambda^{- 1},\\frac{|A|}{\\lambda},$且对应特征向量相同（$A^{T}$ 例外）。 (2)若$\\lambda_{1},\\lambda_{2},\\cdots,\\lambda_{n}$为$A$的$n$个特征值，则$\\sum_{i= 1}^{n}\\lambda_{i} = \\sum_{i = 1}^{n}a_{ {ii} },\\prod_{i = 1}^{n}\\lambda_{i}= |A|$ ,从而$|A| \\neq 0 \\Leftrightarrow A$没有特征值。 (3)设$\\lambda_{1},\\lambda_{2},\\cdots,\\lambda_{s}$为$A$的$s$个特征值，对应特征向量为$\\alpha_{1},\\alpha_{2},\\cdots,\\alpha_{s}$， 若: $\\alpha = k_{1}\\alpha_{1} + k_{2}\\alpha_{2} + \\cdots + k_{s}\\alpha_{s}$ , 则: $A^{n}\\alpha = k_{1}A^{n}\\alpha_{1} + k_{2}A^{n}\\alpha_{2} + \\cdots +k_{s}A^{n}\\alpha_{s} = k_{1}\\lambda_{1}^{n}\\alpha_{1} +k_{2}\\lambda_{2}^{n}\\alpha_{2} + \\cdots k_{s}\\lambda_{s}^{n}\\alpha_{s}$ 。 2.相似变换、相似矩阵的概念及性质 (1) 若$A \\sim B$，则 1) $A^{T} \\sim B^{T},A^{- 1} \\sim B^{- 1},,A^{} \\sim B^{}$ 2) $|A| = |B|,\\sum_{i = 1}^{n}A_{ {ii} } = \\sum_{i =1}^{n}b_{ {ii} },r(A) = r(B)$ 3) $|\\lambda E - A| = |\\lambda E - B|$，对$\\forall\\lambda$成立 3.矩阵可相似对角化的充分必要条件 (1)设$A$为$n$阶方阵，则$A$可对角化$\\Leftrightarrow$对每个$k_{i}$重根特征值$\\lambda_{i}$，有$n-r(\\lambda_{i}E - A) = k_{i}$ (2) 设$A$可对角化，则由$P^{- 1}{AP} = \\Lambda,$有$A = {PΛ}P^{-1}$，从而$A^{n} = P\\Lambda^{n}P^{- 1}$ (3) 重要结论 1) 若$A \\sim B,C \\sim D​$，则$\\begin{bmatrix} A &amp; O \\ O &amp; C \\\\end{bmatrix} \\sim \\begin{bmatrix} B &amp; O \\ O &amp; D \\\\end{bmatrix}​$. 2) 若$A \\sim B$，则$f(A) \\sim f(B),\\left| f(A) \\right| \\sim \\left| f(B)\\right|$，其中$f(A)$为关于$n$阶方阵$A$的多项式。 3) 若$A$为可对角化矩阵，则其非零特征值的个数(重根重复计算)＝秩($A$) 4.实对称矩阵的特征值、特征向量及相似对角阵 (1)相似矩阵：设$A,B$为两个$n$阶方阵，如果存在一个可逆矩阵$P$，使得$B =P^{- 1}{AP}$成立，则称矩阵$A$与$B$相似，记为$A \\sim B$。 (2)相似矩阵的性质：如果$A \\sim B$则有： 1) $A^{T} \\sim B^{T}$ 2) $A^{- 1} \\sim B^{- 1}$ （若$A$，$B$均可逆） 3) $A^{k} \\sim B^{k}$ （$k$为正整数） 4) $\\left| {λE} - A \\right| = \\left| {λE} - B \\right|$，从而$A,B$有相同的特征值 5) $\\left| A \\right| = \\left| B \\right|$，从而$A,B$同时可逆或者不可逆 6) 秩$\\left( A \\right) =$秩$\\left( B \\right),\\left| {λE} - A \\right| =\\left| {λE} - B \\right|$，$A,B$不一定相似 二次型1.$\\mathbf{n}$个变量$\\mathbf{x}{\\mathbf{1} }\\mathbf{,}\\mathbf{x}{\\mathbf{2} }\\mathbf{,\\cdots,}\\mathbf{x}_{\\mathbf{n} }$的二次齐次函数 $f(x_{1},x_{2},\\cdots,x_{n}) = \\sum_{i = 1}^{n}{\\sum_{j =1}^{n}{a_{ {ij} }x_{i}y_{j} } }$，其中$a_{ {ij} } = a_{ {ji} }(i,j =1,2,\\cdots,n)$，称为$n$元二次型，简称二次型. 若令$x = \\ \\begin{bmatrix}x_{1} \\ x_{1} \\ \\vdots \\ x_{n} \\ \\end{bmatrix},A = \\begin{bmatrix} a_{11}&amp; a_{12}&amp; \\cdots &amp; a_{1n} \\ a_{21}&amp; a_{22}&amp; \\cdots &amp; a_{2n} \\ \\cdots &amp;\\cdots &amp;\\cdots &amp;\\cdots \\ a_{n1}&amp; a_{n2} &amp; \\cdots &amp; a_{ {nn} } \\\\end{bmatrix}$,这二次型$f$可改写成矩阵向量形式$f =x^{T}{Ax}$。其中$A$称为二次型矩阵，因为$a_{ {ij} } =a_{ {ji} }(i,j =1,2,\\cdots,n)$，所以二次型矩阵均为对称矩阵，且二次型与对称矩阵一一对应，并把矩阵$A$的秩称为二次型的秩。 2.惯性定理，二次型的标准形和规范形 (1) 惯性定理 对于任一二次型，不论选取怎样的合同变换使它化为仅含平方项的标准型，其正负惯性指数与所选变换无关，这就是所谓的惯性定理。 (2) 标准形 二次型$f = \\left( x_{1},x_{2},\\cdots,x_{n} \\right) =x^{T}{Ax}$经过合同变换$x = {Cy}$化为$f = x^{T}{Ax} =y^{T}C^{T}{AC}$ $y = \\sum_{i = 1}^{r}{d_{i}y_{i}^{2} }$称为 $f(r \\leq n)$的标准形。在一般的数域内，二次型的标准形不是唯一的，与所作的合同变换有关，但系数不为零的平方项的个数由$r(A)$唯一确定。 (3) 规范形 任一实二次型$f$都可经过合同变换化为规范形$f = z_{1}^{2} + z_{2}^{2} + \\cdots z_{p}^{2} - z_{p + 1}^{2} - \\cdots -z_{r}^{2}$，其中$r$为$A$的秩，$p$为正惯性指数，$r -p$为负惯性指数，且规范型唯一。 3.用正交变换和配方法化二次型为标准形，二次型及其矩阵的正定性 设$A$正定$\\Rightarrow {kA}(k &gt; 0),A^{T},A^{- 1},A^{*}$正定；$|A| &gt;0$,$A$可逆；$a_{ {ii} } &gt; 0$，且$|A_{ {ii} }| &gt; 0$ $A$，$B$正定$\\Rightarrow A +B$正定，但${AB}$，${BA}$不一定正定 $A$正定$\\Leftrightarrow f(x) = x^{T}{Ax} &gt; 0,\\forall x \\neq 0$ $\\Leftrightarrow A$的各阶顺序主子式全大于零 $\\Leftrightarrow A$的所有特征值大于零 $\\Leftrightarrow A$的正惯性指数为$n$ $\\Leftrightarrow$存在可逆阵$P$使$A = P^{T}P$ $\\Leftrightarrow$存在正交矩阵$Q$，使$Q^{T}{AQ} = Q^{- 1}{AQ} =\\begin{pmatrix} \\lambda_{1} &amp; &amp; \\ \\begin{matrix} &amp; \\ &amp; \\ \\end{matrix} &amp;\\ddots &amp; \\ &amp; &amp; \\lambda_{n} \\ \\end{pmatrix},$ 其中$\\lambda_{i} &gt; 0,i = 1,2,\\cdots,n.$正定$\\Rightarrow {kA}(k &gt;0),A^{T},A^{- 1},A^{*}$正定； $|A| &gt; 0,A$可逆；$a_{ {ii} } &gt;0$，且$|A_{ {ii} }| &gt; 0$ 。","link":"/2018/12/03/2018-12-03-线性代数基础/"},{"title":"数据结构","text":"以下数据结构均采用ll作为值类型，应用时根据需求调整。 123typedef long long ll;const ll INF = 1e9; //表示（值）正无穷，且两个正无穷相加不会溢出const int NPOS = -1; //表示（下标）不存在 离散化在vector基础上的离散化，使用push_back()向其中插值，init()排序并离散化，ask查询离散化之后的值，at/[]运算符查离散前的值。 12345struct Ranker : vector&lt;ll&gt;{ void init() { sort(begin(), end()), resize(unique(begin(), end()) - begin()); } int ask(ll x) const { return lower_bound(begin(), end(), x) - begin(); }}; 并查集1234567891011121314struct UnionfindSet : vector&lt;int&gt;{ UnionfindSet(int n) : vector&lt;int&gt;(n) { for (int i = 0; i &lt; n; ++i) at(i) = i; } void merge(int u, int w) { if (w = ask(w), u = ask(u), w != u) at(w) = u; } int ask(int u) { return at(u) != u ? at(u) = ask(at(u)) : u; }}; 单调队列和单调栈使用示例 1234567891011typedef pair&lt;int, ll&gt; pil;struct Monotone : deque&lt;pil&gt;{ void push(const pil &amp;p, int k) { while (!empty() &amp;&amp; back().second &gt;= p.second) pop_back(); for (push_back(p); p.first - front().first &gt;= k;) pop_front(); }}; ST表使用示例 $O(n\\log n)$预处理，$O(1)$求静态区间最小值。 123456789101112131415161718192021222324252627/*//可选优化#define log2(n) LOG2[n]struct Log : vector&lt;ll&gt;{ Log(int N, ll E) : vector&lt;ll&gt;(N, -1) { for (int i = 1; i &lt; N; ++i) at(i) = at(i / E) + 1; }} LOG2(N, 2);*/struct SparseTable{ vector&lt;vector&lt;ll&gt;&gt; f; SparseTable(const vector&lt;ll&gt; &amp;a) : f(log2(a.size()) + 1, a) { for (int k = 0; k + 1 &lt; f.size(); ++k) for (int i = 0; i + (1 &lt;&lt; k) &lt; a.size(); ++i) f[k + 1][i] = min(f[k][i], f[k][i + (1 &lt;&lt; k)]); } ll ask(int l, int r) { int k = log2(r - l + 1); return min(f[k][l], f[k][r + 1 - (1 &lt;&lt; k)]); }}; 树状数组模板中Base是对应的基础版本，支持单点修改区间查询。 一维1234567891011121314151617181920212223242526struct Fenwick{ struct BaseFenwick { vector&lt;ll&gt; v; BaseFenwick(int n) : v(n, 0) {} void add(int x, ll w) { for (; x &lt; v.size(); x += x &amp; -x) v[x] += w; } ll ask(int x) { ll ans = 0; for (; x; x -= x &amp; -x) ans += v[x]; return ans; } }; pair&lt;BaseFenwick, BaseFenwick&gt; p; Fenwick(int n) : p(n, n) {} void add(int x, ll w) { p.first.add(x, w), p.second.add(x, x * w); } void add(int l, int r, ll w) { add(l, w), add(r + 1, -w); } ll ask(int x) { return (x + 1) * p.first.ask(x) - p.second.ask(x); } ll ask(int l, int r) { return ask(r) - ask(l - 1); }}; 二维高维的数据结构只要每一维维护低一维的数据（树套树）即可。其余数据结构亦同理。 1234567891011121314151617181920212223242526struct Fenwick2{ struct BaseFenwick2 { vector&lt;Fenwick&gt; v; BaseFenwick2(int r, int c) : v(r, c) {} void add(int x, int b, int t, ll w) { for (; x &lt; v.size(); x += x &amp; -x) v[x].add(b, t, w); } ll ask(int x, int b, int t) { ll ans = 0; for (; x; x -= x &amp; -x) ans += v[x].ask(b, t); return ans; } }; pair&lt;BaseFenwick2, BaseFenwick2&gt; p; Fenwick2(int r, int c) : p(BaseFenwick2(r, c), BaseFenwick2(r, c)) {} void add(int x, int b, int t, ll w) { p.first.add(x, b, t, w), p.second.add(x, b, t, x * w); } void add(int l, int b, int r, int t, ll w) { add(l, b, t, w), add(r + 1, b, t, -w); } //(l,b)~(r,t) ll ask(int x, int b, int t) { return (x + 1) * p.first.ask(x, b, t) - p.second.ask(x, b, t); } ll ask(int l, int b, int r, int t) { return ask(r, b, t) - ask(l - 1, b, t); }}; 动态开点线段树使用示例，支持区间线性变换、区间查询（最大值最小值区间和）。 这样写改主席树也很方便，只要改down函数为每次都新建节点即可，示例。 undefined 无旋Treap按子树大小分裂使用示例 undefined 按值大小分裂使用示例，即排序树。 undefined 莫队使用示例 123456789101112131415161718192021222324252627282930313233struct Mo{ struct Query { int l, r, id; bool operator&lt;(const Query &amp;n) const { return l / BS != n.l / BS ? l &lt; n.l : r &lt; n.r; } }; vector&lt;Query&gt; q; int L, R; void query(int l, int r) { q.push_back(Query{l, r, q.size()}); } void rev(int x) {} void cal(int id) {} void ask() { L = 0, R = -1; sort(q.begin(), q.end()); for (int i = 0; i &lt; q.size(); ++i) { while (L &lt; q[i].l) rev(L++); while (L &gt; q[i].l) rev(--L); while (R &lt; q[i].r) rev(++R); while (R &gt; q[i].r) rev(R--); cal(q[i].id); } }}; 带修莫队使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct Mo{ struct Update { int pos, NEW, OLD; }; struct Query { int t, l, r, id; bool operator&lt;(const Query &amp;n) const { return l / BS != n.l / BS ? l &lt; n.l : r / BS != n.r / BS ? r &lt; n.r : t &lt; n.t; } }; vector&lt;Update&gt; cq; vector&lt;Query&gt; q; int T, L, R; Mo() : cq(1) {} void query(int x, int y) { q.push_back(Query{cq.size() - 1, x, y, q.size()}); } void update(int x, int y) { cq.push_back(Update{x, y, t[x]}), t[x] = y; } void set(int x, int d) { if (vis[x]) return rev(x), a[x] = d, rev(x); a[x] = d; } void rev(int x) {} void cal(int id) {} void ask() { T = L = 0, R = -1; sort(q.begin(), q.end()); for (int i = 0; i &lt; q.size(); ++i) { while (T &lt; q[i].t) ++T, set(cq[T].pos, cq[T].NEW); while (T &gt; q[i].t) set(cq[T].pos, cq[T].OLD), --T; while (L &lt; q[i].l) rev(L++); while (L &gt; q[i].l) rev(--L); while (R &lt; q[i].r) rev(++R); while (R &gt; q[i].r) rev(R--); cal(q[i].id); } }}; 树上莫队使用示例 按照欧拉序分块，使用Tarjan在生成欧拉序的同时预处理所有询问的lca，预处理时间复杂度$O(n+q)$。h为查询图，即如果有一个询问(u,v)，即在h上连$u\\to v,v\\to u$。多个询问边有序插入h。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061struct TreeMo : Graph{ struct Query { int l, r, lca, id; bool operator&lt;(const Query &amp;b) const { return l / BS != b.l / BS ? l &lt; b.l : r &lt; b.r; } }; vector&lt;Query&gt; q; vector&lt;int&gt; dfp, dfi, dfo; UnionFindSet ufs; Graph h; int L, R; TreeMo(int n) : Graph(n), h(n), dfp(n * 2 + 1), dfi(n), dfo(n), ufs(n) {} void query(int x, int y) { h.add(Edge{x, y}), h.add(Edge{y, x}); q.push_back(Query{0, 0, 0, q.size()}); } void rev(int x) {} void cal(int id) {} void dfs(int u, int &amp;cnt) { dfp[dfi[u] = ++cnt] = u; for (int i = 0, k, to; i &lt; v[u].a.size(); ++i) if (k = v[u].a[i], to = e[k].second, !dfi[to]) dfs(to, cnt), ufs.merge(u, to); dfp[dfo[u] = ++cnt] = u; for (int i = 0, k, to, id; i &lt; h.v[u].a.size(); ++i) if (k = h.v[u].a[i], id = k / 2, to = h.e[k].second, dfo[to]) { q[id].lca = ufs.fa(to); q[id].l = q[id].lca != u ? dfo[u] : dfi[u]; q[id].r = dfi[to]; } } void ask(int root = 1) { dfs(root, BS = 0), BS = sqrt(BS); sort(q.begin(), q.end()); L = 0, R = -1; for (int i = 0; i &lt; q.size(); ++i) { while (L &lt; q[i].l) rev(dfp[L++]); while (L &gt; q[i].l) rev(dfp[--L]); while (R &lt; q[i].r) rev(dfp[++R]); while (R &gt; q[i].r) rev(dfp[R--]); if (q[i].lca != dfp[L]) rev(q[i].lca); cal(q[i].id); if (q[i].lca != dfp[L]) rev(q[i].lca); } }}; 树上带修莫队使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980struct CapitalTreeMo : Graph{ struct Update { int pos, NEW, OLD; }; struct Query { int t, l, r, lca, id; bool operator&lt;(const Query &amp;b) const { return l / BS != b.l / BS ? l &lt; b.l : r / BS != b.r / BS ? r &lt; b.r : t &lt; b.t; //在BZOJ4129上去掉r/BS还快100ms? } }; vector&lt;Update&gt; cq; vector&lt;Query&gt; q; vector&lt;int&gt; dfp, dfi, dfo; UnionFindSet ufs; Graph h; int T, L, R; CapitalTreeMo(int n) : cq(1), Graph(n), h(n), dfp(n * 2 + 1), dfi(n), dfo(n), ufs(n) {} void query(int x, int y) { h.add(Edge{x, y}), h.add(Edge{y, x}); q.push_back(Query{cq.size() - 1, 0, 0, 0, q.size()}); } void update(int x, int y) { cq.push_back(Update{x, y, t[x]}), t[x] = y; } void dfs(int u, int &amp;cnt) { dfp[dfi[u] = ++cnt] = u; for (int i = 0, k, to; i &lt; v[u].a.size(); ++i) if (k = v[u].a[i], to = e[k].second, !dfi[to]) dfs(to, cnt), ufs.merge(u, to); dfp[dfo[u] = ++cnt] = u; for (int i = 0, k, to, id; i &lt; h.v[u].a.size(); ++i) if (k = h.v[u].a[i], id = k / 2, to = h.e[k].second, dfo[to]) { q[id].lca = ufs.fa(to); q[id].l = q[id].lca != u ? dfo[u] : dfi[u]; q[id].r = dfi[to]; } } void set(int u, int d) { if (vis[u]) return rev(u), a[u] = d, rev(u); a[u] = d; } void rev(int u) {} void cal(int id) {} void ask(int root = 1) { dfs(root, BS = 0), BS = sqrt(BS); sort(q.begin(), q.end()); T = L = 0, R = -1; for (int i = 0; i &lt; q.size(); ++i) { while (T &lt; q[i].t) ++T, set(cq[T].pos, cq[T].NEW); while (T &gt; q[i].t) set(cq[T].pos, cq[T].OLD), --T; while (L &lt; q[i].l) rev(dfp[L++]); while (L &gt; q[i].l) rev(dfp[--L]); while (R &lt; q[i].r) rev(dfp[++R]); while (R &gt; q[i].r) rev(dfp[R--]); if (q[i].lca != dfp[L]) rev(q[i].lca); cal(q[i].id); if (q[i].lca != dfp[L]) rev(q[i].lca); } }}; 字符串/模式匹配HashString使用示例，如果要修改模数或者直接使用unsigned long long的自然溢出的话直接修改Mod即可。 使用unsigned long long的自然溢出快了5倍，但是容易被卡。 12345678910111213struct HashString : Mod{ vector&lt;ll&gt; f, p; HashString(const string &amp;s, ll M = 1e9 + 7, ll P = 131) : Mod(M), f(s.size() + 1), p(s.size() + 1, 1) { for (int i = 0; i &lt; s.size(); ++i) { f[i + 1] = add(mul(f[i], P), s[i]); p[i + 1] = mul(p[i], P); } } ll ask(int pos, int len) { return add(f[pos + len], -mul(f[pos], p[len])); } //从pos位置开始的长度为len的子串的hash值}; KMP123456789101112131415161718192021222324252627struct KMP{ const string s; vector&lt;int&gt; next; KMP(const string &amp;s) : s(s), next(s.size() + 1, 0) { for (int i = 1, j; i &lt; s.size(); ++i) { for (j = next[i]; j &amp;&amp; s[i] != s[j];) j = next[j]; next[i + 1] = s[i] == s[j] ? j + 1 : 0; } } bool find_in(const string &amp;t) { for (int i = 0, j = 0; i &lt; t.size(); ++i) { while (j &amp;&amp; s[j] != t[i]) j = next[j]; if (s[j] == t[i]) ++j; if (j == s.size()) return 1; //不return可得到t中s的所有匹配地址i+1-s.size() } return 0; }}; AC自动机12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct AhoCorasick{ struct Node { int ch[26], val, f, last; int &amp;to(char c) { return ch[c - 'a']; } //如果不确定c的范围，使用map }; vector&lt;Node&gt; v; AhoCorasick() : v(1) {} void getFail() { for (deque&lt;int&gt; q(1, v[0].last = v[0].f = 0); !q.empty(); q.pop_front()) for (char c = 'a'; c &lt;= 'z'; ++c) { int r = q.front(), u = v[r].to(c), w = v[r].f; if (!r &amp;&amp; u) { q.push_back(u); v[u].f = v[u].last = 0; continue; } if (!u) { v[r].to(c) = v[w].to(c); continue; } q.push_back(u); while (w &amp;&amp; !v[w].to(c)) w = v[w].f; v[u].f = v[w].to(c); v[u].last = v[v[u].f].val ? v[u].f : v[v[u].f].last; } } void add(const string &amp;s, int val, int u = 0) { for (int i = 0; i &lt; s.size(); u = v[u].to(s[i++])) if (!v[u].to(s[i])) { v[u].to(s[i]) = v.size(); v.push_back(Node()); } v[u].val = val; } bool find_in(const string &amp;s, int u = 0) //调用需要调用`getFail()`生成失配函数。 { for (int i = 0; i &lt; s.size(); ++i) if (u = v[u].to(s[i]), v[u].val || v[u].last) return 1; return 0; }}; 暴力回文使用示例 时间复杂度$O(n^2)$，常数低，但会被ababababa这样的数据卡。 1234567891011121314int palindrome(const char *s){ int ans = 0; for (int i = 0, b, e; s[i]; ++i) { for (b = i; s[i] == s[i + 1];) ++i; for (e = i + 1; b &amp;&amp; s[b - 1] == s[e];) --b, ++e; if (ans &lt; e - b) ans = e - b; //此时[b,e)为最大回文区间 } return ans;} 线性回文使用示例 对于一个位置i，[i−f[i]+1,i+f[i]−1]是最长的以i为中心的奇回文串，g[i]−i是最长的以i为开头的回文串长度。 1234567891011121314151617181920212223242526272829303132struct Manacher{ vector&lt;int&gt; t, f, g; Manacher(const string &amp;s) : t(s.size() + 1 &lt;&lt; 1, 0), f(t), g(t) //t初始值为s中没有出现过的值，g开始为0 { for (int i = 0; i &lt; s.size(); ++i) t[i + 1 &lt;&lt; 1] = s[i]; for (int i = 1, p = 0, m = 0; i &lt; t.size(); ++i) { for (f[i] = i &lt; m ? min(f[2 * p - i], m - i) : 1; 0 &lt; i - f[i] &amp;&amp; i + f[i] &lt; t.size() &amp;&amp; t[i - f[i]] == t[i + f[i]];) ++f[i]; if (m &lt; i + f[i]) m = i + f[p = i]; } for (int i = 2; i &lt; t.size(); ++i) if (g[i - f[i] + 1] &lt; i + 1) g[i - f[i] + 1] = i + 1; for (int i = 1; i &lt; t.size(); ++i) if (g[i] &lt; g[i - 1]) g[i] = g[i - 1]; } int ask(int l, int r) //多次询问可做一个ST表 { int ans = 0; for (int i = l + 1 &lt;&lt; 1, e = r + 1 &lt;&lt; 1; i &lt;= e; i += 2) if (ans &lt; g[i] - i) ans = g[i] - i; return ans; }}; 后缀自动机使用示例 m：字符集大小。 s：字符串，其中最后一位为加入的0。 sa[i]：字典序第i小的是哪个后缀。 rk[i]：后缀i的排名。 h[i]：lcp(sa[i],sa[i−1])。 12345678910111213141516171819202122232425262728293031323334struct SufArr{ vector&lt;int&gt; sa, rk, h; SufArr(const vector&lt;int&gt; &amp;s, int m) : sa(s.size(), 0), rk(s), h(s.size(), 0) { vector&lt;int&gt; cnt(s.size() + m, 0); for (int i = 0; i &lt; s.size(); ++i) ++cnt[rk[i]]; for (int i = 1; i &lt; m; ++i) cnt[i] += cnt[i - 1]; for (int i = 0; i &lt; s.size(); ++i) sa[--cnt[rk[i]]] = i; for (int k = 1, j = 0; k &lt;= s.size() &amp;&amp; j &lt; s.size() - 1; k &lt;&lt;= 1) { for (int i = 0; i &lt; s.size(); ++i) { if (j = sa[i] - k, j &lt; 0) j += s.size(); h[cnt[rk[j]]++] = j; } cnt[0] = sa[h[0]] = j = 0; for (int i = 1; i &lt; s.size(); ++i) { if (rk[h[i]] != rk[h[i - 1]] || rk[h[i] + k] != rk[h[i - 1] + k]) cnt[++j] = i; sa[h[i]] = j; } swap(rk, sa), swap(sa, h); } for (int i = 0, k = 0, j = rk[0]; i &lt; s.size() - 1; ++i, ++k) for (; ~k &amp;&amp; s[i] != s[sa[j - 1] + k]; j = rk[sa[j] + 1], --k) h[j] = k; }};","link":"/2019/02/03/2019-02-03-数据结构/"},{"title":"计算几何","text":"二维点和向量化为坐标Coord进行运算，使用stl中的complex实现。 复数相乘的几何意义为长度相乘，极角相加。 用直线上的一点p和方向向量v表示一条经过p的直线，直线上的所有点q满足q=p+t*v，其中t是参数；当限制t≥0时，该参数方程表示射线；限制0≤t≤1时，该参数方程表示线段。 此外，如果已知线段端点a1和a2，可以通过Line(a1,a2-a1)来得到对应的参数形式。 Morley定理：三角形每个内角的三等分线相交成等边三角形。 欧拉定理：平面图的点数V、边数E和面数F满足V+F-E=2。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370typedef double lf;typedef complex&lt;lf&gt; Coord;const lf EPS = 1e-9, PI = acos(-1);#define X real()#define Y imag()struct Line{ Coord p, v; Line(Coord p = Coord(), Coord v = Coord()) : p(p), v(v) {} Coord point(lf t) const { return p + v * t; }};struct Circle{ Coord c; lf r; Circle(Coord c = Coord(), lf r = 0) : c(c), r(r) {} Coord point(lf t) const { return c + polar(r, t); } //t为参数，幅角};/*Coord(lf x=0,lf y=0);//构造函数lf real(Coord a);//a的实部（复平面的横坐标）,也可写作a.real()lf imag(Coord a);//a的虚部（复平面的纵坐标）,也可写作a.imag()lf abs(Coord a);//向量a的模长，或是点a到原点的距离lf norm(Coord a);//abs的平方，比abs快，但是要注意浮点数精度溢出lf arg(Coord a);//a的幅角，与atan2(a.real(),a.imag())等价Coord polar(lf r,lf t);//极坐标生成方式，r为幅值，t为幅角//运算符重载+、-、*、/（以及对应的赋值运算，但是赋值运算不能写在表达式中，详见参考地址）、&lt;&lt;、&gt;&gt;（输出括号形式的坐标）*/int sgn(lf d) { return (d &gt; EPS) - (d &lt; -EPS); }bool operator!=(const Coord &amp;A, const Coord &amp;B) { return sgn(A.X - B.X) || sgn(A.Y - B.Y); } //不等运算符，涉及到浮点数比较要重写bool operator==(const Coord &amp;A, const Coord &amp;B) { return !(A != B); }bool cmpCoord(const Coord &amp;A, const Coord &amp;B) { return sgn(A.X - B.X) ? sgn(A.X - B.X) &lt; 0 : sgn(A.Y - B.Y) &lt; 0; } //复数没有小于运算，只能这样定义一个比较函数bool cmpLine(const Line &amp;A, const Line &amp;B) { return sgn(arg(A.v) - arg(B.v)) &lt; 0; } //按极角排序，求凸包中使用lf Dot(const Coord &amp;A, const Coord &amp;B) { return A.X * B.X + A.Y * B.Y; }lf Cross(const Coord &amp;A, const Coord &amp;B) { return A.X * B.Y - B.X * A.Y; }lf Angle(const Coord &amp;A, const Coord &amp;B) { return acos(Dot(A, B) / abs(A) / abs(B)); }lf Area2(const Coord &amp;A, const Coord &amp;B, const Coord &amp;C) { return Cross(B - A, C - A); } //三角形ABC有向面积的两倍Coord Rotate(const Coord &amp;A, lf rad) { return A * polar(1.0, rad);} //向量A逆时针旋转rad弧度Coord Normal(const Coord &amp;A) //A的法向量，把A逆时针旋转九十度并长度化为1{ lf L = abs(A); return Coord(-A.Y / L, A.X / L);}bool onLeft(const Coord &amp;P, const Line &amp;L) { return sgn(Cross(L.v, P - L.p)) &gt; 0; } //p是否在有向直线L左侧，不含线上lf DistanceToLine(const Coord &amp;P, const Line &amp;L) { return Cross(L.v, P - L.p) / abs(L.v); } //点到直线距离（有向）lf DistanceToLine(const Coord &amp;P, const Coord &amp;A, const Coord &amp;B) { return DistanceToLine(P, Line(A, B - A)); }lf DistanceToSegment(const Coord &amp;P, const Coord &amp;A, const Coord &amp;B) //点到线段的距离（无向）{ if (A == B) return abs(P - A); Coord v1 = B - A, v2 = P - A, v3 = P - B; if (sgn(Dot(v1, v2)) &lt; 0) return abs(v2); if (sgn(Dot(v1, v3)) &gt; 0) return abs(v3); return fabs(DistanceToLine(P, Line(A, B - A)));}Coord getLineProjection(const Coord &amp;P, const Line &amp;L) { return L.point(Dot(L.v, P - L.p) / norm(L.v)); } //点在直线上的投影Coord getLineProjection(const Coord &amp;P, const Coord &amp;A, const Coord &amp;B) { return getLineProjection(P, Line(A, B - A)); }Coord getSymmetry(const Coord &amp;P, const Coord &amp;O) { return O + O - P; } //P关于O的对称点Coord getSymmetry(const Coord &amp;P, const Line &amp;L) { return getSymmetry(P, getLineProjection(P, L)); } //P关于L的对称点Coord getLineIntersection(const Line &amp;L1, const Line &amp;L2) { return L1.point(Cross(L2.v, L1.p - L2.p) / Cross(L1.v, L2.v)); } //直线交点,须确保两直线相交Coord getLineIntersection(const Coord &amp;A1, const Coord &amp;A2, const Coord &amp;B1, const Coord &amp;B2) { return getLineIntersection(Line(A1, A2 - A1), Line(B1, B2 - B1)); }bool SegmentProperIntersection(const Coord &amp;A1, const Coord &amp;A2, const Coord &amp;B1, const Coord &amp;B2) //线段相交判定，交点不在一条线段的端点{ lf C1 = Cross(A2 - A1, B1 - A1), C2 = Cross(A2 - A1, B2 - A1), C3 = Cross(B2 - B1, A1 - B1), C4 = Cross(B2 - B1, A2 - B1); return sgn(C1) * sgn(C2) &lt; 0 &amp;&amp; sgn(C3) * sgn(C4) &lt; 0;}bool onSegment(const Coord &amp;P, const Coord &amp;A1, const Coord &amp;A2) { return sgn(Dot(A1 - P, A2 - P)) &lt; 0 &amp;&amp; !sgn(Cross(A1 - P, A2 - P)); } //判断点是否在线段上，不包含端点lf PolygonArea(const vector&lt;Coord&gt; &amp;p) //计算多边形的有向面积，凸多边形即为面积{ lf s = 0; for (int i = 2; i &lt; p.size(); ++i) s += Area2(p[0], p[i - 1], p[i]); return s / 2;}int inPolygon(const Coord &amp;p, const vector&lt;Coord&gt; &amp;poly) //点在多边形内的判定，转角法，正值为内部，0为外部，-1在边界上{ int ans = 0; for (int i = 0, k, d1, d2, n = poly.size(); i != n; ++i) { if (onSegment(p, poly[i], poly[(i + 1) % n])) return -1; //在边界上 k = sgn(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); d1 = sgn(poly[i].Y - p.Y); d2 = sgn(poly[(i + 1) % n].Y - p.Y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) ++ans; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) --ans; } return ans;}vector&lt;Coord&gt; ConvexHull(vector&lt;Coord&gt; p, int collineation = 1) //获得凸包，不希望凸包的边上有输入点第二个参数传0{ vector&lt;Coord&gt; ans; sort(p.begin(), p.end(), cmpCoord); //先比横坐标再比纵坐标 for (int i = 0; i &lt; p.size(); ++i) //求出下凸包 { while (ans.size() &gt; 1 &amp;&amp; sgn(Area2(ans[ans.size() - 2], ans[ans.size() - 1], p[i])) &lt; collineation) ans.pop_back(); ans.push_back(p[i]); } for (int i = p.size() - 2, k = ans.size(); i &gt;= 0; --i) //求出上凸包 { while (ans.size() &gt; k &amp;&amp; -sgn(Area2(ans[ans.size() - 1], ans[ans.size() - 2], p[i])) &lt; collineation) ans.pop_back(); ans.push_back(p[i]); } if (p.size() &gt; 1) ans.pop_back(); return ans;}vector&lt;Coord&gt; cutPolygon(const vector&lt;Coord&gt; &amp;poly, const Coord &amp;A, const Coord &amp;B) //用有向直线A-&gt;B切割多边形poly， 返回“左侧”。 如果退化，可能会返回一个单点或者线段，复杂度O(n^2){ vector&lt;Coord&gt; newpoly; for (int i = 0, n = poly.size(); i != n; ++i) { Coord C = poly[i], D = poly[(i + 1) % n]; if (sgn(Cross(B - A, C - A)) &gt;= 0) newpoly.push_back(C); if (!sgn(Cross(B - A, C - D))) { Coord ip = getLineIntersection(Line(A, B - A), Line(C, D - C)); if (onSegment(ip, C, D)) newpoly.push_back(ip); } } return newpoly;}vector&lt;Coord&gt; getHalfPlaneIntersection(vector&lt;Line&gt; L) //半平面交{ sort(L.begin(), L.end(), cmpLine); //按极角排序 vector&lt;Coord&gt; p(L.size(), Coord()); //p[i]为q[i]和q[i+1]的交点 int first = 0, last = 0; //双端队列的第一个元素和最后一个元素 vector&lt;Line&gt; q(L.size(), Line()); //双端队列 q[0] = L[0]; //队列初始化为只有一个半平面L[0] for (int i = 0, n = L.size(); i != n; ++i) { while (first &lt; last &amp;&amp; !onLeft(p[last - 1], L[i])) --last; while (first &lt; last &amp;&amp; !onLeft(p[first], L[i])) ++first; q[++last] = L[i]; if (!sgn(Cross(q[last].v, q[last - 1].v))) { --last; if (onLeft(L[i].p, q[last])) q[last] = L[i]; } if (first &lt; last) p[last - 1] = getLineIntersection(q[last - 1], q[last]); } while (first &lt; last &amp;&amp; !onLeft(p[last - 1], q[first])) --last; //删除无用平面 if (last - first &lt;= 1) return vector&lt;Coord&gt;(); //空集 p[last] = getLineIntersection(q[last], q[first]); return vector&lt;Coord&gt;(p.begin() + first, p.begin() + last + 1); //从deque复制到输出中}int getLineCircleIntersection(const Line &amp;L, const Circle &amp;C, vector&lt;Coord&gt; &amp;sol){ lf a = L.v.X, b = L.p.X - C.c.X, c = L.v.Y, d = L.p.Y - C.c.Y, e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r, delta = f * f - 4 * e * g; if (sgn(delta) &lt; 0) return 0; if (!sgn(delta)) return sol.push_back(L.point(-f / (2 * e))), 1; sol.push_back(L.point((-f - sqrt(delta)) / (2 * e))); sol.push_back(L.point((-f + sqrt(delta)) / (2 * e))); return 2;}int getCircleIntersection(const Circle &amp;C1, const Circle &amp;C2, vector&lt;Coord&gt; &amp;sol){ lf d = abs(C1.c - C2.c); if (!sgn(d)) return sgn(C1.r - C2.r) ? 0 : -1; //重合返回-1 if (sgn(C1.r + C2.r - d) &lt; 0 || sgn(fabs(C1.r - C2.r) - d) &gt; 0) //外离或内含 return 0; lf a = arg(C2.c - C1.c), da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d)); Coord p1 = C1.point(a - da), p2 = C1.point(a + da); sol.push_back(p1); if (p1 == p2) return 1; //相切 return sol.push_back(p2), 2;}Line getTangent(const Coord &amp;C, const Coord &amp;P) { return Line(P, Normal(C - P)); } //圆心C，圆上一点P处切线int getTangents(const Coord &amp;p, const Circle &amp;C, vector&lt;Coord&gt; &amp;sol) //点到圆的切点，返回个数{ Coord u = p - C.c; lf d = abs(u); if (d &lt; C.r) return 0; //点在圆内 if (!sgn(d - C.r)) //点在圆上 return sol.push_back(p), 1; lf base = arg(u), ang = acos(C.r / d); sol.push_back(C.point(base + ang)); sol.push_back(C.point(base - ang)); return 2;}int getTangents(Circle A, Circle &amp;B, vector&lt;Coord&gt; &amp;a, vector&lt;Coord&gt; &amp;b) //公共切线的切点{ int cnt = 0; if (A.r &lt; B.r) swap(A, B), swap(a, b); //有时需标记交换 lf d = abs(A.c - B.c), rdiff = A.r - B.r, rsum = A.r + B.r; if (sgn(d - rdiff) &lt; 0) return 0; //内含 lf base = arg(B.c - A.c); if (!sgn(d) &amp;&amp; !sgn(rdiff)) return -1; //重合，无穷多条切线 if (!sgn(d - rdiff)) //内切，外公切线 { a.push_back(A.point(base)); b.push_back(B.point(base)); return 1; } //有外公切线的情形 lf ang = acos(rdiff / d); a.push_back(A.point(base + ang)); b.push_back(B.point(base + ang)); a.push_back(A.point(base - ang)); b.push_back(B.point(base - ang)); cnt += 2; if (!sgn(d - rsum)) { a.push_back(A.point(base)); b.push_back(B.point(base + PI)); ++cnt; } else if (sgn(d - rsum) &gt; 0) { lf ang_in = acos(rsum / d); a.push_back(A.point(base + ang_in)); b.push_back(B.point(base + ang_in + PI)); a.push_back(A.point(base - ang_in)); b.push_back(B.point(base - ang_in + PI)); cnt += 2; } return cnt;}lf AreaCircleWithTriangle(const Circle &amp;C, Coord A, Coord B) //C和三角形OAB的相交面积，如果三角形顶点不在O上则把圆和三角形同时平移，直到有一个顶点在O上{ int sg = sgn(Cross(A, B)); if (!sg || A == C.c || B == C.c) return 0; lf OA = abs(A - C.c), OB = abs(B - C.c), angle = Angle(A, B), d = DistanceToLine(Coord(), A, B); if (sgn(OA - C.r) &lt;= 0 &amp;&amp; sgn(OB - C.r) &lt;= 0) return Cross(A, B) / 2; if (sgn(OA - C.r) &gt;= 0 &amp;&amp; sgn(OB - C.r) &gt;= 0 &amp;&amp; sgn(d - C.r) &gt;= 0) return sg * C.r * C.r * angle / 2; if (sgn(OA - C.r) &gt;= 0 &amp;&amp; sgn(OB - C.r) &gt;= 0 &amp;&amp; sgn(d - C.r) &lt; 0) { Coord prj = getLineProjection(Coord(), A, B); if (!onSegment(prj, A, B)) return sg * C.r * C.r * angle / 2; vector&lt;Coord&gt; p; Line L = Line(A, B - A); getLineCircleIntersection(L, C, p); lf s1 = C.r * C.r * angle / 2, s2 = C.r * C.r * Angle(p[0], p[1]) / 2; s2 -= fabs(Cross(p[0], p[1]) / 2); s1 = s1 - s2; return sg * s1; } if (sgn(OB - C.r) &lt; 0) swap(A, B); Line L = Line(A, B - A); vector&lt;Coord&gt; inter; getLineCircleIntersection(L, C, inter); Coord inter_point = inter[!onSegment(inter[0], A, B)]; lf s = fabs(Cross(inter_point, A) / 2); s += C.r * C.r * Angle(inter_point, B) / 2; return s * sg;}lf AreaCircleWithPolygon(const Circle &amp;C, const vector&lt;Coord&gt; &amp;p){ lf ans = 0; for (int i = 0; i &lt; p.size(); ++i) ans += AreaCircleWithTriangle(C, p[i], p[(i + 1) % p.size()]); return fabs(ans);}Coord getGravityCenter(const vector&lt;Coord&gt; &amp;p) //多边形重心{ Coord a(0, 0); lf am = 0, mj; for (int i = 0; i &lt; p.size(); ++i) { mj = Cross(p[i], p[(i + 1) % p.size()]); a += mj * (p[i] + p[(i + 1) % p.size()]); am += mj; } return a / am / 3.0;} 三维123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177typedef double lf;const lf EPS = 1e-9, INF = 1e9, PI = acos(-1);int sgn(lf d) { return (d &gt; EPS) - (d &lt; -EPS); }struct Coord3{ lf X, Y, Z; friend bool operator!=(const Coord3 &amp;a, const Coord3 &amp;b) { return sgn(a.X - b.X) || sgn(a.Y - b.Y) || sgn(a.Z - b.Z); } friend bool operator==(const Coord3 &amp;a, const Coord3 &amp;b) { return !(a != b); } Coord3 &amp;operator+=(const Coord3 &amp;b) { return X += b.X, Y += b.Y, Z += b.Z, *this; } friend Coord3 operator+(Coord3 a, const Coord3 &amp;b) { return a += b; } Coord3 &amp;operator-=(const Coord3 &amp;b) { return X -= b.X, Y -= b.Y, Z -= b.Z, *this; } friend Coord3 operator-(Coord3 a, const Coord3 &amp;b) { return a -= b; } Coord3 &amp;operator*=(lf d) { return X *= d, Y *= d, Z *= d, *this; } friend Coord3 operator*(Coord3 a, lf d) { return a *= d; } friend Coord3 operator*(lf d, Coord3 a) { return a *= d; } Coord3 &amp;operator/=(lf d) { return X /= d, Y /= d, Z /= d, *this; } friend Coord3 operator/(Coord3 a, lf d) { return a /= d; } friend lf Dot(const Coord3 &amp;A, const Coord3 &amp;B) { return A.X * B.X + A.Y * B.Y + A.Z * B.Z; } friend Coord3 Cross(const Coord3 &amp;A, const Coord3 &amp;B) { return {A.Y * B.Z - A.Z * B.Y, A.Z * B.X - A.X * B.Z, A.X * B.Y - A.Y * B.X}; } friend lf norm(const Coord3 &amp;A) { return Dot(A, A); } friend lf abs(const Coord3 &amp;A) { return sqrt(norm(A)); } friend lf Angle(const Coord3 &amp;A, const Coord3 &amp;B) { return acos(Dot(A, B) / abs(A) / abs(B)); } friend lf Area2(Coord3 A, Coord3 B, Coord3 C) { return abs(Cross(B - A, C - A)); } friend lf Volume6(Coord3 A, Coord3 B, Coord3 C, Coord3 D) { return Dot(D - A, Cross(B - A, C - A)); } //四面体体积 friend Coord3 Centroid(Coord3 A, Coord3 B, Coord3 C, Coord3 D) { return (A + B + C + D) / 4.0; } //四面体的重心 friend lf DistanceToPlane(Coord3 p, Coord3 p0, const Coord3 &amp;n) { return Dot(p - p0, n) / abs(n); } //点p到平面p0-n的有向距离 friend Coord3 getPlaneProjection(Coord3 p, Coord3 p0, const Coord3 &amp;n) { return p - n * Dot(p - p0, n); } //点p在平面p0-n上的投影。n必须为单位向量 friend Coord3 LinePlaneIntersection(Coord3 p1, Coord3 p2, Coord3 p0, Coord3 n) //直线p1-p2 与平面p0-n的交点，假设交点唯一存在 { Coord3 v = p2 - p1; lf t = Dot(n, p0 - p1) / Dot(n, p2 - p1); //分母为0，直线与平面平行或在平面上 return p1 + v * t; //如果是线段 判断t是否在0~1之间 } friend lf DistanceToLine(Coord3 P, Coord3 A, Coord3 B) //点P到直线AB的距离 { Coord3 v1 = B - A, v2 = P - A; return abs(Cross(v1, v2)) / abs(v1); } friend lf DistanceToSeg(Coord3 P, Coord3 A, Coord3 B) //点到线段的距离 { if (A == B) return abs(P - A); Coord3 v1 = B - A, v2 = P - A, v3 = P - B; if (sgn(Dot(v1, v2)) &lt; 0) return abs(v2); if (sgn(Dot(v1, v3)) &gt; 0) return abs(v3); return fabs(DistanceToLine(P, A, B)); } friend bool LineDistance3D(Coord3 p1, Coord3 u, Coord3 p2, Coord3 v, lf &amp;s) //求异面直线 p1+s*u与p2+t*v的公垂线对应的s，如果平行|重合，返回0 { lf b = Dot(u, u) * Dot(v, v) - Dot(u, v) * Dot(u, v); if (!sgn(b)) return 0; lf a = Dot(u, v) * Dot(v, p1 - p2) - Dot(v, v) * Dot(u, p1 - p2); return s = a / b, 1; } friend bool SameSide(Coord3 p1, Coord3 p2, Coord3 a, Coord3 b) { return sgn(Dot(Cross(b - a, p1 - a), Cross(b - a, p2 - a))) &gt;= 0; } //p1和p2是否在线段a-b的同侧 friend bool PointInTri(Coord3 PP, Coord3 P[3]) //点P在三角形P0,P1,p中 { return SameSide(PP, P[0], P[1], P[2]) &amp;&amp; SameSide(PP, P[1], P[0], P[2]) &amp;&amp; SameSide(PP, P[2], P[0], P[1]); } friend bool TriSegIntersection(Coord3 P[3], Coord3 A, Coord3 B, Coord3 &amp;PP) //三角形P0P1p是否和线段AB相交，如有则为PP { Coord3 n = Cross(P[1] - P[0], P[2] - P[0]); if (sgn(Dot(n, B - A)) == 0) return false; //线段A-B和平面P0P1p平行或共面 lf t = Dot(n, P[0] - A) / Dot(n, B - A); //平面A和直线P1-p有惟一交点 if (sgn(t) &lt; 0 || sgn(t - 1) &gt; 0) return false; //不在线段AB上 return PointInTri(PP = A + (B - A) * t, P); } friend bool TriTriIntersection(Coord3 T1[3], Coord3 T2[3]) //空间两三角形是否相交 { Coord3 P; for (int i = 0; i &lt; 3; ++i) if (TriSegIntersection(T1, T2[i], T2[(i + 1) % 3], P) || TriSegIntersection(T2, T1[i], T1[(i + 1) % 3], P)) return 1; return 0; } friend lf SegSegDistance(Coord3 a1, Coord3 b1, Coord3 a2, Coord3 b2, Coord3 &amp;ans1, Coord3 &amp;ans2) //空间两直线上最近点对 返回最近距离 点对保存在ans1 ans2中 { Coord3 v1 = (a1 - b1), v2 = (a2 - b2); Coord3 N = Cross(v1, v2); Coord3 ab = (a1 - a2); lf ans = Dot(N, ab) / abs(N); Coord3 d1 = b1 - a1, d2 = b2 - a2, cd = Cross(d1, d2); lf nd = norm(cd), t1 = Dot(Cross(a2 - a1, d2), cd) / nd, t2 = Dot(Cross(a2 - a1, d1), cd) / nd; return ans1 = a1 + (b1 - a1) * t1, ans2 = a2 + (b2 - a2) * t2, fabs(ans); } friend bool InsideWithMinDistance(Coord3 PP, Coord3 *P, lf dist) //判断PP是否在三角形P中，并且到三条边的距离都至少为dist。保证P,A,B,C共面 { return PointInTri(PP, P) &amp;&amp; DistanceToLine(PP, P[0], P[1]) &gt;= dist || DistanceToLine(PP, P[1], P[2]) &gt;= dist || DistanceToLine(PP, P[2], P[0]) &gt;= dist; }};struct Sphere{ Coord3 o; lf r; Coord3 point(lf lat, lf lng) const //经纬度确定球面上一点 { lat *= PI / 180; lng *= PI / 180; return o + r * Coord3{cos(lat) * cos(lng), cos(lat) * sin(lng), sin(lat)}; }};struct ConvexPolyhedron //空间多边形和凸包问题{ struct Face { int v[3]; Face(int a, int b, int c) { v[0] = a, v[1] = b, v[2] = c; } Coord3 Normal(const vector&lt;Coord3&gt; &amp;P) const { return Cross(P[v[1]] - P[v[0]], P[v[2]] - P[v[0]]); } bool CanSee(const vector&lt;Coord3&gt; &amp;P, int i) const { return Dot(P[i] - P[v[0]], Normal(P)) &gt; 0; } //f是否能看见P[i] }; vector&lt;Face&gt; faces; vector&lt;Coord3&gt; p; ConvexPolyhedron(vector&lt;Coord3&gt; P) : p(P) { for (int i = 0; i &lt; p.size(); ++i) P[i] += Coord3{randEPS(), randEPS(), randEPS()}; vector&lt;vector&lt;int&gt;&gt; vis(P.size(), vector&lt;int&gt;(P.size())); faces.push_back(Face(0, 1, 2)); //由于已经进行扰动，前三个点不共线 faces.push_back(Face(2, 1, 0)); for (int i = 3; i &lt; P.size(); ++i) { vector&lt;Face&gt; next; for (int j = 0; j &lt; faces.size(); ++j) //计算每条边的“左面”的可见性 { Face &amp;f = faces[j]; int res = f.CanSee(P, i); if (!res) next.push_back(f); for (int k = 0; k &lt; 3; ++k) vis[f.v[k]][f.v[(k + 1) % 3]] = res; } for (int j = 0; j &lt; faces.size(); ++j) for (int k = 0; k &lt; 3; ++k) { int a = faces[j].v[k], b = faces[j].v[(k + 1) % 3]; if (vis[a][b] != vis[b][a] &amp;&amp; vis[a][b]) //(a,b)是分界线，左边对P[i]可见 next.push_back(Face(a, b, i)); } swap(faces, next); } } lf randEPS() { return (rand() / lf(RAND_MAX) - 0.5) * EPS; } Coord3 centroid() //三维凸包重心 { Coord3 C = p[0], tot{0, 0, 0}; lf totv = 0; for (int i = 0; i &lt; faces.size(); ++i) { Coord3 p1 = p[faces[i].v[0]], p2 = p[faces[i].v[1]], p3 = p[faces[i].v[2]]; lf v = -Volume6(p1, p2, p3, C); totv += v; tot += v * Centroid(p1, p2, p3, C); } return tot / totv; } lf dist(Coord3 C) //凸包内一点到表面最近距离 { lf ans = INF; for (int i = 0; i &lt; faces.size(); ++i) { Coord3 p1 = p[faces[i].v[0]], p2 = p[faces[i].v[1]], p3 = p[faces[i].v[2]]; ans = min(ans, fabs(-Volume6(p1, p2, p3, C) / Area2(p1, p2, p3))); } return ans; }};","link":"/2019/02/03/2019-02-03-计算几何/"},{"title":"概率论与数理统计","text":"参考斯坦福大学2014（吴恩达）机器学习教程中文笔记，感谢编者黄海广博士。 概率论的基本概念随机试验在概率论中，将具有以下三个特点的事件称为随机试验： 可以在相同的条件下重复进行 每次试验的可能结果不止一个，并且事先能够明确事件的所有可能结果 进行一次试验前不能确定哪个结果会出现 样本空间、随机事件样本空间随机事件$E$的所有基本结果组成的集合为$E$的样本空间，记为$S$。样本空间的元素，即$E$的每个结果，称为样本点或基本事件，有时记为$\\omega$。 随机事件称试验$E$的样本空间$S$的子集为$E$的随机事件，简称事件。在每次试验中，当且仅当这一子集中的一个样本点出现时，称这一事件发生。特别地，由一个样本点组成的单点集，称为基本事件；样本空间$S$包含所有的基本点，每次试验中总是发生，称为必然事件，记为$\\Omega$；空集$\\varnothing$每次都不可能发生，称为不可能事件。 事件间的关系与事件的运算子事件$A \\subset B$，若$A$发生，则$B$发生。 相等事件$A = B$，即$A \\subset B$，且$B \\subset A$ 。 和事件$A\\bigcup B$（或$A + B$），$A$与$B$中至少有一个发生。 差事件$A - B={x|x\\in A,x\\not\\in B}$，$A$发生但$B$不发生。 积事件$A\\bigcap B$（或${AB}$），$A$与$B$同时发生。 互斥事件（互不相容）$A\\bigcap B$=$\\varnothing$。基本事件是两两互斥的。 互逆事件（对立事件）$A\\bigcap B=\\varnothing ,A\\bigcup B=\\Omega ,A=\\overline{B},B=\\overline{A}$ 完全事件组${ {A}{1} }{ {A}{2} }\\cdots { {A}{n} }$两两互斥，且和事件为必然事件，即$A_i\\bigcap A_j=\\varnothing,i\\ne j,\\bigcap{i=1}^n=\\Omega$ 交换律$A\\bigcup B=B\\bigcup A,A\\bigcap B=B\\bigcap A$ 结合律$(A\\bigcup B)\\bigcup C=A\\bigcup (B\\bigcup C)$ 分配律$(A\\bigcap B)\\bigcap C=A\\bigcap (B\\bigcap C)$ 德·摩根律$\\overline{A\\bigcup B}=\\overline{A}\\bigcap \\overline{B}$$\\overline{A\\bigcap B}=\\overline{A}\\bigcup \\overline{B}$ 频率与概率频率定义相同条件下进行了n次试验，在这n次试验当中，事件A发生的频率$n_A$称为事件A的频数，比值$f_n(A)=\\frac{n_A}{n}$称为事件A发生的频率。 性质 $0\\leq f_n(A)\\leq 1$ $f_n(S)=1$ 有限可加性：若$A_1,A_2,\\ldots,a_k$是两两互不相容的事件，则$f_n(A_1\\bigcup A_2\\bigcup\\ldots\\bigcup A_k)=f_n(A_1)+f_n(A_2)+\\ldots+f_n(A_k)$ 概率定义设E是随机试验，S是它的样本空间，对于E的每一事件A赋予一个实数$P(A)$，称为事件A的概率，如果集合函数$P(\\cdot)$满足下列条件： 非负性对于每一事件A，有$P(A)\\ge 0$ 规范性对于必然事件S，有$P(S)=1$ 可列可加性设$A_1,A_2,\\ldots$是两两互不相容的事件，则$P(A_1\\bigcup A_2\\bigcup\\ldots)=P(A_1)+P(A_2)+\\ldots$ 性质 $P(\\varnothing)=0$ 有限可加性：$P(A_1\\bigcup A_2\\bigcup\\ldots\\bigcup A_n)=P(A_1)+P(A_2)+\\ldots+P(A_n)$，可由上一条性质和可列可加性推出。 若$A\\subset B$，则$P(B-A)=P(B)-P(A)\\ge 0$ $P(A)\\le 1$ 逆事件的概率：$P(\\overline{A})=1-P(A)$ 加法公式：$P(A\\bigcup B)=P(A)+P(B)-P(AB)$，推广到三元：$P(A\\bigcup B\\bigcup C)=P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)$ $P(A-B)=P(A)-P(AB)$ $P(A\\overline{B})=P(A)-P(AB)$ $P(A)=P(AB)+P(A\\overline{B})$ $P(A\\bigcup B)=P(A)+P(\\overline{A}B)=P(AB)+P(A\\overline{B})+P(\\overline{A}B)$ 等可能概型（古典概型）具备以下两个特点的试验被称作等可能概型（古典概型）： 试验的样本空间只包含有限个元素 试验中每个基本事件发生的可能性相同 古典概型计算公式$P(A)=\\frac{A包含的基本事件数}{S包含的事件数}$ 实际推断原理概率很小的事件在一次试验中实际上几乎是不发生的。 条件概率条件概率$P(B|A)=\\frac{P(AB)}{P(A)}$,表示$A$发生的条件下，$B$发生的概率。条件概率$P(\\centerdot |B)$满足概率的所有性质，例如： $P({ {\\overline{A} }{1} }|B)=1-P({ {A}{1} }|B)$ $P({ {A}{1} }\\bigcup { {A}{2} }|B)=P({ {A}{1} }|B)+P({ {A}{2} }|B)-P({ {A}{1} }{ {A}{2} }|B)$ $P({ {A}{1} }{ {A}{2} }|B)=P({ {A}{1} }|B)P({ {A}{2} }|{ {A}_{1} }B)$ 非负性对于每一事件$B$，有$P(B|A)\\ge 0$ 规范性对于必然事件$S$，有$P(S|A)=1$ 可列可加性$P(\\underset{i=1}{\\overset{\\infty}{\\mathop{\\bigcup } } },{ {B}{i} }|A)=\\sum{i=1}^\\infty P(B_i|A)$ 乘法定理$P({ {A}{1} }{ {A}{2} })=P({ {A}{1} })P({ {A}{2} }|{ {A}{1} })=P({ {A}{2} })P({ {A}{1} }|{ {A}{2} })$$P({ {A}{1} }{ {A}{2} }\\cdots { {A}{n} })=P({ {A}{1} })P({ {A}{2} }|{ {A}{1} })P({ {A}{3} }|{ {A}{1} }{ {A}{2} })\\cdots P({ {A}{n} }|{ {A}{1} }{ {A}{2} }\\cdots { {A}_{n-1} })$ 全概率公式和贝叶斯公式全概率公式$P(A)=\\sum\\limits_{i=1}^{n}{P(A|{ {B}{i} })P({ {B}{i} }),{ {B}{i} }{ {B}{j} } }=\\varnothing ,i\\ne j,\\underset{i=1}{\\overset{n}{\\mathop{\\bigcup } } },{ {B}_{i} }=\\Omega$ Bayes（贝叶斯）公式$P({ {B}{j} }|A)=\\frac{P(A|{ {B}{j} })P({ {B}{j} })}{\\sum\\limits{i=1}^{n}{P(A|{ {B}{i} })P({ {B}{i} })} },j=1,2,\\cdots ,n$上述公式中事件${ {B}_{i} }$的个数可为可列个。 独立性若干个事件，如果对于其中任意个事件，它们的积事件的概率都等于各事件概率的积，则称这几个事件相互独立。 $A$与$B$相互独立$\\Leftrightarrow P(AB)=P(A)P(B)$ $A$，$B$，$C$两两独立$\\Leftrightarrow P(AB)=P(A)P(B)$;$P(BC)=P(B)P(C)$;$P(AC)=P(A)P(C)$; $A$，$B$，$C$相互独立$\\Leftrightarrow P(AB)=P(A)P(B)$;$P(BC)=P(B)P(C)$;$P(AC)=P(A)P(C)$;$P(ABC)=P(A)P(B)P(C)$ 独立重复试验将某试验独立重复$n$次，若每次试验中事件A发生的概率为$p$，则$n$次试验中$A$发生$k$次的概率为：$P{X=k}=C_{n}^{k}{ {p}^{k} }{ {(1-p)}^{n-k} }$ 性质 若${ {A}{1} },{ {A}{2} },\\cdots ,{ {A}{n} }$相互独立，则$P(\\bigcap\\limits{i=1}^{n}{ { {A}{i} } })=\\prod\\limits{i=1}^{n}{P({ {A}{i} })},$$P(\\bigcup\\limits{i=1}^{n}{ { {A}{i} } })=\\prod\\limits{i=1}^{n}{(1-P({ {A}_{i} }))}$ 若${ {A}{1} },{ {A}{2} },\\cdots ,{ {A}{m} },{ {B}{1} },{ {B}{2} },\\cdots ,{ {B}{n} }$相互独立，则$f({ {A}{1} },{ {A}{2} },\\cdots ,{ {A}{m} })$与$g({ {B}{1} },{ {B}{2} },\\cdots ,{ {B}{n} })$也相互独立，其中$f(\\centerdot ),g(\\centerdot )$分别表示对相应事件做任意事件运算后所得的事件，另外，概率为1（或0）的事件与任何事件相互独立。 互斥、互逆与独立性之间的关系$A$与$B$互逆$\\Rightarrow$ $A$与$B$互斥，但反之不成立，$A$与$B$互斥（或互逆）且均非零概率事件$\\Rightarrow$ $A$与$B$不独立。 随机变量及其分布随机变量设随机试验的样本空间为$S={e}$，称定义在样本空间$S$上的实值单值函数$X=X(e)$为随机变量。 离散型随机变量及其分布律取值有限或可列无限的随机变量称为离散型随机变量。设X的所有取值为$x_k(k=1,2,\\ldots)$，称X取各个事件的概率$P{X=x_k}=p_k,k=1,2,\\ldots$为离散型随机变量X的分布律，也可以写成表格形式： $X$ $x_1$ $x_2$ $\\ldots$ $x_n$ $\\ldots$ $p_k$ $p_1$ $p_2$ $\\ldots$ $p_n$ $\\ldots$ 其中，$p_k$满足： $p_k\\ge 0,k=1,2,\\ldots$ $\\sum_{k=1}^\\infty p_k=1$ 0-1分布（两点分布）$P{X=k} = p^{k}{(1 - p)}^{1 - k},k = 0,1$，则称X服从以p为参数的0-1分布（两点分布） 伯努利试验、二项分布Binomial Distribution（二项分布）背景：n重Bernoulli 试验中，每次试验感兴趣的事件A 在 n 次试验中发生的次数 —— X是一离散型随机变量。若$P(A)=p$,则$P_n(k)=P{X=k}=C_n^kp^k(1-p)^{n-k},k=0,1\\ldots n$称X服从参数为$n, p$的二项分布，记作$X\\sim B(n,p)$特别地，$0 – 1$分布是$n=1$的二项分布. Poisson （泊松）分布背景：已知某事发生速率为每单位时间b次，观察时间为T时间单位，X为该观察时间内发生该事的总次数$\\lambda=bT$设随机变量X的所有可能值是全体非负整数，若$P{X=k}=e^{-\\lambda}\\frac{\\lambda^k}{k!},k=0,1,\\ldots$其中$\\lambda&gt;0$是常数，则称 X 服从参数为$\\lambda$的Poisson 分布，记作$\\pi(\\lambda)$或$P(\\lambda)$ 泊松定理可用于泊松分布逼近二项分布。设随机变量X服从二项分布，其分布律为$P{X=K}=C_n^kp^k(1-p)^{n-k}$,又设$np=\\lambda$是常数，则有$\\lim_{n\\to\\infty}P{X=K}=e^{-\\lambda}\\frac{\\lambda^k}{k!}$在实际计算中,当$n\\ge 20,p\\leq 0.05$时，可用上述公式近似计算；而当$n\\ge 100,np\\leq 10$时，精度更好。 几何分布在n次伯努利试验中，试验k次才得到第一次成功的机率。$G(p):P{X=k} = {(1 - p)}^{k - 1}p,0 &lt; p &lt; 1,k = 1,2,\\cdots,P{X = m + k|X &gt; m} = P{X=k}$ 超几何分布设有产品N件，其中次品D件，其余为正品，从中随机地抽取n件。记X为抽到的的次品件数，求X的分布律.此时抽到k件次品的概率为$H(N,M,n):P{X=k} = \\frac{C_{M}^{k}C_{N - M}^{n -k} }{C_{N}^{n} },k =0,1,\\cdots,min(n,M)$，称X服从超几何分布. 可以证明超几何分布的极限分布就是二项分布. 负二项分布(Pascal分布)离散均匀分布随机变量的分布函数定义$F(x) = P(X \\leq x), - \\infty &lt; x &lt; + \\infty$ 性质 $0 \\leq F(x) \\leq 1$ $F(x)$单调不减 右连续$F(x) = F(x+0)$ $F( - \\infty) = 0,F( + \\infty) = 1$ 连续型随机变量及其概率密度概率密度$f(x)$非负可积，且: $f(x) \\geq 0$ $\\int_{- \\infty}^{+\\infty}{f(x){dx} = 1}$ $x$为$f(x)$的连续点，则:$f(x) = F’(x)$分布函数$F(x) = \\int_{- \\infty}^{x}{f(t){dt} }$ 均匀分布设连续型随机变量X具有概率密度$p(x)=\\begin{cases}\\frac{1}{b-a},a\\leq x\\leq b,\\0,其它\\end{cases}$则称X在$(a,b)$上服从均匀分布，记作$X\\sim U(a,b)$分布函数$F(x)=\\begin{cases}0,x&lt;a\\ \\frac{x-a}{b-a},a\\leq x&lt; b\\1,x\\ge b\\end{cases}$ 指数分布设连续型随机变量X具有概率密度$p(X)=\\begin{cases}\\lambda e^{-\\lambda x},x\\ge 0,\\0,x&lt;0\\end{cases}$，其中$\\lambda &gt;0$为常数，则称X在$(a,b)$上服从指数分布。分布函数$F(x)=\\begin{cases}1-e^{-\\frac{x}{\\theta}},x&gt;0\\0,x\\le 0\\end{cases}$无记忆性：$\\forall s,t&gt;0$，$P{x&gt;s+t|x&gt;s}=p{x&gt;t}$，即，如果T是某一元件的寿命，已知元件使用了s小时，它总共使用至少s+t小时的条件概率，与从开始使用时算起它使用至少t小时的概率相等。 正态分布（高斯分布，Gauss）设连续型随机变量X具有概率密度$p(X)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2} }$则称X服从参数为$\\mu,\\sigma$的正态分布或高斯分布，记作$X\\sim N(\\mu,\\sigma^2)$$\\mu$是位置参数，即固定$\\sigma$，对于不同的$\\mu$，对应的f(x)的形状不变化，只是位置不同。$\\sigma$是形状参数，即固定$\\mu$，对于不同的$\\sigma$，对应f(x)位置不变化，只是$\\sigma$越小，靠近$\\mu$附近取值的概率越大，相应拐点越接近于ox轴。$\\sigma$大小与曲线陡峭程度成反比（几何意义），与数据分散程度成正比（数据意义）。 标准正态分布N(0,1)密度函数$\\varphi(x)=\\frac{1}{\\sqrt{2\\pi} }e^{-\\frac{x^2}{2} }$是偶函数，其分布函数为$\\Phi(x)=\\frac{1}{\\sqrt{2\\pi} }\\int_{-\\infty}^xe^{-\\frac{t^2}{2} },dt$，其值可查表。$\\varphi(0) = \\frac{1}{\\sqrt{2\\pi} },\\Phi(0) =\\frac{1}{2},$ $\\Phi( - a) = P(X \\leq - a) = 1 - \\Phi(a)$$X\\sim N\\left( \\mu,\\sigma^{2} \\right) \\Rightarrow \\frac{X -\\mu}{\\sigma}\\sim N\\left( 0,1 \\right),P(X \\leq a) = \\Phi(\\frac{a -\\mu}{\\sigma})$ 随机变量的函数的分布 离散型：$P(X = x_{1}) = p_{i},Y = g(X)$，则: $P(Y = y_{j}) = \\sum_{g(x_{i}) = y_{i} }^{}{P(X = x_{i})}$ 连续型：$X\\sim f_{X}(x),Y = g(x)$，则:$F_{y}(y) = P(Y \\leq y) = P(g(X) \\leq y) = \\int_{g(x) \\leq y}^{}{f_{x}(x)dx}$， $f_{Y}(y) = F’_{Y}(y)$ 离散型随机变量的分布函数为阶梯间断函数；连续型随机变量的分布函数为连续函数，但不一定为处处可导函数。 存在既非离散也非连续型随机变量。 多维随机变量及其分布二维随机变量由两个随机变量构成的随机向量$(X,Y)$， 联合分布为$F(x,y) = P{X \\le x,Y \\le y}$$P{ X = x_{i},Y = y_{j}} = p_{ {ij} };i,j =1,2,\\cdots$$f(x,y) \\geq 0$$\\int_{- \\infty}^{+ \\infty}{\\int_{- \\infty}^{+ \\infty}{f(x,y)dxdy} } = 1$$F(x,y) = \\int_{- \\infty}^{x}{\\int_{- \\infty}^{y}{f(u,v)dudv} }$ 边缘分布$p_{i \\cdot} = \\sum_{j = 1}^{\\infty}p_{ {ij} },i =1,2,\\cdots$ $p_{\\cdot j} = \\sum_{i}^{\\infty}p_{ {ij} },j = 1,2,\\cdots$$f_{X}\\left( x \\right) = \\int_{- \\infty}^{+ \\infty}{f\\left( x,y \\right){dy} }$ $f_{Y}(y) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dx}$ 条件分布$P{ X = x_{i}|Y = y_{j}} = \\frac{p_{ {ij} } }{p_{\\cdot j} }$$P{ Y = y_{j}|X = x_{i}} = \\frac{p_{ {ij} } }{p_{i \\cdot} }$$f_{X|Y}\\left( x \\middle| y \\right) = \\frac{f\\left( x,y \\right)}{f_{Y}\\left( y \\right)}$$f_{Y|X}(y|x) = \\frac{f(x,y)}{f_{X}(x)}$ 相互独立的随机变量若$P{X\\le x,Y\\le y}=P{X\\le x}P{Y\\le y}$，即$F(x,y)=F_X(x)F_Y(y)$，则称随机变量$X,Y$是相互独立的。对于连续型随机变量，即$f(x,y)=f_X(x)f_Y(y)$在平面上几乎（除去面积为0的集合外）处处成立。对于离散型随机变量，即$P{X=x_i,Y=y_i}=P{X=x_i}P{Y=y_i}$。对于二维正态随机变量$(X,Y)$，$X,Y$相互独立的充要条件是参数$\\rho=0$。 两个随机变量的函数的分布二维均匀分布$(x,y) \\sim U(D)$ ,$f(x,y) = \\begin{cases} \\frac{1}{S(D)},(x,y) \\in D \\ 0,其他 \\end{cases}$ 二维正态分布$(X,Y)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$,$(X,Y)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$$f(x,y) = \\frac{1}{2\\pi\\sigma_{1}\\sigma_{2}\\sqrt{1 - \\rho^{2} } }.\\exp\\left{ \\frac{- 1}{2(1 - \\rho^{2})}\\lbrack\\frac{ {(x - \\mu_{1})}^{2} }{\\sigma_{1}^{2} } - 2\\rho\\frac{(x - \\mu_{1})(y - \\mu_{2})}{\\sigma_{1}\\sigma_{2} } + \\frac{ {(y - \\mu_{2})}^{2} }{\\sigma_{2}^{2} }\\rbrack \\right}$ 随机变量的独立性和相关性$X$和$Y$的相互独立:$\\Leftrightarrow F\\left( x,y \\right) = F_{X}\\left( x \\right)F_{Y}\\left( y \\right)$:$\\Leftrightarrow p_{ {ij} } = p_{i \\cdot} \\cdot p_{\\cdot j}$（离散型）$\\Leftrightarrow f\\left( x,y \\right) = f_{X}\\left( x \\right)f_{Y}\\left( y \\right)$（连续型）$X$和$Y$的相关性： 相关系数$\\rho_{ {XY} } = 0$时，称$X$和$Y$不相关，否则称$X$和$Y$相关 两个随机变量的函数的分布$Z=X+Y$的分布$f_{X+Y}(z)=\\int_{-\\infty}^\\infty f(x,z-x)dx$ $Z=\\frac{Y}{X}$的分布、$Z=XY$的分布$f_{Y/X}(z)=\\int_{-\\infty}^\\infty |x|f(x,xz)dx$$f_{XY}(z)=\\int_{-\\infty}^\\infty \\frac{1}{|x|}f(x,\\frac{z}{x})dx$ $M=\\max{X,Y}$的分布、$N=\\min{X,Y}$的分布$F_{max}(z)=\\Pi F_{x_i}(z)$$F_{min}(z)=1-\\Pi (1-F_{x_i}(z))$ 离散型$P\\left( X = x_{i},Y = y_{i} \\right) = p_{ {ij} },Z = g\\left( X,Y \\right)$ 则：$P(Z = z_{k}) = P\\left{ g\\left( X,Y \\right) = z_{k} \\right} = \\sum_{g\\left( x_{i},y_{i} \\right) = z_{k} }^{}{P\\left( X = x_{i},Y = y_{j} \\right)}$ 连续型$\\left( X,Y \\right) \\sim f\\left( x,y \\right),Z = g\\left( X,Y \\right)$则：$F_{z}\\left( z \\right) = P\\left{ g\\left( X,Y \\right) \\leq z \\right} = \\iint_{g(x,y) \\leq z}^{}{f(x,y)dxdy}$，$f_{z}(z) = F’_{z}(z)$ 重要公式与结论$f_{X}(x) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dy,}$$f_{Y}(y) = \\int_{- \\infty}^{+ \\infty}{f(x,y)dx}$$P\\left{ \\left( X,Y \\right) \\in D \\right} = \\iint_{D}^{}{f\\left( x,y \\right){dxdy} }$若$(X,Y)$服从二维正态分布$N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},\\rho)$则有： $X\\sim N\\left( \\mu_{1},\\sigma_{1}^{2} \\right),Y\\sim N(\\mu_{2},\\sigma_{2}^{2}).$ $X$与$Y$相互独立$\\Leftrightarrow \\rho = 0$，即$X$与$Y$不相关。 $C_{1}X + C_{2}Y\\sim N(C_{1}\\mu_{1} + C_{2}\\mu_{2},C_{1}^{2}\\sigma_{1}^{2} + C_{2}^{2}\\sigma_{2}^{2} + 2C_{1}C_{2}\\sigma_{1}\\sigma_{2}\\rho)$ ${\\ X}$关于$Y=y$的条件分布为： $N(\\mu_{1} + \\rho\\frac{\\sigma_{1} }{\\sigma_{2} }(y - \\mu_{2}),\\sigma_{1}^{2}(1 - \\rho^{2}))$ $Y$关于$X = x$的条件分布为： $N(\\mu_{2} + \\rho\\frac{\\sigma_{2} }{\\sigma_{1} }(x - \\mu_{1}),\\sigma_{2}^{2}(1 - \\rho^{2}))$ 若$X$与$Y$独立，且分别服从$N(\\mu_{1},\\sigma_{1}^{2}),N(\\mu_{1},\\sigma_{2}^{2}),$则：$\\left( X,Y \\right)\\sim N(\\mu_{1},\\mu_{2},\\sigma_{1}^{2},\\sigma_{2}^{2},0),$ $C_{1}X + C_{2}Y\\sim{\\ }N(C_{1}\\mu_{1} + C_{2}\\mu_{2},C_{1}^{2}\\sigma_{1}^{2} C_{2}^{2}\\sigma_{2}^{2}).$ 若$X$与$Y$相互独立，$f\\left( x \\right)$和$g\\left( x \\right)$为连续函数， 则$f\\left( X \\right)$和$g(Y)$也相互独立。 随机变量的数字特征数学期望数学期望简称期望，又称均值。数学期望完全由概率分布决定。 离散型若离散型随机变量$X$的分布律为$P\\left{ X = x_{i} \\right} = p_{i}$ ，且级数$E(X) = \\sum_{i}^{}{x_{i}p_{i} }$绝对收敛，则称$E(x)$为随机变量$X$的数学期望。 连续型$X\\sim f(x),E(X) = \\int_{- \\infty}^{+ \\infty}{xf(x)dx}$ 性质 $E(C) = C,E\\lbrack E(X)\\rbrack = E(X)$ $E(C_{1}X + C_{2}Y) = C_{1}E(X) + C_{2}E(Y)$ 若$X$和$Y$独立，则$E(XY) = E(X)E(Y)$ $\\left\\lbrack E(XY) \\right\\rbrack^{2} \\leq E(X^{2})E(Y^{2})$ 随机变量函数的数学期望对于函数$Y = g(x)$ $X$为离散型$P{ X = x_{i}} = p_{i},E(Y) = \\sum_{i}^{}{g(x_{i})p_{i} }$； $X$为连续型$X\\sim f(x),E(Y) = \\int_{- \\infty}^{+ \\infty}{g(x)f(x)dx}$扩展到多维函数：$Z = g(X,Y)$;$\\left( X,Y \\right)\\sim P{ X = x_{i},Y = y_{j}} = p_{ {ij} }$;$E(Z) = \\sum_{i}^{}{\\sum_{j}^{}{g(x_{i},y_{j})p_{ {ij} } } }$ $\\left( X,Y \\right)\\sim f(x,y)$;$E(Z) = \\int_{- \\infty}^{+ \\infty}{\\int_{- \\infty}^{+ \\infty}{g(x,y)f(x,y)dxdy} }$ 方差$D(X) = E\\left\\lbrack X - E(X) \\right\\rbrack^{2} = E(X^{2}) - \\left\\lbrack E(X) \\right\\rbrack^{2}$，有时也记作$Var(X)$。同时引入标准差（均方差）$\\sigma (x)=\\sqrt{D(X)}$。 离散型$D(X) = \\sum_{i}^{}{\\left\\lbrack x_{i} - E(X) \\right\\rbrack^{2}p_{i} }$ 连续型$D(X) = {\\int_{- \\infty}^{+ \\infty}\\left\\lbrack x - E(X) \\right\\rbrack}^{2}f(x)dx$ 性质 $\\ D(X) = E(X^{2}) - E^{2}(X)$ $\\ D(C) = 0,D\\lbrack E(X)\\rbrack = 0,D\\lbrack D(X)\\rbrack = 0$ $\\ D\\left( C_{1}X + C_{2} \\right) = C_{1}^{2}D\\left( X \\right)$ $X$与$Y$相互独立，则$D(X \\pm Y) = D(X) + D(Y)$ $\\ D(X) = 0 \\Leftrightarrow P\\left{ X = C \\right} = 1$ $\\ D\\left( X \\right) &lt; E\\left( X - C \\right)^{2},C \\neq E\\left( X \\right)$ Chebyshev（切比雪夫）不等式若随机变量$X$满足$E(X)=\\mu$，方差$D(x)=\\sigma^2$，则对于任意正数$\\varepsilon$，有切比雪夫不等式$P{|X-\\mu|\\ge\\varepsilon}\\leq\\frac{\\sigma^2}{\\varepsilon^2}$成立。 协方差及相关系数$Cov(X,Y) = E\\left\\lbrack (X - E(X)(Y - E(Y)) \\right\\rbrack$称为随机变量$X,Y$的协方差，$\\rho_{ {XY} } = \\frac{Cov(X,Y)}{\\sqrt{D(X)}\\sqrt{D(Y)} }$称为他们的相关系数。 性质 $\\ Cov(X,Y) = Cov(Y,X)$ $\\ Cov(aX,bY) = abCov(Y,X)$ $\\ Cov(X_{1} + X_{2},Y) = Cov(X_{1},Y) + Cov(X_{2},Y)$ $\\ \\left| \\rho\\left( X,Y \\right) \\right| \\leq 1$ $\\ \\rho\\left( X,Y \\right) = 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$ ，其中$a &gt; 0$ $\\rho\\left( X,Y \\right) = - 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &lt; 0$ 一般有 $D(X \\pm Y) = D(X) + D(Y) \\pm 2Cov(X,Y) = D(X) + D(Y) \\pm 2\\rho\\sqrt{D(X)}\\sqrt{D(Y)}$ 重要公式与结论 $\\ Cov(X,Y) = E(XY) - E(X)E(Y)$ $\\left| \\rho\\left( X,Y \\right) \\right| \\leq 1,$且 $\\rho\\left( X,Y \\right) = 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &gt; 0$ $\\rho\\left( X,Y \\right) = - 1 \\Leftrightarrow P\\left( Y = aX + b \\right) = 1$，其中$a &lt; 0$ 下面5个条件互为充要条件：$\\rho(X,Y) = 0$ $\\Leftrightarrow Cov(X,Y) = 0$ $\\Leftrightarrow E(X,Y) = E(X)E(Y)$ $\\Leftrightarrow D(X + Y) = D(X) + D(Y)$ $\\Leftrightarrow D(X - Y) = D(X) + D(Y)$。注：$X$与$Y$独立为上述5个条件中任何一个成立的充分条件，但非必要条件。 矩、协方差矩阵（待补充）$E(X^{k})$称为$X$的$k$阶原点矩，简称$k$阶矩。$E\\left{ {\\lbrack X - E(X)\\rbrack}^{k} \\right},k=2,3,\\ldots$称为$X$的$k$阶中心矩。$E(X^{k}Y^{l})$称为$X,Y$的$k+l$阶混合矩。$E\\left{ {\\lbrack X - E(X)\\rbrack}^{k} {\\lbrack Y - E(Y)\\rbrack}^{l}\\right},k,l=2,3,\\ldots$称为$X,Y$的$k+l$阶混合中心矩。显然，$E(X)$是$X的一阶原点矩，$D(X)$是$X的二阶中心矩，$Cov(X,Y)$是$X,Y$的二阶混合中心矩。 大数定律及中心极限定理大数定律辛钦大数定理（弱大数定理）设随机变量$X_1,X_2,\\ldots,X_n,\\ldots$相互独立，服从同一分布且具有数学期望$E(X_k)=\\mu,(k=1,2,\\ldots)$，则序列$\\overline{X}=\\frac{1}{n}\\sum_{k=1}^nX_k$依概率收敛于$\\mu$。 伯努利大数定理伯努利大数定理是辛钦大数定理的一个重要推论，它表明：试验次数很大时，可用事件的频率代替事件的概率。设$f_A$是n次独立重复试验中事件A发生的次数，$p$是事件A在每次试验中发生的概率，则对于任意的正数$\\varepsilon$，有$\\lim_{n\\to\\infty}P{|\\frac{f_A}{n}-p|&lt;\\varepsilon}=1$，$\\lim_{n\\to\\infty}P{|\\frac{f_A}{n}-p|\\ge\\varepsilon}=0$。 中心极限定理独立同分布的中心极限定理设随机变量$X_1,X_2,\\ldots,X_n,\\ldots$相互独立，服从同一分布且具有数学期望和方差$E(X_k)=\\mu,D(X_k)=\\sigma^2&gt;0,(k=1,2,\\ldots)$，则随机变量之和$\\sum_{k=1}^nX_k$的标准化变量$Y_n=\\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt{n}\\sigma}$的分布函数$F_n(x)$对任意x满足$\\lim_{n\\to\\infty}F_n(x)=\\Phi(x)$。这就是说，n足够大的时候，近似地有$\\frac{\\sum_{k=1}^nX_k-n\\mu}{\\sqrt{n}\\sigma}\\sim N(0,1)$或$\\overline{X}~N(\\mu,\\frac{\\sigma^2}{n})$ Lyapunov（李雅普诺夫）定理设随机变量$X_1,X_2,\\ldots,X_n,\\ldots$相互独立，具有数学期望和方差$E(X_k)=\\mu_k,D(X_k)=\\sigma_k^2&gt;0,(k=1,2,\\ldots)$，记$B_n=\\sum_{k=1}^n\\sigma_k^2$，若存在正数$\\delta$，使得当$n\\to\\infty$时，$\\frac{1}{B_n^{2+\\delta}}\\sum_{k=1}^nE{|X_k-\\mu_k|^{2+\\delta}}\\to 0$，则随机化变量之和$\\sum_{k=1}^nX_k$的标准化变量$Z_n=\\frac{\\sum_{k=1}^nX_k-\\sum_{k=1}^n\\mu_k}{B_n}$的分布函数$F_n(x)$对于任意x满足$\\lim_{n\\to\\infty}F_n(x)=\\Phi(x)$。该定理表明，n足够大的时候，近似地有$Z_n\\sim N(0,1)$。 De Moivre-Laplace（棣莫弗-拉普拉斯）定理独立同分布的中心极限定理的特殊情况，设随机变量$\\eta_n(n=1,2,\\ldots)$服从参数为$n,p(0 &lt; p &lt; 1) $的二项分布，则对于任意x，有$\\lim_{n\\to\\infty}P{\\frac{\\eta_n-np}{\\sqrt{np(1-p)}}\\leq x}=\\Phi(x)$。 样本及抽样分布随机样本总体研究对象的全体，它是一个随机变量，用$X$表示。 个体组成总体的每个基本元素。 简单随机样本来自总体$X$的$n$个相互独立且与总体同分布的随机变量$X_{1},X_{2}\\cdots,X_{n}$，称为容量为$n$的简单随机样本，简称样本。 直方图和箱线图直方图箱线图样本分位数若$P(X \\leq x_{\\alpha}) = \\alpha,$则称$x_{\\alpha}$为$X$的$\\alpha$分位数 抽样分布统计量设$X_{1},X_{2}\\cdots,X_{n},$是来自总体$X$的一个样本，$g(X_{1},X_{2}\\cdots,X_{n})$）是样本的连续函数，且$g()$中不含任何未知参数，则称$g(X_{1},X_{2}\\cdots,X_{n})$为统计量。 样本均值$\\overline{X} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i}$ 样本方差$S^{2} = \\frac{1}{n - 1}\\sum_{i = 1}^{n}{(X_{i} - \\overline{X})}^{2}$ 样本矩样本$k$阶原点矩：$A_{k} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i}^{k},k = 1,2,\\cdots$ 样本k阶中心矩$B_{k} = \\frac{1}{n}\\sum_{i = 1}^{n}{(X_{i} - \\overline{X})}^{k},k = 1,2,\\cdots$ 常用统计量分布$\\chi^{2}$分布$\\chi^{2} = X_{1}^{2} + X_{2}^{2} + \\cdots + X_{n}^{2}\\sim\\chi^{2}(n)$，其中$X_{1},X_{2}\\cdots,X_{n},$相互独立，且同服从$N(0,1)$ $t$分布$T = \\frac{X}{\\sqrt{Y/n} }\\sim t(n)$ ，其中$X\\sim N\\left( 0,1 \\right),Y\\sim\\chi^{2}(n),$且$X$，$Y$ 相互独立。 $F$分布$F = \\frac{X/n_{1} }{Y/n_{2} }\\sim F(n_{1},n_{2})$，其中$X\\sim\\chi^{2}\\left( n_{1} \\right),Y\\sim\\chi^{2}(n_{2}),$且$X$，$Y$相互独立。 正态总体的常用样本分布设$X_{1},X_{2}\\cdots,X_{n}$为来自正态总体$N(\\mu,\\sigma^{2})$的样本，$\\overline{X} = \\frac{1}{n}\\sum_{i = 1}^{n}X_{i},S^{2} = \\frac{1}{n - 1}\\sum_{i = 1}^{n}{ {(X_{i} - \\overline{X})}^{2} }$，则： $\\overline{X}\\sim N\\left( \\mu,\\frac{\\sigma^{2} }{n} \\right){\\ \\ }$或者$\\frac{\\overline{X} - \\mu}{\\frac{\\sigma}{\\sqrt{n} } }\\sim N(0,1)$ $\\frac{(n - 1)S^{2} }{\\sigma^{2} } = \\frac{1}{\\sigma^{2} }\\sum_{i = 1}^{n}{ {(X_{i} - \\overline{X})}^{2}\\sim\\chi^{2}(n - 1)}$ $\\frac{1}{\\sigma^{2} }\\sum_{i = 1}^{n}{ {(X_{i} - \\mu)}^{2}\\sim\\chi^{2}(n)}$ ${\\ \\ }\\frac{\\overline{X} - \\mu}{S/\\sqrt{n} }\\sim t(n - 1)$ 重要公式与结论 对于$\\chi^{2}\\sim\\chi^{2}(n)$，有$E(\\chi^{2}(n)) = n,D(\\chi^{2}(n)) = 2n$； 对于$T\\sim t(n)$，有$E(T) = 0,D(T) = \\frac{n}{n - 2}(n &gt; 2)$； 对于$F\\sim{\\ }F(m,n)$，有 $\\frac{1}{F}\\sim F(n,m),F_{a/2}(m,n) = \\frac{1}{F_{1 - a/2}(n,m)}$； 对于任意总体$X$，有 $E(\\overline{X}) = E(X),E(S^{2}) = D(X),D(\\overline{X}) = \\frac{D(X)}{n}$ 参数估计点估计矩估计法最大似然估计法基于截尾样本的最大似然估计估计量的评选标准无偏性有效性相和性区间估计正态总体均值与方差的区间估计(0-1)分布参数的区间估计单侧置信区间假设试验假设检验正态总体均值的假设检验单个总体$N(\\mu,\\sigma^2)$均值$\\mu$的检验$\\sigma^2$已知，关于$\\mu$的检验（Z检验）$\\mu$已知，关于$\\sigma^2$的检验（t检验）两个正态总体均值差的检验（t检验）基于成对数据的检验（t检验）正态总体方差的假设检验单个总体的情况两个总体的情况置信区间与假设检验之间的关系样本容量的选取分布拟合检验单个分布的$\\chi^2$拟合检验法分布族的$\\chi^2$拟合检验偏度、峰度检验秩和检验假设检验问题的p值检验法","link":"/2018/12/03/2018-12-03-概率论与数理统计/"},{"title":"图论","text":"这里用类似邻接表的方法存图。有的算法可能需要邻接矩阵，详见线性代数部分。 12345678910111213141516171819202122232425struct Graph{ struct Vertex { vector&lt;int&gt; o, i; //相关出边和入边编号 int siz, dep, top, dfn; //树链剖分中使用，依次代表子树节点数、深度、所在链的顶端节点、dfs序 }; struct Edge : pair&lt;int, int&gt; { ll len, cap; //边长、容量，图论算法使用 }; vector&lt;Vertex&gt; v; //点集 vector&lt;Edge&gt; e; //边集 Graph(int n) : v(n) {} void add(const Edge &amp;ed) { if (ed.first == ed.second) return; //如果有需要请拆点 v[ed.first].o.push_back(e.size()); v[ed.second].i.push_back(e.size()); e.push_back(ed); } int ch(int u, int i = 0) { return e[v[u].o[i]].second; } //u的第i个孩子节点 int fa(int u, int i = 0) { return e[v[u].i[i]].first; } //u的第i个父节点}; 最短路Dijkstra算法使用示例，适用于边权为正的情况（无论有向图还是无向图），用于求单源最短路。 直接给出其优先队列优化的版本。另外，由于priority_queue并不提供修改优先级的操作，为避免重复扩展，这里选择将新元素直接插入队列并在运行时判断该点是否被处理，并不影响结果的正确性。 1234567891011121314151617181920212223242526struct Dijkstra : Graph{ vector&lt;ll&gt; d; vector&lt;int&gt; p; Dijkstra(int n) : Graph(n) {} void ask(int s) { d.assign(v.size(), INF); p.assign(v.size(), NPOS); priority_queue&lt;pair&lt;ll, int&gt;&gt; q; for (q.push(make_pair(d[s] = 0, s)); !q.empty();) { ll dis = -q.top().first; int u = q.top().second; if (q.pop(), d[u] &lt; dis) continue; for (int i = 0, k, to; i != v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, d[to] &gt; d[u] + e[k].len) { d[to] = d[u] + e[k].len, p[to] = k; q.push(make_pair(-d[to], to)); } } }}; BellmanFord算法使用示例，直接给出其队列优化、国内称之为SPFA算法的版本。较之Dijkstra算法，此算法不够快速稳定但是可以允许负边存在，当s到达负权回路时会直接返回0。稀疏图上性能优秀。 1234567891011121314151617181920212223242526struct BellmanFord : Graph{ vector&lt;ll&gt; d; vector&lt;int&gt; p; BellmanFord(int n) : Graph(n) {} bool ask(int s) { d.assign(v.size(), INF); p.assign(v.size(), NPOS); vector&lt;int&gt; cnt(v.size(), 0), flag(v.size(), d[s] = 0); for (deque&lt;int&gt; q(cnt[s] = flag[s] = 1, s); !q.empty(); q.pop_front()) for (int u = q.front(), i = flag[u] = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, d[to] &gt; d[u] + e[k].len) { d[to] = d[u] + e[k].len, p[to] = k; if (!flag[to]) { if (v.size() == ++cnt[to]) return 0; flag[to] = 1, q.push_back(to); } } return 1; }}; 差分约束系统按如下方式建图、跑SPFA： 对每个不等式$x_i−x_j\\leq d$，从$j$向$i$连一条边，边长为$d$。 若不等号的方向相反，即$x_i−x_j\\geq d$，则在不等式两边同时乘以$-1$，变成$x_j−x_i\\leq -d$，即从$i$到$j$连一条边，边长为$d$。 Floyed求多源最短路不连通的权置INF。 1234567891011struct Floyed : Matrix{ void ask() { for (int k = 0; k &lt; n; ++k) for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) if (a[i][j] &gt; a[i][k] + a[k][j]) a[i][j] = a[i][k] + a[k][j]; }}; Astar求k短路使用示例，在这个比较坑的例子中需要在调用前补一句if(s==t)++k;。k下标从0开始，即最短路==第0短路。 朴素的想法是使用priority_queue从原点出发向外探索，当取出终点t第k次时就得到第k短路，类似bfs的思想，缺陷是越往后状态数越多。 我们在反向图上从$t\\to s$跑Astar算法，通过优先展开到s近的状态，使搜索方向靠近答案，而不是一层一层全都展开，估价函数$f\\approx g+h$，f是估计的s到t的距离，g是到达当前点已经点的花费，h是预计剩下的花费。这里h取当前点的距离到s距离，可通过从s跑一遍Dijkstra可以预处理得出。 Astar算法是只有到达终点的时候才能统计答案，这导致可能拓展很多个状态才能得到一个用来更新答案的有效状态。例如一个n元环，当我们到达终点之后,可能还要拓展n次才能得到下一个状态，于是时间复杂度就被卡到$O(nk)$。 12345678910111213141516171819202122232425struct Astar : Dijkstra{ vector&lt;ll&gt; ans; Astar(int n) : Dijkstra(n) {} void ask(int s, int t, int k) { Dijkstra::ask(s); ans.assign(k, INF); if (d[t] == INF) return; vector&lt;int&gt; cnt(v.size(), 0); priority_queue&lt;pair&lt;ll, int&gt;&gt; q; for (q.push(make_pair(-d[t], t)); cnt[s] &lt; k &amp;&amp; !q.empty();) { ll dis = -q.top().first; int u = q.top().second; if (u == s) ans[cnt[s]] = dis; if (q.pop(), ++cnt[u] &gt; k) continue; for (int i = 0, k; i &lt; v[u].i.size(); ++i) k = v[u].i[i], q.push(make_pair(d[u] - d[e[k].first] - e[k].len - dis, e[k].first)); } }}; 网络流ISAP求最大流使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct ISAP : Graph{ ll flow; vector&lt;ll&gt; f; vector&lt;int&gt; h, cur, gap; ISAP(int n) : Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.first, ed.second), ed.cap = 0; Graph::add(ed); } ll dfs(int s, int u, int t, ll r) { if (r == 0 || u == t) return r; ll _f, _r = 0; for (int &amp;i = cur[u], k; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], h[u] == h[e[k].second] + 1) { _f = dfs(s, e[k].second, t, min(r - _r, e[k].cap - f[k])); f[k] += _f, f[k ^ 1] -= _f, _r += _f; if (_r == r || h[s] &gt;= v.size()) return _r; } if (!--gap[h[u]]) h[s] = v.size(); return ++gap[++h[u]], cur[u] = 0, _r; } void ask(int s, int t) { h.assign(v.size(), 0); cur.assign(v.size(), 0); gap.assign(v.size() + 2, 0); /* for(deque&lt;int&gt; q(h[t]=gap[t]=1,t); !q.empty(); q.pop_front())//优化，加了能快一点 for(int i=0,u=q.front(),k,to; i&lt;v[u].o.size(); ++i) if(to=e[v[u].o[i]].second,!h[to]) ++gap[h[to]=h[u]+1],q.push_back(to); */ for (f.assign(e.size(), flow = 0); h[s] &lt; v.size();) flow += dfs(s, s, t, INF); }}; PrimalDual求费用流使用示例，定义一条边的费用为流量*边长，求总费用最小的最大流。性能优秀，只能跑非负权图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct PrimalDual : Graph{ ll flow, cost; vector&lt;ll&gt; f; PrimalDual(int n) : Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1; Graph::add(ed); } void ask(int s, int t) //询问s到t的最小费用最大流，答案存在flow、cost中 { vector&lt;int&gt; p(v.size(), NPOS); vector&lt;ll&gt; d(v.size(), INF), h(v.size(), 0); for (f.assign(e.size(), flow = cost = 0);;) { priority_queue&lt;pair&lt;ll, int&gt;&gt; q; for (q.push(make_pair(d[s] = 0, s)); !q.empty();) { ll dis = -q.top().first; int u = q.top().second; if (q.pop(), d[u] &lt; dis) continue; for (int i = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, e[k].cap &gt; f[k] &amp;&amp; d[to] &gt; d[u] + e[k].len + h[u] - h[to]) { d[to] = d[u] + e[k].len + h[u] - h[to], p[to] = k; q.push(make_pair(-d[to], to)); } } if (d[t] == INF) return; for (int i = 0; i &lt; d.size(); ++i) if (d[i] != INF) h[i] += d[i], d[i] = INF; ll _f = INF; for (int u = t; u != s; u = e[p[u]].first) _f = min(_f, e[p[u]].cap - f[p[u]]); for (int u = t; u != s; u = e[p[u]].first) cost += _f * e[p[u]].len, f[p[u]] += _f, f[p[u] ^ 1] -= _f; flow += _f; } }}; EK求费用流使用示例，定义一条边的费用为流量*边长，求总费用最小的最大流。BellmanFord算法找增广路，可能被卡但是可以跑负费用流（最大费用流）。 1234567891011121314151617181920212223242526272829303132333435363738struct EdmondKarp : Graph{ ll flow, cost; vector&lt;ll&gt; f; EdmondKarp(int n) : Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1; Graph::add(ed); } void ask(int s, int t) { vector&lt;int&gt; p(v.size(), NPOS); for (f.assign(e.size(), flow = cost = 0);;) { vector&lt;ll&gt; d(v.size(), INF); vector&lt;int&gt; flag(v.size(), d[s] = 0); for (deque&lt;int&gt; q(flag[s] = 1, s); !q.empty(); q.pop_front()) for (int u = q.front(), i = flag[u] = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, e[k].cap &gt; f[k] &amp;&amp; d[to] &gt; d[u] + e[k].len) { d[to] = d[u] + e[k].len, p[to] = k; if (!flag[to]) q.push_back(to), flag[to] = 1; } if (d[t] == INF) return; ll _f = INF; for (int u = t; u != s; u = e[p[u]].first) _f = min(_f, e[p[u]].cap - f[p[u]]); for (int u = t; u != s; u = e[p[u]].first) cost += _f * e[p[u]].len, f[p[u]] += _f, f[p[u] ^ 1] -= _f; flow += _f; } }}; ZKW求费用流使用示例，定义一条边的费用为流量*边长，求总费用最小的最大流。 对于最终流量较大，而费用取值范围不大的图，或者是增广路径比较短的图（如二分图），zkw算法都会比较快，原因是充分发挥优势。比如流多说明可以同一费用反复增广，费用窄说明不用改太多距离标号就会有新增广路，增广路径短可以显著改善最坏情况，因为即使每次就只增加一条边也可以很快凑成最短路。如果恰恰相反，流量不大，费用不小，增广路还较长，就不适合 zkw 算法了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct ZKW : Graph{ ll flow, cost; vector&lt;ll&gt; h, f; vector&lt;int&gt; vis; ZKW(int n) : Graph(n) {} void add(Edge ed) { Graph::add(ed); swap(ed.first, ed.second), ed.cap = 0, ed.len *= -1; Graph::add(ed); } ll dfs(int u, int t, ll r) { if (r == 0 || u == t) return r; if (vis[u]) return 0; ll _f = vis[u] = 1, _r = 0; for (int i = 0, k; r &gt; _r &amp;&amp; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], h[e[k].second] + e[k].len == h[u]) _f = dfs(e[k].second, t, min(r - _r, e[k].cap - f[k])), f[k] += _f, f[k ^ 1] -= _f, _r += _f; return _r; } void ask(int s, int t) { h.assign(v.size(), 0); vis.assign(v.size(), 0); for (f.assign(e.size(), flow = cost = 0);;) { ll _f = dfs(s, t, INF), d = INF; flow += _f, cost += _f * h[s]; for (int u = 0; u &lt; v.size(); ++u) for (int i = 0, k; vis[u] &amp;&amp; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], !vis[e[k].second] &amp;&amp; e[k].cap &gt; f[k]) d = min(d, e[k].len + h[e[k].second] - h[e[k].first]); if (d == INF) return; for (int i = 0; i &lt; v.size(); ++i) if (vis[i]) h[i] += d, vis[i] = 0; } }}; 上下界有源汇网络流T向S连容量正无穷的边，将有源汇转化为无源汇。每条边容量减去下界，设$in[i]$表示流入i的下界之和减去流出i的下界之和。新建超级源汇SS,TT，对于$in[i]&gt;0$的点，SS向i连容量为$in[i]$的边。对于$in[i]&lt;0$的点，i向TT连容量为$−in[i]$的边。 求出以 SS,TT 为源汇的最大流，如果等于$\\sum in[i](in[i] &gt; 0)$则存在可行流。再求出以S,T为源汇的最大流即为最大流。 费用流：建完图后等价于求以SS,TT为源汇的的费用流。 上下界费用流：先把下界的费用加入答案。 判断边是否属于某一割集在残余网络 (还有流量的边) 中求强连通分量，顶点不在同一 SCC 且满流的边。 判断边是否为全部最小割集的边： 在上一条的基础上，还要满足起点与 S 在同一 SCC，且终点与T在同一SCC。 线性规划转费用流首先添加松弛变量，将不等号都变为等号。分别用下一个式子减去上一个式子，如果每个变量只出现了两次且符号一正一负，那么可以转化为费用流。对于每个式子建立一个点，那么每个变量对应一条边，从一个点流出，向另一个点流入。这样，对于等式右边的常数，如果是正的，对应从源点向该点连一条流量C，费用0的边；如果是负的对应从该点向汇点连一条流量−C，费用0的边。对于每个变量，从它系数为正的式子向系数为负的式子连一条容量为 inf，费用为它在目标函数里系数的边。这样网络流模型就构造完毕了。 欧拉路使用示例，给定无孤立结点图G，若存在一条路，经过图中每边一次且仅一次，该条路称为欧拉路。 无向图：当仅当该图所有顶点的度数为偶数（此时为回路），或除两个度数为奇数外（作为路径的起点和终点）、其余全为偶数。 有向图：当仅当该图所有顶点出度=入度（此时为回路），或一个顶点出度=入度+1（作为起点）、另一个顶点入度=出度+1（作为终点）、其他顶点出度=入度。 混合图欧拉回路判定：首先给无向边随便定一个方向，设$\\deg x$为x连出去的边数−连入x的边数。若存在$\\deg x$为奇数，或者图不连通，则无解。否则建立源点S，汇点T。对于一个点x，若$\\deg x&gt;0$，则S向x连边，容量$\\frac{\\deg x}{2}$；若$\\deg x&lt;0$，则x向T连边，容量$-\\frac{\\deg x}{2}$。 对于一条定了向的无向边$x\\to y$，x向y连边，容量1，求出最大流，若与 S 和T连的每条边都满流，则有解。 1234567891011121314151617181920212223struct Fleury : Graph{ vector&lt;int&gt; vis, cur, p; Fleury(int n) : Graph(n) {} void dfs(int u) { for (int &amp;i = cur[u], k; i &lt; v[u].i.size(); ++i) //遍历原图的反向图，这里加了一个“当前弧”优化 if (k = v[u].i[i], !vis[k] &amp;&amp; !vis[k ^ 1]) //无向图需要同时检查反向边未被访问过 { vis[k] = 1; dfs(e[k].first); p.push_back(k); } } void ask() //查询欧拉回路，路径上边的序号按顺序存在p中 { vis.assign(e.size(), 0), cur.assign(v.size(), 0), p.clear(); for (int i = 0; i &lt; v.size(); ++i) if (v[i].i.size() % 2) return dfs(i); dfs(0); }}; 连通性无向图求割和双连通分量使用示例割边：在连通图中，删除了连通图的某条边后，图不再连通。这样的边被称为割边，也叫做桥。 割点：在连通图中，删除了连通图的某个点以及与这个点相连的边后，图不再连通。这样的点被称为割点。构造dfs搜索树，在树上有两类节点可以成为割点： 对根节点u，若其有两棵或两棵以上的子树，则该根结点u为割点； 对非根非叶节点u，若其中的某棵子树的节点均没有指向u的祖先节点的回边，说明删除u之后，根结点与该棵子树的节点不再连通；则节点u为割点。 对于一个无向图的子图，当删除其中任意一条边后，不改变图内点的连通性，这样的子图叫做边的双连通子图。而当子图的边数达到最大时，叫做边的双连通分量。原理是图中所有割边再求一次SCC，可直接使用求SCC的代码。 对于一个无向图的子图，当删除其中任意一个点后，不改变图内点的连通性，这样的子图叫做点的双连通子图。而当子图的边数达到最大时，叫做点的双连通分量。下面给出求点双连通分量的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct BCC : Graph //Biconnected Connected Componenet{ vector&lt;int&gt; low, bid, stak, cutPoint, cutEdge; //连通块最早dfs序，边的端点所属双连通块 int bcc_siz; BCC(int n) : Graph(n) {} void ask() { low.assign(v.size(), NPOS); bid.assign(e.size(), NPOS); cutPoint.assign(v.size(), 0); cutEdge.assign(e.size(), 0); for (int i = bcc_siz = 0, cnt = 0; i &lt; v.size(); ++i) if (low[i] == NPOS) dfs(i, NPOS, cnt); } void dfs(int u, int fa, int &amp;cnt) { low[u] = v[u].dfn = ++cnt; for (int i = 0, k, to, ch = 0; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, to != fa) { if (low[to] == NPOS) { ++ch; stak.push_back(k); dfs(to, u, cnt); low[u] = min(low[u], low[to]); if (low[to] &gt;= v[u].dfn) for (++bcc_siz, cutPoint[u] = fa != NPOS || ch &gt; 1;;) { int x = stak.back(); stak.pop_back(); bid[x] = bid[x ^ 1] = bcc_siz - 1; if (x == k) break; } if (low[to] &gt; v[u].dfn) cutEdge[k] = cutEdge[k ^ 1] = 1; } else if (v[to].dfn &lt; v[u].dfn) { stak.push_back(k); low[u] = min(low[u], v[to].dfn); } } }}; 双连通图的构造先求出所有的桥，然后删除这些桥边，剩下的每个连通块都是一个双连通子图。把每个双连通子图收缩为一个顶点，再把桥边加回来，最后的这个图一定是一棵树，边连通度为1。统计出树中度为1的节点的个数，即为叶节点的个数，记为leaf。至少在树上添加(leaf+1)/2条边，就能使树达到边双连通：先把两个最近公共祖先最远的两个叶节点之间连接一条边，这样可以把这两个点到祖先的路径上所有点收缩到一起，因为一个形成的环一定是双连通的；然后再找两个最近公共祖先最远的两个叶节点，这样一对一对找完，恰好是(leaf+1)/2次，把所有点收缩到了一起。 有向图求强连通分量使用示例，如果是无向图，求出来的还是边双连通分量。 123456789101112131415161718192021222324252627282930313233343536struct SCC : Graph //Strongly Connected Componenet{ vector&lt;int&gt; low, sid, stak; //连通块最早dfs序，点所属连通块 int scc_siz; SCC(int n) : Graph(n) {} void ask() { low.assign(v.size(), NPOS); sid.assign(v.size(), NPOS); for (int i = scc_siz = 0, cnt = 0; i != v.size(); ++i) if (low[i] == NPOS) dfs(i, NPOS, cnt); } void dfs(int u, int fa, int &amp;cnt) { low[u] = v[u].dfn = ++cnt; stak.push_back(u); for (int i = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, to != fa, 1) //求边双连通分量把\",1\"注释掉，即不许走回边 { if (low[to] == NPOS) dfs(to, u, cnt), low[u] = min(low[u], low[to]); else if (sid[to] == NPOS) low[u] = min(low[u], v[to].dfn); } if (low[u] == v[u].dfn) for (++scc_siz;;) { int x = stak.back(); stak.pop_back(); sid[x] = scc_siz - 1; if (x == u) break; } }}; 2-SAT使用示例，n个布尔变量$x_0\\ldots x_{n-1}$，逻辑表达式$Y=(A_0+B_0)(A_1+B_1)\\ldots(A_{m-1}+B_{m-1})$，其中$A_i,B_i\\in{x_j,\\overline{x_j}}$，判断是否存在$x_0\\ldots x_{n-1}$的取值使得Y值为1。因为$A+B=(\\overline A\\to B)(\\overline B\\to A)$，所以对于一个要求$A+B$，我们连$\\overline A\\to B,\\overline B\\to A$两条边。如果有一条边$A\\to B$，意味着如果A成立那么B必然成立。若$\\exists i,x_i,\\overline{x_i}\\in$同一SCC，则不存在。 二分图二分图的一个等价定义是：不含有含奇数条边的环的图。 完美匹配图中所有的顶点都是匹配点。 二分图的最小点覆盖（最小割）是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联。二分图中，最小割=最大匹配。 二分图的最小边覆盖（最大独立集）是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。二分图中，最小点覆盖+最小边覆盖=总点数。 Hall定理：二分图中的两部分顶点组成的集合分别为 X,Y ，则有一组无公共点的边，一端恰好为组成 X 的点的充分必要条件是：X 中的任意 k 个点至少与 Y 中的 k 个点相邻。对于区间图只需要考虑极端情况，线段树维护。 关键点：一定在最大匹配中的点。 求出任意一个最大匹配，那么只需要考虑哪些匹配点不一定在。 假设是考虑左侧的点，右侧类似： 将匹配边从右往左，非匹配边从左到右，从左侧每个未匹配点开始DFS到的匹配点都不是关键点。 关键边：求出任意一个最大匹配，将匹配边从右到左，剩余边从左到右，求出 SCC。 对于一条边：若它位于当前匹配中，那么若两端点位于同一SCC，则是可能在，否则必定在；若它不位于当前匹配中，那么若两端点位于同一 SCC，则是可能在，否则必定不在。 Hungary求最大匹配使用示例 左边nl个点$0\\ldots nl-1$，右边nr个点$0\\ldots nr-1$，取n=max(nl,nr)，左i右j间代价a[x][y]。 生成fl[i]表示左边第i个匹配右边第fl[i]个（对应权a[i][fl[i]]），fr同理。时间复杂度$O(n^3)$。 稀疏图的时候考虑用邻接表代替邻接矩阵，并且找完全匹配的时候有问题可直接return。 匹配是一个边集，其中任意两条边都没有公共顶点；扫一遍fl或fr判断有多少不等于NPOS即为最大匹配数。 12345678910111213141516171819struct Hungary : Matrix{ int fl[N], fr[N], vr[N]; bool dfs(int x, int rt) { for (int y = 0; y &lt; n; ++y) if (a[x][y] &amp;&amp; vr[y] != rt) if (vr[y] = rt, fr[y] == NPOS || dfs(fr[y], rt)) return fl[fr[y] = x] = y, 1; return 0; } void ask() { fill(fl, fl + n, NPOS), fill(fr, fr + n, NPOS), fill(vr, vr + n, NPOS); for (int i = 0; i &lt; n; ++i) if (fl[i] == NPOS) dfs(i, i); }} HopcroftKarp求最大匹配使用示例，时间复杂度$O(\\sqrt{|V|}|E|)$，稀疏图上效果明显。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct HopcroftKarp{ vector&lt;int&gt; g[N]; int n, fl[N], fr[N], hl[N], hr[N], q[N]; bool dfs(int x) { for (int i = 0, c = hl[x] + 1, y = hl[x] = NPOS; i &lt; g[x].size(); ++i) if (hr[y = g[x][i]] == c) if (hr[y] = NPOS, fr[y] == NPOS || dfs(fr[y])) return fl[fr[y] = x] = y, 1; return 0; } void ask() { fill(fl, fl + n, NPOS), fill(fr, fr + n, NPOS); for (int x = 0; x &lt; n; ++x) for (int i = 0, y; i &lt; g[x].size(); ++i) if (fr[y = g[x][i]] == NPOS) { fl[fr[y] = x] = y; break; } for (int ql, qr, ok;;) { fill(hl, hl + n, NPOS), fill(hr, hr + n, NPOS); for (int x = ql = qr = ok = 0; x &lt; n; ++x) if (fl[x] == NPOS) hl[q[qr++] = x] = 0; while (ql &lt; qr) for (int i = 0, x = q[ql++], y; i &lt; g[x].size(); ++i) if (hr[y = g[x][i]] == NPOS) { hr[y] = hl[x] + 1; if (fr[y] == NPOS) ok = 1; else if (hl[fr[y]] == NPOS) hl[q[qr++] = fr[y]] = hr[y] + 1; } if (!ok) return; for (int x = 0; x &lt; n; ++x) if (fl[x] == NPOS) dfs(x); } }}; KuhnMunkres求最优完备匹配使用示例，最大费用流时，a初始化0；最大费用最大流时，a初始化-N*INF。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051struct KuhnMunkres : Matrix{ ll hl[N], hr[N], slk[N]; int fl[N], fr[N], vl[N], vr[N], pre[N], q[N], ql, qr; int check(int i) { if (vl[i] = 1, fl[i] != NPOS) return vr[q[qr++] = fl[i]] = 1; while (i != NPOS) swap(i, fr[fl[i] = pre[i]]); return 0; } void bfs(int s) { fill(slk, slk + n, INF), fill(vl, vl + n, 0), fill(vr, vr + n, 0); for (vr[q[ql = 0] = s] = qr = 1;;) { for (ll d; ql &lt; qr;) for (int i = 0, j = q[ql++]; i &lt; n; ++i) if (!vl[i] &amp;&amp; slk[i] &gt;= (d = hl[i] + hr[j] - a[i][j])) if (pre[i] = j, d) slk[i] = d; else if (!check(i)) return; ll d = INF; for (int i = 0; i &lt; n; ++i) if (!vl[i] &amp;&amp; d &gt; slk[i]) d = slk[i]; for (int i = 0; i &lt; n; ++i) { if (vl[i]) hl[i] += d; else slk[i] -= d; if (vr[i]) hr[i] -= d; } for (int i = 0; i &lt; n; ++i) if (!vl[i] &amp;&amp; !slk[i] &amp;&amp; !check(i)) return; } } void ask() { fill(fl, fl + n, NPOS), fill(fr, fr + n, NPOS), fill(hr, hr + n, 0); for (int i = 0; i &lt; n; ++i) hl[i] = *max_element(a[i], a[i] + n); for (int j = 0; j &lt; n; ++j) bfs(j); }}; 带花树一般图最大匹配使用示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Blossom : Graph{ vector&lt;int&gt; f; Blossom(int n) : Graph(n) {} void ask() { vector&lt;int&gt; vis(v.size(), NPOS); f = vis; for (int s = 0, t = 0; s &lt; v.size(); ++s) if (f[s] == NPOS) { UnionfindSet ufs(v.size()); vector&lt;int&gt; pre(v.size(), NPOS), flag(pre); for (deque&lt;int&gt; q(flag[s] = 1, s); f[s] == NPOS &amp;&amp; !q.empty(); q.pop_front()) for (int i = 0, x = q.front(), y, a, b; i &lt; v[x].o.size(); ++i) if (y = e[v[x].o[i]].second, y != f[x] &amp;&amp; flag[y] &amp;&amp; ufs.ask(x) != ufs.ask(y)) { if (flag[y] == 1) { for (a = x, b = y, ++t;; swap(a, b)) if (a != NPOS) { if (vis[a = ufs.ask(a)] == t) break; vis[a] = t, a = f[a] != NPOS ? pre[f[a]] : NPOS; } if (ufs.ask(x) != a) pre[x] = y; if (ufs.ask(y) != a) pre[y] = x; for (int p[2] = {x, y}, j = 0; j &lt; 2; ++j) for (int x = p[j], y, z; x != a; ufs.merge(y, x), ufs.merge(x = z, y)) { if (ufs.ask(z = pre[y = f[x]]) != a) pre[z] = y; if (!flag[y]) flag[y] = 1, q.push_back(y); if (!flag[z]) flag[z] = 1, q.push_back(z); } } else if (f[y] == NPOS) { for (pre[y] = x; y != NPOS;) swap(y, f[f[y] = pre[y]]); break; } else pre[y] = x, q.push_back(f[y]), flag[f[y]] = 1, flag[y] = 0; } } }}; 树形图最小生成树无向图同时给出Prim算法（生成新树）、Kruskal算法（消耗小）。 1234567891011121314151617181920212223242526272829303132333435363738394041struct Prim : Graph{ struct DisGreater { bool operator()(const Edge &amp;e1, const Edge &amp;e2) { return e1.len &gt; e2.len; } }; ll ans; vector&lt;int&gt; vis; priority_queue&lt;Edge, vector&lt;Edge&gt;, DisGreater&gt; q; Prim(const Graph &amp;g, int root) : Tree(n), ans(0), vis(g.v.size(), 0) //生成新树，每条边都要有等长反向边 { for (insert(root, g); !q.empty();) { Edge ed = q.top(); if (q.pop(), !vis[ed.second]) insert(ed.second, g), ans += ed.len, add(ed); } } void insert(int u, const Graph &amp;g) //把点和对应的相连的边加入集合 { vis[u] = 1; for (int i = 0, k; i &lt; g.v[u].o.size(); ++i) if (k = g.v[u].o[i], !vis[g.e[k].second]) q.push(g.e[k]); }};ll kruskal(vector&lt;Edge&gt; &amp;e, int n) //会清空边集e，每条边被认作无向边{ ll ret = 0; UnionFindSet ufs(n); for (sort(e.begin(), e.end(), DisGreater()); !e.empty(); e.pop_back()) if (ufs.fa(e.back().from) != ufs.fa(e.back().to)) { ufs.merge(e.back().from, e.back().to); ret += e.back().len; } return /*ufs.siz&gt;1?INF:*/ ret; //视情况选择去注释} 有向图使用示例 指定以root为根，如果没有限定根那么新建一个虚拟点作为根，向所有边连边长最大边长+1的边，在最后生成的图中去掉此边。时间复杂度$O(VE)$。 12345678910111213141516171819202122232425262728293031323334353637383940ll zhuLiu(vector&lt;Edge&gt; &amp;e, int root, int n) //不存在返回INF{ for (ll ret = 0;;) { vector&lt;ll&gt; in(n, INF); vector&lt;int&gt; pre(n, NPOS); for (int i = 0, to; i &lt; e.size(); ++i) { if (e[i].first == (to = e[i].second)) swap(e[i--], e.back()), e.pop_back(); else if (in[to] &gt; e[i].len) in[to] = e[i].len, pre[to] = e[i].first; } for (int i = in [root] = 0; i &lt; n; ++i) if (in[i] == INF) return INF; vector&lt;int&gt; id(n, NPOS), vis(n, NPOS); int tn = 0; for (int i = 0, v; i &lt; n; ++i) { for (ret += in [v = i]; vis[v] != i &amp;&amp; id[v] == NPOS &amp;&amp; v != root; v = pre[v]) vis[v] = i; if (v != root &amp;&amp; id[v] == NPOS) { for (int u = pre[v]; u != v; u = pre[u]) id[u] = tn; id[v] = tn++; } } if (!tn) return ret; for (int i = 0; i &lt; n; ++i) if (id[i] == NPOS) id[i] = tn++; for (int i = 0, v; i &lt; e.size(); ++i) if ((e[i].first = id[e[i].first]) != (e[i].second = id[v = e[i].second])) e[i].len -= in[v]; n = tn, root = id[root]; }} 树链剖分与LCA使用示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct Diagram : Graph{ Fenwick data; //暂用树状数组作为默认数据结构 Diagram(const Graph &amp;g, int root) : Graph(g.v.size()), data(g.v.size()) { build(root, g); int cnt = v[root].dfn = v[root].dep = 1; dfs(v[root].top = root, cnt); } void build(int u, const Graph &amp;g) //无向图dfs建树，且重边在最前，u为根节点 { v[u].siz = 1; for (int i = 0, k, to; i &lt; g.v[u].o.size(); ++i) if (k = g.v[u].o[i], to = g.e[k].second, !v[to].siz) //没访问过的点siz默认0 { build(to, g); v[u].siz += v[to].siz; Graph::add(g.e[k]); if (v[ch(u)].siz &lt; v[to].siz) //重边移到最前 swap(v[u].o.front(), v[u].o.back()); } } void dfs(int u, int &amp;cnt) { for (int i = 0, to; i &lt; v[u].o.size(); ++i) { v[to = ch(u, i)].dfn = ++cnt; v[to].top = i ? to : v[u].top; v[to].dep = v[u].dep + 1; dfs(to, cnt); } } int lca(int x, int y) { for (; v[x].top != v[y].top; x = fa(v[x].top)) if (v[v[x].top].dep &lt; v[v[y].top].dep) swap(x, y); if (v[x].dep &lt; v[y].dep) swap(x, y); return y; } ll ask(int x, int y) { ll ans = 0; for (; v[x].top != v[y].top; x = fa(v[x].top)) { if (v[v[x].top].dep &lt; v[v[y].top].dep) swap(x, y); ans += data.ask(v[v[x].top].dfn, v[x].dfn); } if (v[x].dep &lt; v[y].dep) swap(x, y); return ans += data.ask(v[y].dfn, v[x].dfn); } void add(int x, int y, ll pv) { for (; v[x].top != v[y].top; x = fa(v[x].top)) { if (v[v[x].top].dep &lt; v[v[y].top].dep) swap(x, y); data.add(v[v[x].top].dfn, v[x].dfn, pv); } if (v[x].dep &lt; v[y].dep) swap(x, y); data.add(v[y].dfn, v[x].dfn, pv); }}; 点剖（点分治）使用示例，零号点为虚节点。 1234567891011121314151617181920212223242526272829303132333435struct TreeDiv : Graph{ int root; vector&lt;int&gt; mx, siz, vis; TreeDiv(int n) : Graph(n), mx(n, n), siz(n), vis(n) {} void dfsRoot(int u, int fa) { for (int i = mx[u] = siz[u] = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, to != fa &amp;&amp; !vis[to]) if (dfsRoot(to, u), siz[u] += siz[to], mx[u] &lt; siz[to]) mx[u] = siz[to]; if (mx[u] &lt; mx[0] - ++siz[u]) mx[u] = mx[0] - siz[u]; if (mx[root] &gt;= mx[u]) root = u; } void dfsDis(int u, int fa, ll d) { //用d更新答案 for (int i = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, to != fa &amp;&amp; !vis[to]) dfsDis(to, u, d + e[k].len); } int cal(int u, ll d) //返回符合要求的点对数 { return dfsDis(u, 0, d), /*得到答案*/; } void dfs(int u = 1) { dfsRoot(u, root = 0), ans += cal(u = root, 0), vis[u] = 1; for (int i = 0, k, to; i &lt; v[u].o.size(); ++i) if (k = v[u].o[i], to = e[k].second, !vis[to]) ans -= cal(to, e[k].len), mx[0] = siz[to], dfs(to); }};","link":"/2019/02/03/2019-02-03-图论/"},{"title":"","text":"并行与分布式计算学院：数据科学与计算机学院专业：计算机科学与技术（超级计算方向）学号：17341163姓名：吴坎 课后作业 Why is it difficult to construct a true shared-memory computer? What is the minimum number of switches for connecting p processors to a shared memory with b words (where each word can be accessed independently)? 共享内存的使用大大降低了在大规模数据处理过程中内存的消耗，但是共享内存的使用中有很多的陷阱，使理解和管理数据的局部性变得困难，一不注意就很容易导致程序崩溃。数据在读写过程中会更透明，但是数据写入进程或数据读出进程中，需要附加的数据结构控制。 每个word都需要一个开关，一共需要$b$个开关。 Consider a memory system with a level 1 cache of 32 KB and DRAM of 512 MB with the processor operating at 1 GHz. The latency to L1 cache is one cycle and the latency to DRAM is 100 cycles. In each memory cycle, the processor fetches four words (cache line size is four words). What is the peak achievable performance of a dot product of two vectors? Note: Where necessary, assume an optimal cache placement policy. 1234&gt; /* dot product loop */&gt; for (i = 0; i &lt; dim; ++i)&gt; dot_prod += a[i] * b[i];&gt; 最佳的内存策略是cache的一半用于缓存a，另一半用于缓存b。在这样的情况下，i每增加4，会发生两次cache miss，访问2次DRAM和6次cache。因此，完成上述循环，需要$\\frac{dim}{4}\\times(2\\times 100+6\\times 1)\\times\\frac{1}{1GHz}=dim\\times 5.15\\times 10^{-8}s$ Homework-asst-1Consider the following code where each line within the function represents a single function. 123456789101112131415161718192021&gt; typedef struct&gt; {&gt; float x, y;&gt; } Point;&gt; inline void innerProduct(const Point *a, const Point *b, float *result)&gt; {&gt; float x1 = a-&gt;x, //Uses a load instruction&gt; x2 = b-&gt;x,&gt; product1 = x1 * x2,&gt; y1 = a-&gt;y,&gt; y2 = b-&gt;y,&gt; product2 = y1 * y2,&gt; inner = product1 + product2;&gt; *result = inner; //Uses a store instruction&gt; }&gt; void computeInnerProduct(const Point a[], const Point b[], float result[], int n)&gt; {&gt; for (int i = 0; i &lt; n; ++i)&gt; innerProduct(&amp;a[i], &amp;b[i], &amp;result[i]);&gt; }&gt; In the following questions, you can assume the following: $N$ is very large($&gt;10^6$). The machines described have modern CPUs, providing out-of-order execution, speculative execution, branch prediction, etc. There are no cache misses. The overhead of updating the loopindex i is negligible. The overhead due to procedure calls, as well as starting and ending loops, is negligible. Problem 1: Instruction-Level ParallelismSuppose you have a machine $M_1$ with two load/store unites that can each load or store a single value on each clock cycle, and one arithmetic unit can perform one arithmetic operation(e.g., multiplication or addition) on each clock cycle.A. Assume that the load/store and arithmetic have latencies of one cycle. How many clock cycles would be required to execute computeInnerProduct as a function of n? Explain what limits the performance. 做一次innerProduct需要7次load，1次store，3次arithmetic. 而computeInnerProduct的循环中有n次innerProduct，如果不考虑循环处的消耗的话需要$11n$个cycle。 老师上课说，这一问也考虑了不同指令的并行，所以还是3n。 B. Now assume that the load/store and arithmetic unit have latencies of 10 clock cycles, but they are fully pipelined, able to initiate new operations every clock cycle. How many cycles would be required to execute computeInnerProduction as a function of n?Explain how this relates your answer to Part-A. 最理想的情况下不发生竞争，完全并行，因此不考虑循环处的消耗的话需要3n个cycle。和A部分相比，由于指令完全流水线，因此每次循环时的load/store/arithmetic间没有间断。 Problem 2: SIMD with ISPCConsider running the following ISPC code. 1234567891011&gt; export void computeInnerProductISPC(&gt; uniform point[] a,&gt; uniform point[] b,&gt; uniform float[] result,&gt; uniform int n&gt; )&gt; {&gt; foreach (i = 0...n)&gt; result[i] = a[i].x * b[i].x + a[i].y * b[i].y;&gt; }&gt; Suppose machine $M_2$ has one 8-wide SIMD load/store unit, and one 8-wide SIMD arithmetic unit. both have latencies of one clock cycle.A. How many clock cycles would be required to execute computeInnerProductISPC as a function of n? Explain what lmits the performance. 对于循环中的每个i，发生可4次load，1次store，3次arithmetic。所以一共需要$8n$个cycle。 老师上课说是$\\frac{5}{8}n$，因为5次内存操作是瓶颈，8路同时运算。 B. If we run the computeInnerProductISPC on a five-core machine $M_3$, where each core has the same SIMD capabilities as $M_2$, what would be the best speedup it could achieve over the single-core performance of Part-A? Explain. 最理想的情况下能够加速5倍，因为每个进程间的计算是彼此独立的。 由于使用了SIMD指令集，这是一套单盒的指令集，没有多核并行的内容，所以没有加速，一倍。太坑了！！！ Homework-asst-2Parallel Fractal Generation Using Pthreads Leverage the sample code provided in the course web site. Build and run the code in the prob1_mandelbrot_threads directory of the Assignment 1 code base.This program produces the image file mandelbrot-vV -serial.ppm, where V is the view index. This image is a visualization of a famous set of complex numbers called the Mandelbrot set. As you can see in the images below, the result is a familiar and beautiful fractal. Each pixel in the image corresponds to a value in the complex plane, and the brightness of each pixel is proportional to the computational cost of determining whether the value is contained in the Mandelbrot set—white pixels required the maximum (256) number of iterations, dark ones only a few iterations, and colored pixels were somewhere in between. (See function mandel() defined in mandelbrot.cpp.) You can learn more about the definition of the Mandelbrot set at en.wikipedia.org/wiki/Mandelbrot set. Use the command option “–view V ” for V between 0 and 6 to get the different images. You can click the links below to see the different images on a browser. Take the time to do this—the images are quite striking. (View 0 is not shown— it is all white.) Your job is to parallelize the computation of the images using Pthreads. The command-line option “–threads T” specifies that the computation is to be partitioned over T threads. In function mandelbrotThread(), located in mandelbrot.cpp, the main application thread creates T-1 additional thread using pthread_create(). It waits for these threads to complete using pthread_join(). Currently, neither the launched threads nor the main thread do any computation, and so the program generates an error message. You should add code to the workerThreadStart() function to accomplish this task. You will not need to use of any other Pthread API calls in this assignment. What you need to do: Modify the code in mandelbrot.cpp to parallelize the Mandelbrot generation using two cores. Specifically, compute the top half of the image in thread 0, and the bottom half of the image in thread 1. This type of problem decomposition is referred to as spatial decomposition since different spatial regions of the image are computed by different processors. Extend your code to utilize T threads for {2, 4, 8,16} , partitioning the image generation work into the appropriate number of horizontal blocks. You will need to modify the code in function workerThreadStart, to partition the work over the threads. To confirm (or disprove) your hypothesis, measure the amount of time each thread requires to complete its work by inserting timing code at the beginning and end of workerThreadStart(). How do your measurements explain the speedup graph you previously created? 问题本身还是比较容易的，只在mandelbrot.cpp中加入了$126\\sim 134$行和$164\\sim 174$行就解决了问题，详见源代码。以上三个文件都在文件夹prog1_mandelbrot_threads\\下，虽然老师给的代码有点乱，但好在写了Makefile。于是在终端中执行下列指令编译并运行。 123cd prog1_mandelbrot_threadsmake./mandelbrot -t 2 得到如下输出。 12345678910111213[mandelbrot serial]: [708.508] msWrote image file mandelbrot-serial.ppmHello world from thread 0Hello world from thread 1Hello world from thread 0Hello world from thread 1Hello world from thread 0Hello world from thread 1Hello world from thread 0Hello world from thread 1Hello world from thread 0Hello world from thread 1[mandelbrot thread]: [336.797] msWrote image file mandelbrot-thread.ppm++++ (2.10x speedup from 2 threads) 以上输出表明并行计算的版本在双线程时比单线程快了2.1倍。生成了两个ppm格式的文件mandelbrot-serial.ppm、mandelbrot-thread.ppm，但是并看不了。使用下述指令进行转码： 12ffmpeg -i mandelbrot-serial.ppm mandelbrot-serial.bmpffmpeg -i mandelbrot-thread.ppm mandelbrot-thread.bmp 得到如下两张图片，可以看到也是一模一样的。 mandelbrot-serial.bmp mandelbrot-thread.bmp 假如要使用更多的线程进行计算，只需要修改./mandelbrot -t 2中-t后的参数即可。 123456789101112131415161718192021222324$ ./mandelbrot -t 4[mandelbrot serial]: [713.990] msWrote image file mandelbrot-serial.ppmHello world from thread 1Hello world from thread 2Hello world from thread 0Hello world from thread 3Hello world from thread 1Hello world from thread 2Hello world from thread 0Hello world from thread 3Hello world from thread 1Hello world from thread 0Hello world from thread 2Hello world from thread 3Hello world from thread 1Hello world from thread 2Hello world from thread 0Hello world from thread 3Hello world from thread 1Hello world from thread 2Hello world from thread 0Hello world from thread 3[mandelbrot thread]: [291.995] msWrote image file mandelbrot-thread.ppm++++ (2.45x speedup from 4 threads) 4线程的时候只快了2.45倍。 1234567891011121314151617181920212223242526272829303132333435363738394041424344$ ./mandelbrot -t 8[mandelbrot serial]: [707.881] msWrote image file mandelbrot-serial.ppmHello world from thread 1Hello world from thread 2Hello world from thread 3Hello world from thread 4Hello world from thread 5Hello world from thread 6Hello world from thread 0Hello world from thread 7Hello world from thread 1Hello world from thread 0Hello world from thread 3Hello world from thread 4Hello world from thread 2Hello world from thread 5Hello world from thread 6Hello world from thread 7Hello world from thread 1Hello world from thread 0Hello world from thread 3Hello world from thread 4Hello world from thread 5Hello world from thread 6Hello world from thread 2Hello world from thread 7Hello world from thread 1Hello world from thread 2Hello world from thread 3Hello world from thread 4Hello world from thread 5Hello world from thread 0Hello world from thread 6Hello world from thread 7Hello world from thread 1Hello world from thread 2Hello world from thread 3Hello world from thread 4Hello world from thread 5Hello world from thread 6Hello world from thread 0Hello world from thread 7[mandelbrot thread]: [196.575] msWrote image file mandelbrot-thread.ppm++++ (3.60x speedup from 8 threads) 8线程的时候3.6倍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$ ./mandelbrot -t 16[mandelbrot serial]: [738.481] msWrote image file mandelbrot-serial.ppmHello world from thread 1Hello world from thread 4Hello world from thread 13Hello world from thread 5Hello world from thread 6Hello world from thread 2Hello world from thread 7Hello world from thread 8Hello world from thread 9Hello world from thread 10Hello world from thread 11Hello world from thread 0Hello world from thread 12Hello world from thread 14Hello world from thread 15Hello world from thread 3Hello world from thread 1Hello world from thread 6Hello world from thread 3Hello world from thread 4Hello world from thread 5Hello world from thread 7Hello world from thread 8Hello world from thread 9Hello world from thread 2Hello world from thread 10Hello world from thread 11Hello world from thread 12Hello world from thread 13Hello world from thread 0Hello world from thread 14Hello world from thread 15Hello world from thread 1Hello world from thread 2Hello world from thread 0Hello world from thread 4Hello world from thread 5Hello world from thread 6Hello world from thread 7Hello world from thread 8Hello world from thread 9Hello world from thread 10Hello world from thread 11Hello world from thread 12Hello world from thread 13Hello world from thread 14Hello world from thread 15Hello world from thread 3Hello world from thread 1Hello world from thread 2Hello world from thread 9Hello world from thread 15Hello world from thread 5Hello world from thread 6Hello world from thread 7Hello world from thread 8Hello world from thread 3Hello world from thread 10Hello world from thread 11Hello world from thread 12Hello world from thread 13Hello world from thread 0Hello world from thread 14Hello world from thread 4Hello world from thread 1Hello world from thread 2Hello world from thread 9Hello world from thread 3Hello world from thread 5Hello world from thread 6Hello world from thread 7Hello world from thread 8Hello world from thread 0Hello world from thread 4Hello world from thread 10Hello world from thread 11Hello world from thread 12Hello world from thread 13Hello world from thread 14Hello world from thread 15[mandelbrot thread]: [185.233] msWrote image file mandelbrot-thread.ppm++++ (3.99x speedup from 16 threads) 16线程的时候3.99倍。 可以看到，加速比随进程增加而增加，但是增加的量不是线性的。这是因为并行的时候会有额外的开销。 源代码mandelbrot.cpp主要的代码， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;// Use this code to time your threads// 我加入的代码在126~134行和164~174行#include \"CycleTimer.h\"/* 15418 Spring 2012 note: This code was modified from example code originally provided by Intel. To comply with Intel's open source licensing agreement, their copyright is retained below. ----------------------------------------------------------------- Copyright (c) 2010-2011, Intel Corporation All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of Intel Corporation nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/// Core computation of Mandelbrot set membershop// Iterate complex number c to determine whether it divergesstatic inline int mandel(float c_re, float c_im, int count){ float z_re = c_re, z_im = c_im; int i; for (i = 0; i &lt; count; ++i) { if (z_re * z_re + z_im * z_im &gt; 4.f) break; float new_re = z_re * z_re - z_im * z_im; float new_im = 2.f * z_re * z_im; z_re = c_re + new_re; z_im = c_im + new_im; } return i;}//// MandelbrotSerial --//// Compute an image visualizing the mandelbrot set. The resulting// array contains the number of iterations required before the complex// number corresponding to a pixel could be rejected from the set.//// * x0, y0, x1, y1 describe the complex coordinates mapping// into the image viewport.// * width, height describe the size of the output image// * startRow, endRow describe how much of the image to computevoid mandelbrotSerial( float x0, float y0, float x1, float y1, int width, int height, int startRow, int endRow, int maxIterations, int output[]){ float dx = (x1 - x0) / width; float dy = (y1 - y0) / height; for (int j = startRow; j &lt; endRow; j++) { for (int i = 0; i &lt; width; ++i) { float x = x0 + i * dx; float y = y0 + j * dy; int index = (j * width + i); output[index] = mandel(x, y, maxIterations); } }}// Struct for passing arguments to thread routinetypedef struct{ float x0, x1; float y0, y1; unsigned int width; unsigned int height; int maxIterations; int *output; int threadId; int numThreads;} WorkerArgs;//// workerThreadStart --//// Thread entrypoint.void *workerThreadStart(void *threadArgs){ WorkerArgs *args = static_cast&lt;WorkerArgs *&gt;(threadArgs); // TODO: Implement worker thread here. printf(\"Hello world from thread %d\\n\", args-&gt;threadId); //以下是我加的第一部分内容 mandelbrotSerial( args-&gt;x0, args-&gt;y0, args-&gt;x1, args-&gt;y1, args-&gt;width, args-&gt;height, args-&gt;height / args-&gt;numThreads * args-&gt;threadId, //startRow args-&gt;threadId == args-&gt;numThreads - 1 ? args-&gt;height : args-&gt;height / args-&gt;numThreads * (args-&gt;threadId + 1), //endRow args-&gt;maxIterations, args-&gt;output); //增加完毕，只需要调用串行部分的代码即可 return NULL;}//// MandelbrotThread --//// Multi-threaded implementation of mandelbrot set image generation.// Multi-threading performed via pthreads.void mandelbrotThread( int numThreads, float x0, float y0, float x1, float y1, int width, int height, int maxIterations, int output[]){ const static int MAX_THREADS = 32; if (numThreads &gt; MAX_THREADS) { fprintf(stderr, \"Error: Max allowed threads is %d\\n\", MAX_THREADS); exit(1); } pthread_t workers[MAX_THREADS]; WorkerArgs args[MAX_THREADS]; for (int i = 0; i &lt; numThreads; i++) { // TODO: Set thread arguments here. args[i].threadId = i; //以下是我加的第二段内容 args[i].x0 = x0; args[i].x1 = x1; args[i].y0 = y0; args[i].y1 = y1; args[i].width = width; args[i].height = height; args[i].maxIterations = maxIterations; args[i].output = output; args[i].numThreads = numThreads; //增加完毕，把所有信息传给worker线程即可 } // Fire up the worker threads. Note that numThreads-1 pthreads // are created and the main app thread is used as a worker as // well. for (int i = 1; i &lt; numThreads; i++) pthread_create(&amp;workers[i], NULL, workerThreadStart, &amp;args[i]); workerThreadStart(&amp;args[0]); // wait for worker threads to complete for (int i = 1; i &lt; numThreads; i++) pthread_join(workers[i], NULL);} main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;getopt.h&gt;#include \"CycleTimer.h\"extern void mandelbrotSerial( float x0, float y0, float x1, float y1, int width, int height, int startRow, int endRow, int maxIterations, int output[]);extern void mandelbrotThread( int numThreads, float x0, float y0, float x1, float y1, int width, int height, int maxIterations, int output[]);extern void writePPMImage( int *data, int width, int height, const char *filename, int maxIterations);void scaleAndShift(float &amp;x0, float &amp;x1, float &amp;y0, float &amp;y1, float scale, float shiftX, float shiftY){ x0 *= scale; x1 *= scale; y0 *= scale; y1 *= scale; x0 += shiftX; x1 += shiftX; y0 += shiftY; y1 += shiftY;}void usage(const char *progname){ printf(\"Usage: %s [options]\\n\", progname); printf(\"Program Options:\\n\"); printf(\" -t --threads &lt;N&gt; Use N threads\\n\"); printf(\" -v --view &lt;INT&gt; Use specified view settings (1-6)\\n\"); printf(\" -? --help This message\\n\");}bool verifyResult(int *gold, int *result, int width, int height){ int i, j; for (i = 0; i &lt; height; i++) { for (j = 0; j &lt; width; j++) { if (gold[i * width + j] != result[i * width + j]) { printf(\"Mismatch : [%d][%d], Expected : %d, Actual : %d\\n\", i, j, gold[i * width + j], result[i * width + j]); return 0; } } } return 1;}#define VIEWCNT 6int main(int argc, char **argv){ const int width = 1440; const int height = 900; const int maxIterations = 256; int numThreads = 2; float x0 = -2.167; float x1 = 1.167; float y0 = -1; float y1 = 1; // Support VIEWCNT views float scaleValues[VIEWCNT + 1] = {1.0f, 1.0f, 0.015f, 0.02f, 0.02f, 0.02f, 0.002f}; float shiftXs[VIEWCNT + 1] = {0.0f, 0.0f, -0.98f, 0.35f, 0.0f, -1.5f, -1.4f}; float shiftYs[VIEWCNT + 1] = {0.0f, 0.0f, 0.30f, 0.05f, 0.73f, 0.0f, 0.0f}; // parse commandline options //////////////////////////////////////////// int opt; static struct option long_options[] = { {\"threads\", 1, 0, 't'}, {\"view\", 1, 0, 'v'}, {\"help\", 0, 0, '?'}, {0, 0, 0, 0}}; while ((opt = getopt_long(argc, argv, \"t:v:?\", long_options, NULL)) != EOF) { switch (opt) { case 't': { numThreads = atoi(optarg); break; } case 'v': { int viewIndex = atoi(optarg); // change view settings if (viewIndex &gt;= 1 &amp;&amp; viewIndex &lt;= VIEWCNT) { float scaleValue = scaleValues[viewIndex]; float shiftX = shiftXs[viewIndex]; float shiftY = shiftYs[viewIndex]; scaleAndShift(x0, x1, y0, y1, scaleValue, shiftX, shiftY); } else { fprintf(stderr, \"Invalid view index\\n\"); return 1; } break; } case '?': default: usage(argv[0]); return 1; } } // end parsing of commandline options int *output_serial = new int[width * height]; int *output_thread = new int[width * height]; // // Run the serial implementation. Run the code three times and // take the minimum to get a good estimate. // memset(output_serial, 0, width * height * sizeof(int)); double minSerial = 1e30; for (int i = 0; i &lt; 3; ++i) { double startTime = CycleTimer::currentSeconds(); mandelbrotSerial(x0, y0, x1, y1, width, height, 0, height, maxIterations, output_serial); double endTime = CycleTimer::currentSeconds(); minSerial = std::min(minSerial, endTime - startTime); } printf(\"[mandelbrot serial]:\\t\\t[%.3f] ms\\n\", minSerial * 1000); writePPMImage(output_serial, width, height, \"mandelbrot-serial.ppm\", maxIterations); // // Run the threaded version // memset(output_thread, 0, width * height * sizeof(int)); double minThread = 1e30; for (int i = 0; i &lt; 5; ++i) { double startTime = CycleTimer::currentSeconds(); mandelbrotThread(numThreads, x0, y0, x1, y1, width, height, maxIterations, output_thread); double endTime = CycleTimer::currentSeconds(); minThread = std::min(minThread, endTime - startTime); } printf(\"[mandelbrot thread]:\\t\\t[%.3f] ms\\n\", minThread * 1000); writePPMImage(output_thread, width, height, \"mandelbrot-thread.ppm\", maxIterations); if (!verifyResult(output_serial, output_thread, width, height)) { printf(\"ERROR : Output from threads does not match serial output\\n\"); delete[] output_serial; delete[] output_thread; return 1; } // compute speedup printf(\"++++\\t\\t\\t\\t(%.2fx speedup from %d threads)\\n\", minSerial / minThread, numThreads); delete[] output_serial; delete[] output_thread; return 0;} Makefile123456789101112131415161718192021222324252627282930313233CXX=g++ -m64CXXFLAGS=-I../common -Iobjs/ -O3 -WallAPP_NAME=mandelbrotOBJDIR=objsCOMMONDIR=../commonPPM_CXX=$(COMMONDIR)/ppm.cppPPM_OBJ=$(addprefix $(OBJDIR)/, $(subst $(COMMONDIR)/,, $(PPM_CXX:.cpp=.o)))default: $(APP_NAME).PHONY: dirs cleandirs: /bin/mkdir -p $(OBJDIR)/clean: /bin/rm -rf $(OBJDIR) *.ppm *~ $(APP_NAME)OBJS=$(OBJDIR)/main.o $(OBJDIR)/mandelbrot.o $(PPM_OBJ)$(APP_NAME): dirs $(OBJS) $(CXX) $(CXXFLAGS) -o $@ $(OBJS) -lm -lpthread$(OBJDIR)/%.o: %.cpp $(CXX) $&lt; $(CXXFLAGS) -c -o $@$(OBJDIR)/%.o: $(COMMONDIR)/%.cpp $(CXX) $&lt; $(CXXFLAGS) -c -o $@$(OBJDIR)/main.o: $(COMMONDIR)/CycleTimer.h","link":"/2019/04/11/2019-03-25-并行与分布式计算（2）/"},{"title":"Vmware虚拟机安装和配置Ubuntu系统","text":"创建带有 SCSI 控制器类型、虚拟机磁盘类型以及与旧版 VMware 产品兼容性等高级选项的虚拟机 安装前准备： 安装好VMwareWorkstation Ubuntu16.04镜像文件 （下载地址链接：https://pan.baidu.com/s/1MSBBv9NOh7_cFgTMUQPEhQ 提取码：w6g7 ） Ubuntu18.04镜像文件 （下载地址链接：链接：https://pan.baidu.com/s/1uhPj0ttM9M7QxpR3Z4LI5g 提取码：il08 ） 一、Ubuntu的初步安装 创建新的虚拟机 点击下一步，如下图所示 选择兼容性版本 注意修改的信息 修改处理器配置信息，如下图所示 虚拟机内存配置，最低要求2GB,可以根据自己的需求修改，后期也可以再更改 此时，切记千万不要手快点开电源！！！ 二、Ubuntu系统安装设置 设置加载镜像 这些完成后就可以直接开启虚拟机了 拖动窗口，点 continue 继续下一步 设置自己的用户名和密码 : 安装进行中，等待安装 点击 Restart Now 进行重启， 如果出现如下图所示的状况，导致无法进入系统界面，需要点击Vmware的重新启动客户机按钮进行重新启动 如下图所示： 如果出现如下情况，切记千万不要选择更新 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 然后，修改hosts文件 etc目录下的hosts文件 使用vim修改编辑hosts文件sudo vi /etc/hosts 使用gedit修改编辑hosts文件sudo gedit /etc/hosts 如此，即代表系统安装成功 三、安装Vmware Tools 为了让系统能像下图一样适应客户机，需要安装Vmware Tools 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 获取管理员权限 输入以下命令，来获取管理员权限，密码是你在上面设置的密码：sudo passwd 前面我设置的密码是chuanzhi 如果上面你设置的密码不是chuanzhi,请输入你自己设置的密码 切换到 root 最高权限用户 安装Vmware tools工具 选择Vmware顶部工具栏里的 安装Vmware Tools（T）选项 在安装好的Ubuntu系统中鼠标右键选择 Open Terminal，打开Ubuntu系统的命令终端 打开终端后，进行下面设置 复制CD中的 VMwareTools-10.0.10-4301679.tar.gz 文件到根目录下： cp /media/user/VMware\\ Tools/VMwareTools-10.0.10-4301679.tar.gz / 然到移动到根目录： cd / 解压 VMwareTools-10.0.10-4301679.tar.gz： tar -zxvf VMwareTools-10.0.10-4301679.tar.gz 按下回车，执行解压 如下如所示 解压完成后进入解压文件夹vmware-tools-distrib cd vmware-tools-distrib 运行安装程序： ./vmware-install.pl 一路 y 加 回车 如下图所示 四、设置共享文件夹 设置共享文件夹，可以实现Windows系统和Ubuntu系统的复制粘贴功能 在菜单栏找到虚拟机-&gt;设置，添加自己的共享文件夹 如此，即完成了Ubuntu系统的初步设置 五、修改Ubuntu系统的更新源 更改apt源为国内源方法早就有了，内容大同小异，我们应当掌握其规律了，其实每一版内容不同的地方就是版本号（或者官方一点的说：系统代号），所以我们先了解下新版本的系统代号：使用命令：lsb_release -c得到本系统的系统代号，如下图所示：同样的我们也可以得到之前任意版本的系统代号：Ubuntu 12.04 (LTS)代号为precise。Ubuntu 14.04 (LTS)代号为trusty。Ubuntu 15.04 代号为vivid。Ubuntu 15.10 代号为wily。Ubuntu 16.04 (LTS)代号为xenial。所以这也就解释了为什么利用搜索引擎搜出来的那么多方案里面内容不尽相同的原因，因为大家更改apt安装源时用的系统不一样。 *查看系统版本代号 *lsb_release -a 注意：一定要对准自己的Ubuntu系统版本代号，检查是Ubuntu16.04还是Ubuntu18.04 下面分别提供Ubuntu16.04和ubuntu 18.04两个不同系统版本的阿里源 Ubuntu16.04对应阿里源 123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse Ubuntu18.04对应阿里源 如果是Ubuntu18.04系统可以参照我的简书配置：https://www.jianshu.com/p/e5677ebd5341 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse 修改系统更新源方法步骤如下： 首先备份Ubuntu系统的官方源文件 打开Ubuntu的命令终端，进入源文件 sources.list 所在的目录： 然后执行备份命令，执行 sudo cp sources.list sources.list.backup 对源文件内容进行备份，以防万一。 12cd /etc/aptsudo cp sources.list sources.list.backup 修改源文件内容 将上述对应系统版本的阿里源的文件内容全部复制，使用 sudo vim sources.list 打开文件，输入 ggdG（vim操作指令）删除所有内容（这句指令可以理解为删除第一行到最后一行的的全部内容） 12sudo vim sources.list # 在 /etc/apt 目录下ggdG # 使用vim打开 sources.list 文件后执行此命令 将复制的阿里源文件内容全部粘贴到文件中后，输入 : 然后再输入wq 保存退出。 值得注意的是 sources.list 文件的条目都是有格式的（通过上面的内容大家也看的出来），一般有如下形式： 12deb http://site.example.com/debian distribution component1 component2 component3deb-src http://site.example.com/debian distribution component1 component2 component3 所以后面几个参数是对软件包的分类（Ubuntu下是main， restricted，universe ，multiverse这四个）所以你把内容写成: 1234deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed universe multiverse 上面之类的也是可以的，之前我有这个疑惑，所以在这里一并告知和我有一样疑惑的朋友。 更新源 使用 sudo apt-get update 即可更新获取阿里软件源 提供的软件列表 1sudo apt-get update 更新软件 使用 sudo apt-get upgrade 即可跟新软件 1sudo apt-get upgrade 如下图所示，即代表更新成功 六、安装VIM编辑器 在Ubuntu系统的命令终端输入 sudo apt-get install vim 进行下载 检测是否安装成功 在命令终端输入 vim 回车 如上图所示，即代表安装成功 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 安装完成后的 vim 是默认不显示行号的 上图中在 /etc/vim/ 目录下打开的 输入 sudo vi vimrc后是不显示行号的，如下图所示 进入编辑界面后，按下 G 键（这是大写的 G）直接跳转到文件的最后一行 再次按下 i 键，进行编辑，输入 set number 如下图所示 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 检查设置行号是否生效 如此，即代表安装好修改配置成功 七、安装谷歌浏览器 先下载谷歌浏览器的deb安装包 下载地址如下： https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 等待下载完成 安装谷歌浏览器需执行以下两步，回到终端输入以下命令 sudo apt install libappindicator1 libindicator7 关闭终端，打开下载的存放deb包的文件夹，空白处右键在这里打开终端 输入以下命令 sudo dpkg -i google-chrome-stable_current_amd64.deb 最后在终端中输入以下命令，修复依赖关系 sudo apt -f install 至此谷歌浏览器就安装好了，现在把它设置在快速启动栏 最后将其移动到快速启动栏的合适位置，右键点击图标锁定到启动器，左键拖动选择合适位置！ 至此，谷歌浏览器即安装成功 八、安装Pycharm 下载地址：https://www.jetbrains.com/pycharm/download/#section=linux 右键安装包，点击“Extract Here”意思是提取到这里，相当于解压 提取完成后，会生成一个 pycharm-2019.1.1 的文件夹，然后双击进入该文件夹 ，空白处右键在这里打开终端 选择主题 到这里，我选择秘钥激活的方法 百度：lanyus http://idea.lanyus.com/ 修改 hosts 文件（hosts文件在 /etc 目录下） 120.0.0.0 account.jetbrains.com0.0.0.0 www.jetbrains.com 将上面两行代码添加到，hosts文件中 添加后如下图所示 退出 vim 1.按下 ESC 键 2.再输入 ： 3.最后输入 q 或 wq 即可 4.回车 获取注册码后输入 指定Python3解释器（1） 指定Python3解释器（2） 可以通过在命令终端输入：whereis python找到系统的Python解释器路径 如此，Python3的解释器便指定完成 添加Pycharm桌面快捷方式 第一步 创建Pycharm.desktop文件并用gedit的打开 sudo gedit /usr/share/applications/Pycharm.desktop 然后就会弹出一个新框 第二步 粘贴下面的代码输入并保存 123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=sh /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.shIcon=/home/python/Downloads/pycharm-2019.1.1/bin/pycharm.pngTerminal=pycharmCategories=Pycharm 注意一定要将Desktop Entry复制进去，也就是上面的全部都要复制进去 Exec 的路径是 pycharm.sh 的所在路径，即 pycharm 的启动文件 Icon 的路径是 pycharm.png 的所在路径，即 pycharm 的图标 我下载解压后的路径，如下图 路径：/home/python/Downloads/pycharm-2019.1.1/bin Exec 的路径是 pycharm.sh 的所在路径，即 pycharm 的启动文件 /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.sh Icon 的路径是 pycharm.png 的所在路径，即 pycharm 的图标 /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.png 创建的Pycharm.desktop文件如下 123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=sh /home/python/Downloads/pycharm-2019.1.1/bin/pycharm.shIcon=/home/python/Downloads/pycharm-2019.1.1/bin/pycharm.pngTerminal=pycharmCategories=Pycharm 修改完成后，即可发现Pycharm的快捷方式 如此，即表示配置成功 九、安装MySQL数据库 有两种安装方法，请将两种方法都阅读完后，再选择其中的一种方式进行安装 方法一 使用命令安装MySQL数据库 安装前先更新软件包列表： 12在终端执行如下命令：sudo apt-get update Vmware虚拟机安装和配置Ubuntu系统/ 在Ubuntu16.04上安装MySQL： 12在终端执行如下命令：sudo apt-get install mysql-server mysql-client 在安装过程中需要你输入MySQL管理员用户（root）密码，如下图 如上即代表安装完成 方法二 通过APT方式安装 说明：此种方式完全参考官方提供的教程:地址：https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/ 注意：通过APT方式安装的版本都是现在最新的版本，现在我安装的是5.7.18。通过这种方式安装好之后开机自启动都已经配置好，和命令行上的环境变量，无需手动配置。 下载官方提供的mysql-apt-config.deb包进行APT源设置，下载地址：https://dev.mysql.com/downloads/repo/apt/ 找到下载的包路径 输入如下命令： sudo dpkg -i mysql-apt-config_0.8.12-1_all.deb 运行之后会出现如下界面： 一般只需要默认，按方向键选择OK回车即可。 完成后使用以下命令从MySQL APT存储库更新包信息（此步骤是必需的）： sudo apt-get update 说明：官方说通过这个工具这样操作之后，安装MySQL时就是按照上面选择的来进行。 安装 通过以下命令安装MySQL sudo apt-get install mysql-server 这将安装MySQL服务器的包，以及客户端和数据库公共文件的包。 此时如果提示依赖不足，如下所示： 如果没出现依赖问题，那么就不需要使用此命令。 ​ 那么需要运行下面命令解决依赖问题 ​ sudo apt-get install -f ​ 安装MySQL时会一并安装如下所示的软件： 完成后再次运行 sudo apt-get install mysql-server 如果没出现依赖问题，那么就不需要使用此命令。 在安装过程中，系统会要求您为MySQL安装的root用户提供密码,输入即可,如下所示： 重要 确保记住您设置的root密码。想要稍后设置密码的用户可以在对话框中将 密码字段留空，只需按确定即可 ; 在这种情况下，对于使用Unix套接字文件的连接，将通过Socket Peer-Credential Pluggable Authentication对服务器的root访问进行身份 验证。您可以稍后使用程序mysql_secure_installation设置root密码 。 我这里密码设置为：mysql (为了避免忘记密码，建议设置为:mysql) MySQL8.0采用了新的加密方式，一定要注意，正是因为这个加密方式才导致Ubuntu18.04用设置的root密码登录不了MySQL，因为Ubuntu18.04的终端可能有问题，并不支持这个新的加密方式。幸好有界面可以让我们选择使用旧版本5.x的加密方式，所以果断选择采用5.x的加密方式。 确认密码","link":"/2018/05/22/Vmware虚拟机安装和配置Ubuntu系统/"},{"title":"单周期CPU设计","text":"实验目的 掌握单周期CPU数据通路图的构成、原理及其设计方法； 掌握单周期CPU的实现方法，代码实现方法； 认识和掌握指令与CPU的关系； 掌握测试单周期CPU的方法。 实验内容设计一个单周期CPU，该CPU至少能实现以下指令功能操作，指令与格式如下。 算术运算指令add rd rs rt 000000 rs(5位) rt(5位) rd(5位) reserved 功能：rd←rs + rt；reserved为预留部分，即未用，一般填“0”。 sub rd rs rt 000001 rs(5位) rt(5位) rd(5位) reserved 功能：rd←rs - rt。 addiu rt rs immediate 000010 rs(5位) rt(5位) immediate(16位) 功能：rt←rs + (sign-extend)immediate；immediate符号扩展再参加“加”运算。 逻辑运算指令andi rt rs immediate|010000|rs(5位)|rt(5位)|immediate(16位)||-|-|-|-|-||||||| 功能：rt←rs &amp; (zero-extend)immediate；immediate做“0”扩展再参加“与”运算。 and rd rs rt 010001 rs(5位) rt(5位) rd(5位) reserved - - - - - 功能：rd←rs &amp; rt；逻辑与运算。 ori rt rs immediate 010010 rs(5位) rt(5位) immediate(16位) 功能：rt←rs | (zero-extend)immediate；immediate做“0”扩展再参加“或”运算。 or rd rs rt 010011 rs(5位) rt(5位) rd(5位) reserved 功能：rd←rs | rt；逻辑或运算。 移位指令sll rd rt sa 011000 未用 rt(5位) rd(5位) sa(5位) reserved 功能：rd&lt;－rt&lt;&lt;(zero-extend)sa，左移sa位 ，(zero-extend)sa。 比较指令slti rt rs immediate 011100 rs(5位) rt(5位) immediate(16位) 功能：if (rs&lt; (sign-extend)immediate) rt =1 else rt=0, 带符号比较，详见ALU运算功能表。 存储器读/写指令sw rt immediate(rs) 100110 rs(5位) rt(5位) immediate(16位) 功能：memory[rs+ (sign-extend)immediate]←rt；immediate符号扩展再相加。即将rt寄存器的内容保存到rs寄存器内容和立即数符号扩展后的数相加作为地址的内存单元中。 lw rt immediate(rs) 100111 rs(5位) rt(5位) immediate(16位) 功能：rt ← memory[rs + (sign-extend)immediate]；immediate符号扩展再相加。即读取rs寄存器内容和立即数符号扩展后的数相加作为地址的内存单元中的数，然后保存到rt寄存器中。 分支指令beq rs rt immediate 110000 rs(5位) rt(5位) immediate(16位) 功能：if(rs=rt) pc←pc + 4 + (sign-extend)immediate &lt;&lt;2 else pc ←pc + 4特别说明：immediate是从PC+4地址开始和转移到的指令之间指令条数。immediate符号扩展之后左移2位再相加。为什么要左移2位？由于跳转到的指令地址肯定是4的倍数（每条指令占4个字节），最低两位是“00”，因此将immediate放进指令码中的时候，是右移了2位的，也就是以上说的“指令之间指令条数”。 bne rs rt immediate 110001 rs(5位) rt(5位) immediate(16位) 功能：if(rs!=rt) pc←pc + 4 + (sign-extend)immediate &lt;&lt;2 else pc ←pc + 4特别说明：与beq不同点是，不等时转移，相等时顺序执行。 bltz rs immediate 110010 rs(5位) 00000 immediate(16位) 功能：if(rs&lt;$zero) pc←pc + 4 + (sign-extend)immediate &lt;&lt;2 else pc ←pc + 4。 跳转指令j addr 111000 addr[27:2] 功能：pc &lt;－{(pc+4)[31:28],addr[27:2],2’b00}，无条件跳转。说明：由于MIPS32的指令代码长度占4个字节，所以指令地址二进制数最低2位均为0，将指令地址放进指令代码中时，可省掉！这样，除了最高6位操作码外，还有26位可用于存放地址，事实上，可存放28位地址，剩下最高4位由pc+4最高4位拼接上。 停机指令halt 111111 00000000000000000000000000(26位) 功能：停机；不改变PC的值，PC保持不变。 实验原理单周期CPU指的是一条指令的执行在一个时钟周期内完成，然后开始下一条指令的执行，即一条指令用一个时钟周期完成。电平从低到高变化的瞬间称为时钟上升沿，两个相邻时钟上升沿之间的时间间隔称为一个时钟周期。时钟周期一般也称振荡周期（如果晶振的输出没有经过分频就直接作为CPU的工作时钟，则时钟周期就等于振荡周期。若振荡周期经二分频后形成时钟脉冲信号作为CPU的工作时钟，这样，时钟周期就是振荡周期的两倍）。 CPU在处理指令的几个步骤123456graph LR取指令IF--&gt;指令译码ID指令译码ID--&gt;指令执行EXE指令执行EXE--&gt;存储器访问MEM存储器访问MEM--&gt;结果写回WB结果写回WB--&gt;取指令IF 图1 CPU指令处理过程 取指令(IF)根据程序计数器PC中的指令地址，从存储器中取出一条指令，同时，PC根据指令字长度自动递增产生下一条指令所需要的指令地址，但遇到“地址转移”指令时，则控制器把“转移地址”送入PC，当然得到的“地址”需要做些变换才送入PC。 指令译码(ID)对取指令操作中得到的指令进行分析并译码，确定这条指令需要完成的操作，从而产生相应的操作控制信号，用于驱动执行状态中的各种操作。 指令执行(EXE)根据指令译码得到的操作控制信号，具体地执行指令动作，然后转移到结果写回状态。 存储器访问(MEM)所有需要访问存储器的操作都将在这个步骤中执行，该步骤给出存储器的数据地址，把数据写入到存储器中数据地址所指定的存储单元或者从存储器中得到数据地址单元中的数据。 结果写回(WB)指令执行的结果或者访问存储器中得到的数据写回相应的目的寄存器中。单周期CPU，是在一个时钟周期内完成这五个阶段的处理。 MIPS指令的三种格式 缩写 说明 op 操作码 rs 只读，为第1个源操作数寄存器，寄存器地址（编号）是00000~11111，00~1F rt 可读可写，为第2个源操作数寄存器，或目的操作数寄存器，寄存器地址（同上） rd 只写，为目的操作数寄存器，寄存器地址（同上） sa 位移量（shift amt），移位指令用于指定移多少位 funct 功能码，在寄存器类型指令中（R类型）用来指定指令的功能与操作码配合使用 immediate 16位立即数，用作无符号的逻辑操作数、有符号的算术操作数、数据加载（Laod）/数据保存（Store）指令的数据地址字节偏移量和分支指令中相对程序计数器（PC）的有符号偏移量； address 地址 R类型 31-26 25-21 20-16 15-11 10-6 5-0 op rs rt rd sa func 6位 5位 5位 5位 5位 6位 I类型 31-26 25-21 20-16 15-0 op rs rt immediate 6位 5位 5位 16位 J类型 31-26 25-0 op address 6位 26位 单周期CPU数据通路和控制线路图 上图是一个简单的基本上能够在单周期CPU上完成所要求设计的指令功能的数据通路和必要的控制线路图。 指令执行的结果总是在时钟下降沿保存到寄存器和存储器中，PC的改变是在时钟上升沿进行的，这样稳定性较好。另外，值得注意的问题，设计时，用模块化的思想方法设计，关于ALU设计、存储器设计、寄存器组设计等等，也是必须认真考虑的问题。 其中指令和数据各存储在不同存储器中，即有指令存储器和数据存储器。访问存储器时，先给出内存地址，然后由读或写信号控制操作。对于寄存器组，先给出寄存器地址，读操作时不需要时钟信号，输出端就直接输出相应数据；而在写操作时，在 WE使能信号为1时，在时钟边沿触发将数据写入寄存器。 控制信号的作用表以上数据通路图是根据要实现的指令功能的要求画出来的，同时，还必须确定ALU的运算功能(当然，以上指令没有完全用到提供的ALU所有功能，但至少必须能实现以上指令功能操作)。从数据通路图上可以看出控制单元部分需要产生各种控制信号，当然，也有些信号必须要传送给控制单元。从指令功能要求和数据通路图的关系得出以上表1，这样，从表1可以看出各控制信号与相应指令之间的相互关系，根据这种关系就可以得出控制信号与指令之间的关系（见下面表中的“相关指令”），从而写出各控制信号的逻辑表达式，这样控制单元部分就可实现了。 控制信号名 状态“0” 状态“1” Reset 初始化PC为0 PC接收新地址 PCWre PC不更改，相关指令：halt PC更改，相关指令：除指令halt外 ALUSrcA 来自寄存器堆data1输出，相关指令：add、sub、addiu、or、and、andi、ori、slti、beq、bne、bltz、sw、lw 来自移位数sa，同时，进行(zero-extend)sa，即，相关指令：sll ALUSrcB 来自寄存器堆data2输出，相关指令：add、sub、or、and、beq、bne、bltz 来自sign或zero扩展的立即数，相关指令：addiu、andi、ori、slti、sw、lw DBDataSrc 来自ALU运算结果的输出，相关指令：add、addiu、sub、ori、or、and、andi、slti、sll 来自数据存储器（Data MEM）的输出，相关指令：lw RegWre 无写寄存器组寄存器，相关指令：beq、bne、bltz、sw、halt 寄存器组写使能，相关指令：add、addiu、sub、ori、or、and、andi、slti、sll、lw InsMemRW 写指令存储器 读指令存储器(Ins. Data) mRD 输出高阻态 读数据存储器，相关指令：lw mWR 无操作 写数据存储器，相关指令：sw RegDst 写寄存器组寄存器的地址，来自rt字段，相关指令：addiu、andi、ori、slti、lw 写寄存器组寄存器的地址，来自rd字段，相关指令：add、sub、and、or、sll ExtSel (zero-extend)immediate（0扩展），相关指令：andi、ori (sign-extend)immediate（符号扩展），相关指令：addiu、slti、sw、lw、beq、bne、bltz ALUOp的功能表 ALUOp[2..0] 功能 描述 相关指令 000 Y=A+B 加 add、addiu、sw、lw、j、halt 001 Y=A–B 减 sub、beq、bne、bltz 010 Y=B&lt;&lt;A B左移A位 sll 011 Y=A∨B 或 ori、or 100 Y=A∧B 与 andi、and 101 Y=A&lt;B 不带符号比较A&lt;B 110 Y=A[31]!=B[31]?A[31]&gt;B[31]:A&lt;B 带符号比较A&lt;B slti 111 Y=A^B 异或 PCSrc的功能表|PCSrc[1..0]|功能|相关指令||-|-|-|-||00|pc&lt;－pc+4|add、addiu、sub、or、ori、and、andi、slti、sll、sw、lw、beq(zero=0)、bne(zero=1)、bltz(sign=0)||01|pc&lt;－pc+4+(sign-extend)immediate&lt;&lt;2|beq(zero=1)、bne(zero=0)、bltz(sign=1)||10|pc&lt;－{(pc+4)[31:28],addr[27:2],2’b00}|j||11|未用| 相关部件及引脚说明：Instruction Memory指令存储器。 Iaddr 指令存储器地址输入端口 IDataIn 指令存储器数据输入端口（指令代码输入端口） IDataOut 指令存储器数据输出端口（指令代码输出端口） RW 指令存储器读写控制信号，为0写，为1读 Data Memory数据存储器。 Daddr 数据存储器地址输入端口 DataIn 数据存储器数据输入端口 DataOut 数据存储器数据输出端口 RD 数据存储器读控制信号，为0读 WR 数据存储器写控制信号，为0写 Register File：寄存器组。 Read Reg1 rs寄存器地址输入端口 Read Reg2 rt寄存器地址输入端口 Write Reg 将数据写入的寄存器端口，其地址来源rt或rd字段 Write Data 写入寄存器的数据输入端口 Read Data1 rs寄存器数据输出端口 Read Data2 rt寄存器数据输出端口 WE 写使能信号，为1时，在时钟边沿触发写入 ALU： 算术逻辑单元 result ALU运算结果 zero 运算结果标志，结果为0，则zero=1；否则zero=0 sign 运算结果标志，结果最高位为0，则sign=0，正数；否则，sign=1，负数 实验器材电脑一台，Xilinx Vivado 2017.4 软件一套，Basys3实验板一块。 实验过程与结果代码实现SingleCPU.v单周期CPU的顶层连接文件，主要是调用下层模块并将它们输入输出连在一起，并计算下一个指令的地址（正常+4或跳转）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546`timescale 1ns / 1psmodule SingleCPU( input CLK, //时钟信号 input Reset, //置零信号 output[31:0] CurPC, //当前指令地址 output[31:0] newaddress, //下一个指令地址 output[31:0] instcode, //rs,rt寄存器所在指令 output[31:0] Reg1Out, //寄存器组rs寄存器的值 output[31:0] Reg2Out, //寄存器组rt寄存器的值 output[31:0] ALU_Out, //ALU的result输出值 output[31:0] WriteData //DB总线值); wire ExtSel; //位扩展信号，1为符号扩展，0为0扩展 wire PCWre; //PC工作信号，0不更改，1更改 wire InsMemRW; //指令寄存器信号，0为写，1为读 wire RegDst; //指令读取时判断是rt还是rd进入寄存器组的写数据端，0为rt，1为rd wire RegWre; //寄存器组是否需要写功能，0为无写功能，1为些功能 wire[2:0] ALUOp; //ALU8种运算功能选择 wire[1:0] PCSrc; //PC正常+4还是要跳转，0为正常+4，1为跳转 wire ALUSrcA; //寄存器组Data1的输出，0为寄存器本身输出，1为指令码的最后16位立即数 wire ALUSrcB; //寄存器组Data2的输出，0位本身的输出，1为扩展后的立即数 wire RD; //读数据存储器功能，0时读取 wire WR; //写数据存储器功能，1时写 wire DBDataSrc; //决定将什么数据传入寄存器组Write Data端，0为ALU结果，1为存储器 wire[4:0] WriteRegAddr; //寄存器组Write Reg输入端 wire[31:0] ALU_Input_A; //ALU的A输入端 wire[31:0] ALU_Input_B; //ALU的B输入端 wire zero; //ALU的zero输出 wire sign; //ALU的sign输出 wire[31:0] MemOut; //存储器的输出 wire[31:0] Ext_Imm; //位扩展后的立即数 wire[31:0] CurPC4=CurPC+4; assign newaddress= (PCSrc==2'b01)?{CurPC4[31:28],instcode[25:0],2'b00}: (PCSrc==2'b10)?CurPC4+(Ext_Imm&lt;&lt;2):CurPC4; PC pc(CLK,Reset,PCWre,newaddress,CurPC); ALU alu(ALU_Input_A,ALU_Input_B,ALUOp,ALU_Out,zero,sign); DataMemory dm(ALU_Out,CLK,RD,WR,Reg2Out,MemOut); SignZeroExtend sze(instcode[15:0],ExtSel,Ext_Imm); Multiplexer5 mux21R(RegDst,instcode[20:16],instcode[15:11],WriteRegAddr); Multiplexer32 mux21A(ALUSrcA,Reg1Out,{27'b000000000000000000000000000,instcode[10:6]},ALU_Input_A); Multiplexer32 mux21B(ALUSrcB,Reg2Out,Ext_Imm,ALU_Input_B); Multiplexer32 mux21RW(DBDataSrc,ALU_Out,MemOut,WriteData); RegisterFile rf(RegWre,CLK,instcode[25:21],instcode[20:16],WriteRegAddr,WriteData,Reg1Out,Reg2Out); ControlUnit cu(ExtSel,PCWre,InsMemRW,RegDst,RegWre,ALUOp,PCSrc,ALUSrcA,ALUSrcB,RD,WR,DBDataSrc,instcode[31:26],zero,sign); InstructionMemory im(CurPC,InsMemRW,instcode);endmodule ControlUnit.v控制信号模块，通过解析op得到该指令的各种控制信号。定义了很多用到的常量，可读性还是比较高的。控制单元通过输入的zero零标志位与当前指令中对应的指令部分来确定当前整个CPU程序中各模块的工作和协作情况，根据CPU运行逻辑，事先对整个CPU中控制信号的控制，以此来达到指挥各个模块协同工作的目的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061`timescale 1ns / 1psmodule ControlUnit( output ExtSel, output PCWre, output InsMemRW, output RegDst, output RegWre, output[2:0] ALUOp, output[1:0] PCSrc, output ALUSrcA, output ALUSrcB, output mRD, output mWR, output DBDataSrc, input[5:0] op, input zero, input sign); parameter ADD= 6'b000000; parameter SUB= 6'b000001; parameter ADDIU= 6'b000010; parameter ANDI= 6'b010000; parameter AND= 6'b010001; parameter ORI= 6'b010010; parameter OR= 6'b010011; parameter SLL= 6'b011000; parameter SLTI= 6'b011100; parameter SW= 6'b100110; parameter LW= 6'b100111; parameter BEQ= 6'b110000; parameter BNE= 6'b110001; parameter BLTZ= 6'b110010; parameter J= 6'b111000; parameter HALT= 6'b111111; parameter _ADD= 3'b000; parameter _SUB= 3'b001; parameter _SLL= 3'b010; parameter _OR= 3'b011; parameter _AND= 3'b100; parameter _SLTU= 3'b101; parameter _SLT= 3'b110; parameter _XOR= 3'b111; assign PCWre= op!=HALT; assign ALUSrcA= op==SLL; assign ALUSrcB= op==ADDIU||op==ANDI||op==ORI||op==SLTI||op==SW||op==LW; assign DBDataSrc= op==LW; assign RegWre= op!=BEQ&amp;&amp;op!=BNE&amp;&amp;op!=BLTZ&amp;&amp;op!=SW&amp;&amp;op!=HALT; assign InsMemRW= 0; assign mRD= op==LW; assign mWR= op==SW; assign RegDst= op!=ADDIU&amp;&amp;op!=ANDI&amp;&amp;op!=ORI&amp;&amp;op!=SLTI&amp;&amp;op!=LW; assign ExtSel= op!=ANDI&amp;&amp;op!=ORI; assign PCSrc[0]= op==J; assign PCSrc[1]= op==BEQ&amp;&amp;zero==1||op==BNE&amp;&amp;zero==0||op==BLTZ&amp;&amp;sign==1; assign ALUOp= op==SUB||op==BNE||op==BEQ||op==BLTZ?_SUB: op==SLL?_SLL: op==ORI||op==OR?_OR: op==ANDI||op==AND?_AND: op==SLTI?_SLT:_ADD;endmodule ALU.v该部分为算术逻辑单元，用于逻辑指令计算和跳转指令比较。ALUOp用于控制算数的类型，A、B为输入数，result为运算结果，zero、sign主要用于beq、bne、bltz等指令的判断。ALU算术逻辑单元的功能是根据控制信号从输入的数据中选取对应的操作数，根据操作码进行运算并输出结果与零标志位。 1234567891011121314151617181920212223242526272829303132333435`timescale 1ns / 1psmodule ALU( input[31:0] A, //输入A input[31:0] B, //输入B input[2:0] ALUOp, //ALU操作控制 output reg[31:0] result, //ALU运算结果 output zero, //运算结果result的标志，result为0输出1，否则输出0 output sign //运算结果result的正负性（有符号数的情况），result为负数输出1，否则输出0); parameter _ADD= 3'b000; parameter _SUB= 3'b001; parameter _SLL= 3'b010; parameter _OR= 3'b011; parameter _AND= 3'b100; parameter _SLTU= 3'b101; parameter _SLT= 3'b110; parameter _XOR= 3'b111; assign zero= result==0; assign sign= result[31]; always@(*)begin //进行ALU计算 case(ALUOp) //进行运算 _ADD: result= A+B; //加法 _SUB: result= A-B; //减法 _SLL: result= B&lt;&lt;A; //B左移A位 _OR: result= A|B; //或 _AND: result= A&amp;B; //与 _SLTU: result= A&lt;B; //比较A&lt;B不带符号 _SLT: result= A[31]!=B[31]?A[31]&gt;B[31]:A&lt;B; //比较A&lt;B带符号 _XOR: result= A^B; //异或 default: result= 0; endcase endendmodule DataMemory.v该部分控制内存存储，用于内存存储、读写。用255大小的8位寄存器数组模拟内存，采用小端模式。DataMenRW控制内存读写。由于指令为真实地址，所以不需要&lt;&lt;2。 123456789101112131415161718192021222324252627`timescale 1ns / 1psmodule DataMemory( input[31:0] DAddr, input CLK, input mRD, input mWR, input[31:0] DataIn, output reg[31:0] DataOut); reg[7:0] dataMemory [255:0]; always@(mRD or DAddr)begin if(mRD)begin DataOut[7:0]= dataMemory[DAddr+3]; DataOut[15:8]= dataMemory[DAddr+2]; DataOut[23:16]= dataMemory[DAddr+1]; DataOut[31:24]= dataMemory[DAddr]; end end always@(negedge CLK)begin //总是在时钟下降沿到来时触发 if(mWR)begin dataMemory[DAddr+3]&lt;= DataIn[7:0]; dataMemory[DAddr+2]&lt;= DataIn[15:8]; dataMemory[DAddr+1]&lt;= DataIn[23:16]; dataMemory[DAddr]&lt;= DataIn[31:24]; end endendmodule InstructionMemory.v该部分为指令寄存器，通过一个256大小的8位寄存器数组来保存从文件输入的全部指令。然后通过输入的地址，找到相应的指令，输出到IDataOut。指令存储器的功能是存储读入的所有32-bit位宽的指令，根据程序计数器PC中的指令地址进行取指令操作并对指令类型进行分析，通过指令类型对所取指令的各字段进行区分识别，最后将对应部分传递给其他模块进行后续处理。指令存储器中每个单元的位宽为8-bit，也就是存储每条32-bit位宽的指令都需要占据4个单元，所以第n（n大于或等于0）条指令所对应的起始地址为4n，且占据第4n，4n+1，4n+2，4n+3这四个单元。取出指令就是将这四个单元分别取出，因为指令的存储服从高位指令存储在低位地址的规则，所以4n单元中的字段是该条指令的最高8位，后面以此类推，并通过左移操作将指令的四个单元部分移动到相对应的位置，以此来得到所存指令。 12345678910111213141516`timescale 1ns / 1psmodule InstructionMemory( input[31:0] IAddr, input RW, output reg[31:0] IDataOut); reg[7:0] InstMemory[255:0]; initial begin //此处为绝对地址，注意斜杠方向 $readmemb(\"C:/Users/wukan/Documents/VIVADO/SingleCPU/input.txt\",InstMemory); end always@(IAddr or RW)begin if(RW==0)begin IDataOut= {InstMemory[IAddr],InstMemory[IAddr+1],InstMemory[IAddr+2],InstMemory[IAddr+3]}; end endendmodule Multiplexer32.v三十二线双路选择器。 123456789`timescale 1ns / 1psmodule Multiplexer32( input Select, input[31:0] DataIn1, input[31:0] DataIn2, output[31:0] DataOut); assign DataOut= Select?DataIn2:DataIn1;endmodule Multiplexer5.v五线双路选择器。 123456789`timescale 1ns / 1psmodule Multiplexer5( input Select, input[4:0] DataIn1, input[4:0] DataIn2, output[4:0] DataOut); assign DataOut= Select?DataIn2:DataIn1;endmodule PC.vCLK上升沿触发，更改指令地址。由于指令地址存储在寄存器里，一开始需要赋currentAddress为0。Reset是重置信号，当为1时，指令寄存器地址重置。PCWre的作用为保留现场，如果PCWre为0，指令地址不变。PC程序计数器用于存放当前指令的地址，当PC的值发生改变的时候，CPU会根据程序计数器PC中新得到的指令地址，从指令存储器中取出对应地址的指令。在单周期CPU的运行周期中，PC值的变化是最先的，而且是根据PCSrc控制信号的值选择指令地址是要进行PC+4或者跳转等操作。若PC程序计数器检测到Reset输入信号为0时，则对程序计数器存储的当前指令地址进行清零处理。 1234567891011121314151617181920`timescale 1ns / 1psmodule PC( input CLK, input Reset, input PCWre, input[31:0] newAddress, output reg[31:0] PCAddr); initial begin PCAddr= 0; end always@(posedge CLK or negedge Reset)begin if(Reset==0)begin PCAddr= 0; end else if(PCWre)begin PCAddr= newAddress; end endendmodule RegisterFile.v该部分为寄存器读写单元，储存寄存器组，并根据地址对寄存器组进行读写。WE的作用是控制寄存器是否写入。同上，通过一个32大小的32位寄存器数组来模拟寄存器，开始时全部置0。通过访问寄存器的地址，来获取寄存器里面的值，并进行操作。（由于$0恒为0，所以写入寄存器的地址不能为0）寄存器组中的每个寄存器位宽32-bit,是存放ALU计算所需要的临时数据的,与数据存储器不同，可能会在程序执行的过程中被多次覆盖，而数据存储器内的数据一般只有sw指令才能进行修改覆盖。寄存器组会根据操作码opCode与rs，rt字段相应的地址读取数据,同时将rs，rt寄存器的地址和其中的数据输出，在CLK的下降沿到来时将数据存放到rd或者rt字段的相应地址的寄存器内。 123456789101112131415161718192021222324`timescale 1ns / 1psmodule RegisterFile( input WE, input CLK, input[4:0] ReadReg1, input[4:0] ReadReg2, input[4:0] WriteReg, input[31:0] WriteData, output[31:0] ReadData1, output[31:0] ReadData2); reg[31:0] registers[0:31]; integer i; initial begin //初始时，将32个寄存器全部赋值为0 for(i=0; i&lt;32; i=i+1)registers[i]&lt;= 0; end assign ReadData1= ReadReg1?registers[ReadReg1]:0; assign ReadData2= ReadReg2?registers[ReadReg2]:0; always@(negedge CLK)begin if(WriteReg&amp;&amp;WE)begin registers[WriteReg]= WriteData; end endendmodule SignZeroExtend.v比较简单的一个模块，用于立即数的扩展。ExtSel为控制补位信号。判断后，将extendImmediate的前16位全补1或0即可。 12345678`timescale 1ns / 1psmodule SignZeroExtend( input[15:0] immediate, input ExtSel, output[31:0] extendImmediate); assign extendImmediate= {ExtSel&amp;&amp;immediate[15]?16'hffff:16'h0000,immediate};endmodule 仿真检验将指令转换成二进制代码，如下表： 地址 汇编程序 op（6） rs(5) rt(5) rd(5)/immediate(16) 16进制数代码 0x00000000 addiu $1,$0,8 000010 00000 00001 00000000 00001000 08010008 0x00000004 ori $2,$0,2 010010 00000 00010 00000000 00000010 48020002 0x00000008 add $3,$2,$1 000000 00010 00001 00011000 00000000 00411800 0x0000000C sub $5,$3,$2 000001 00011 00010 00101000 00000000 04622800 0x00000010 and $4,$5,$2 010001 00101 00010 00100000 00000000 44a22000 0x00000014 or $8,$4,$2 010011 00100 00010 01000000 00000000 4c824000 0x00000018 sll $8,$8,1 011000 00000 01000 01000000 01000000 60084040 0x0000001C bne $8,$1,-2 110001 01000 00001 11111111 11111110 c501fffe 0x00000020 slti $6,$2,4 011100 00010 00110 00000000 00000100 70460004 0x00000024 slti $7,$6,0 011100 00110 00111 00000000 00000000 70c70000 0x00000028 addiu $7,$7,8 000010 00111 00111 00000000 00001000 08e70008 0x0000002C beq $7,$1,-2 110000 00111 00001 11111111 11111110 c0e1fffe 0x00000030 sw $2,4($1) 100110 00001 00010 00000000 00000100 98220004 0x00000034 lw $9,4($1) 100111 00001 01001 00000000 00000100 9c290004 0x00000038 addiu $10,$0,-2 000010 00000 01010 11111111 11111110 080afffe 0x0000003C addiu $10,$10,1 000010 01010 01010 00000000 00000001 094a0001 0x00000040 bltz $10,-2 110010 01010 00000 11111111 11111110 c940fffe 0x00000044 andi $11,$2,2 010000 00010 01011 00000000 00000010 404b0002 0x00000048 j 0x00000050 111000 00000 00000 00000000 00010100 e0000014 0x0000004C or $8,$4,$2 010011 00100 00010 01000000 00000000 4c824000 0x00000050 halt 111111 00000 00000 00000000 00000000 fc000000 input.txt12345678910111213141516171819202100001000 00000001 00000000 0000100001001000 00000010 00000000 0000001000000000 01000001 00011000 0000000000000100 01100010 00101000 0000000001000100 10100010 00100000 0000000001001100 10000010 01000000 0000000001100000 00001000 01000000 0100000011000101 00000001 11111111 1111111001110000 01000110 00000000 0000010001110000 11000111 00000000 0000000000001000 11100111 00000000 0000100011000000 11100001 11111111 1111111010011000 00100010 00000000 0000010010011100 00101001 00000000 0000010000001000 00001010 11111111 1111111000001001 01001010 00000000 0000000111001001 01000000 11111111 1111111001000000 01001011 00000000 0000001011100000 00000000 00000000 0001010001001100 10000010 01000000 0000000011111100 00000000 00000000 00000000 Sim.v仿真模块。 123456789101112131415161718`timescale 1ns / 1psmodule Sim; reg CLK; //时钟信号 reg Reset; //置零信号 SingleCPU scpu(CLK,Reset); initial begin CLK= 0; Reset= 0; //刚开始设置pc为0 #50; //等待Reset完成 CLK= !CLK; //下降沿，使PC先清零 #50; Reset= 1; //清除保持信号 forever #50 begin //产生时钟信号，周期为50s CLK= !CLK; end endendmodule 仿真波形波形比较长，分成三部分逐一分析。前100ps为初始化，各寄存器的值被初始化为0。第800ps时执行了bne $8,$1,-2，此时寄存器$8的值是4，寄存器$1的值是8，两者不等，发生了一步跳转，于是第900ps的地址跳转到00000018。在第900ps前寄存器111的值依次为（16进制）8,2,a,0,8,0,0,4,0,0,0。第1000ps时再次执行了bne $8,$1,-2，此时寄存器$8的值是8，寄存器$1的值是8，两者相等，pc+4执行下一条指令。第1400ps时执行了beq $7,$1,-2，此时寄存器$7的值是8，寄存器$1的值是8，两者相等，发生了一步跳转，于是第1500ps的地址跳转到00000028。第1600ps时再次执行了beq $7,$1,-2，此时寄存器$7的值是10，寄存器$1的值是8，两者不等，pc+4执行下一条指令。在第1800ps前寄存器111的值依次为（16进制）8,2,a,0,8,1,10,8,0,0,0。第2100ps时执行了bltz $10,-2，此时寄存器$10的值是ffffffff，小于0，发生了一步跳转，于是第2200ps的地址跳转到0000003c。第2300ps时再次执行了bltz $10,-2，此时寄存器$10的值是0，不小于0，pc+4执行下一条指令。第2500ps时执行了j 0x00000050，于是第2600ps的地址跳转到00000050。第2600ps时执行了halt，程序终止，pc不再跳转。在第2700ps前寄存器1~11的值依次为（16进制）8,2,a,0,8,1,10,8,2,0,2。 烧写到Basys3实验板Basys3.v顶层模块。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697`timescale 1ns / 1psmodule Basys3( input CLK, input[1:0] SW, //选择输出信号 input Reset, //重置按钮 input Button, //单脉冲 output reg[3:0] AN, //数码管位选择信号 output[7:0] Out //数码管输入信号); parameter T1MS= 100000; reg[16:0] showCounter; wire[31:0] ALU_Out; //ALU的result输出值 wire[31:0] CurPC; wire[31:0] WriteData; //DB总线值 wire[31:0] Reg1Out; //寄存器组rs寄存器的值 wire[31:0] Reg2Out; //寄存器组rt寄存器的值 wire[31:0] instcode; wire myCLK; reg[3:0] store; //记录当前要显示位的值 wire[31:0] newAddress; SingleCPU scpu(myCLK,Reset,CurPC,newAddress,instcode,Reg1Out,Reg2Out,ALU_Out,WriteData); Debounce debounce(CLK,Button,myCLK); initial begin showCounter&lt;= 0; AN&lt;= 4'b0111; end always@(posedge CLK) begin if(Reset==0)begin showCounter&lt;= 0; AN&lt;= 4'b0000; end else begin showCounter&lt;= showCounter+1; if(showCounter==T1MS) begin showCounter&lt;= 0; case(AN) 4'b1110: begin AN&lt;= 4'b1101; end 4'b1101: begin AN&lt;= 4'b1011; end 4'b1011: begin AN&lt;= 4'b0111; end 4'b0111: begin AN&lt;= 4'b1110; end 4'b0000: begin AN&lt;= 4'b0111; end endcase end end end SegLED led(store,Reset,Out); always@(myCLK)begin case(AN) 4'b1110: begin case(SW) 2'b00: store&lt;= newAddress[3:0]; 2'b01: store&lt;= Reg1Out[3:0]; 2'b10: store&lt;= Reg2Out[3:0]; 2'b11: store&lt;= WriteData[3:0]; endcase end 4'b1101: begin case(SW) 2'b00: store&lt;= newAddress[7:4]; 2'b01: store&lt;= Reg1Out[7:4]; 2'b10: store&lt;= Reg2Out[7:4]; 2'b11: store&lt;= WriteData[7:4]; endcase end 4'b1011: begin case(SW) 2'b00: store&lt;= CurPC[3:0]; 2'b01: store&lt;= instcode[24:21]; 2'b10: store&lt;= instcode[19:16]; 2'b11: store&lt;= ALU_Out[3:0]; endcase end 4'b0111 : begin case(SW) 2'b00: store&lt;= CurPC[7:4]; 2'b01: store&lt;= {3'b000,instcode[25]}; 2'b10: store&lt;= {3'b000,instcode[20]}; 2'b11: store&lt;= ALU_Out[7:4]; endcase end endcase endendmodule Debounce.v按键消抖模块。Basys3板采用的是机械按键，在按下按键时按键会出现人眼无法观测但是系统会检测到的抖动变化，这可能会使短时间内电平频繁变化，导致程序接收到许多错误的触发信号而出现许多不可知的错误。消抖操作是每当检测到CLK上升沿到来时检测一次当前电平信号并记录，同计数器开始计数，若在计数器达到5000之前电平发生变化，则将计数器清零，若达到5000，则将该记录电平取反输出。因为程序开始时已经运行第一条指令，为避免跳过第一条指令计算值的写入，我们的输入需要从下降沿开始，因此我们给按键信号取反后再输入。 1234567891011121314151617181920`timescale 1ns / 1psmodule Debounce(clk,key_in,key_out); parameter SAMPLE_TIME= 5000; input clk; input key_in; output key_out; reg[21:0] count_low; reg[21:0] count_high; reg key_out_reg; always@(posedge clk)begin count_low&lt;= key_in?0:count_low+1; count_high&lt;= key_in?0:count_high+1; if(count_high == SAMPLE_TIME) key_out_reg&lt;= 1; else if(count_low == SAMPLE_TIME) key_out_reg&lt;= 0; end assign key_out=!key_out_reg;endmodule SegLED.v数码管译码模块。译码模块将CPU运算的结果转换成7段数码管中各个数码管显示所需的高低电平信号,该单元的输入为4-bit位宽的二进制数。其中，七段数码管的八个电平控制输出中最低位是小数点的显示信号，但小数点在CPU运行时没有用到，恰好用于标记Reset状态。 123456789101112131415161718192021222324252627282930313233`timescale 1ns / 1psmodule SegLED( input[3:0] Store, input Reset, output reg[7:0] Out); always@(Store or Reset)begin if(Reset==0)begin Out= 8'b11111110; end else begin case(Store) 4'b0000: Out= 8'b00000011; //0 4'b0001: Out= 8'b10011111; //1 4'b0010: Out= 8'b00100101; //2 4'b0011: Out= 8'b00001101; //3 4'b0100: Out= 8'b10011001; //4 4'b0101: Out= 8'b01001001; //5 4'b0110: Out= 8'b01000001; //6 4'b0111: Out= 8'b00011111; //7 4'b1000: Out= 8'b00000001; //8 4'b1001: Out= 8'b00001001; //9 4'b1010: Out= 8'b00010001; //A 4'b1011: Out= 8'b11000001; //b 4'b1100: Out= 8'b01100011; //C 4'b1101: Out= 8'b10000101; //d 4'b1110: Out= 8'b01100001; //E 4'b1111: Out= 8'b01110001; //F default: Out= 8'b00000000; //all light endcase end endendmodule 运行结果端口映射 初始化所有寄存器被初始化为0。 第1条指令addiu $1,$0,8当前地址00，下一地址04。0号寄存器，值为0。1号寄存器，值为0。ALU结果为8。 第2条指令ori $2,$0,2当前地址04，下一地址08。0号寄存器，值为0。2号寄存器，值为0。ALU结果为2。 第3条指令add $3,$2,$1当前地址08，下一地址0c。2号寄存器，值为2。1号寄存器，3号寄存器。输出结果为0a。 第4条指令sub $5,$3,$2当前地址0c，下一地址10。3号寄存器，值为0a。2号寄存器，值为2。ALU结果为8。 第5条指令and $4,$5,$2当前地址10，下一地址14。5号寄存器，值为3。2号寄存器，值为2。ALU结果为0。 实验心得对于第一次使用verilog语言的我来说，设计单周期CPU是一个不小的挑战。总的来说，从开始构思到真正写板完成大约用了三整天的时间，期间遇到了很多有困难的地方，也翻了很多网上的博客。不得不说，网上能找到的很多博客给出的代码都是有些问题的，确实在一定程度上误导了自己。但是这样一个比较复杂的系统又确实很难什么都不去参考而直接写出来。因此，还是希望老师能够多做一些有关verilog语言的讲学吧，遇到的很多问题其实都是关于语法方面的，因为vivado并不会对语法错误进行提示（我用的2017.4版会在可能错误的地方画一道波浪线但是并不会提示错在哪里），而我遇到的问题很多都是语法方面的（例如，在readmemb的时候地址的斜杠和操作系统的是反的，这花费了我很多时间检查才发现）。","link":"/2018/11/23/2018-11-23-单周期CPU设计/"},{"title":"多周期CPU设计","text":"实验目的 认识和掌握多周期数据通路图的构成、原理及其设计方法； 掌握多周期CPU的实现方法，代码实现方法； 编写一个编译器，将MIPS汇编程序编译为二进制机器码； 掌握多周期CPU的测试方法; 掌握多周期CPU的实现方法。 实验内容设计一个多周期CPU，该CPU至少能实现以下指令功能操作。需设计的指令与格式如下： 算术运算指令add rd rs rt 000000 rs(5位) rt(5位) rd(5位) reserved 功能：rd←rs + rt；reserved为预留部分，即未用，一般填“0”。 sub rd rs rt 000001 rs(5位) rt(5位) rd(5位) reserved 功能：rd←rs - rt。 addiu rt rs immediate 000010 rs(5位) rt(5位) immediate(16位) 功能：rt←rs + (sign-extend)immediate；immediate符号扩展再参加“加”运算。 逻辑运算指令and rd rs rt 010000 rs(5位) rt(5位) rd(5位) reserved 功能：rd←rs &amp; rt；逻辑与运算。 andi rt rs immediate|010001|rs(5位)|rt(5位)|immediate(16位)||-|-|-|-|-||||||| 功能：rt←rs &amp; (zero-extend)immediate；immediate做“0”扩展再参加“与”运算。 ori rt rs immediate 010010 rs(5位) rt(5位) immediate(16位) 功能：rt←rs | (zero-extend)immediate；immediate做“0”扩展再参加“或”运算。 xori rd rs rt 010011 rs(5位) rt(5位) rd(5位) reserved 功能：rt←rs$\\oplus$(zero-extend)immediate；immediate做“0”扩展再参加“异或”运算。 移位指令sll rd rt sa 011000 未用 rt(5位) rd(5位) sa(5位) reserved 功能：rd&lt;－rt&lt;&lt;(zero-extend)sa，左移sa位 ，(zero-extend)sa。 比较指令slti rt rs immediate 100110 rs(5位) rt(5位) immediate(16位) 功能：if (rs&lt; (sign-extend)immediate) rt =1 else rt=0, 带符号比较，详见ALU运算功能表。 slt rd rs rt 100111 rs(5位) rt(5位) rd(5位) sa(5位) reserved 功能：if (rs&lt;rt) rd =1 else rd=0, 具体请看ALU运算功能表，带符号。 存储器读/写指令sw rt immediate(rs) 110000 rs(5位) rt(5位) immediate(16位) 功能：memory[rs+ (sign-extend)immediate]←rt；immediate符号扩展再相加。即将rt寄存器的内容保存到rs寄存器内容和立即数符号扩展后的数相加作为地址的内存单元中。 lw rt immediate(rs) 110001 rs(5位) rt(5位) immediate(16位) 功能：rt ← memory[rs + (sign-extend)immediate]；immediate符号扩展再相加。即读取rs寄存器内容和立即数符号扩展后的数相加作为地址的内存单元中的数，然后保存到rt寄存器中。 分支指令beq rs rt immediate 110100 rs(5位) rt(5位) immediate(16位) 功能：if(rs=rt) pc←pc + 4 + (sign-extend)immediate &lt;&lt;2 else pc ←pc + 4特别说明：immediate是从PC+4地址开始和转移到的指令之间指令条数。immediate符号扩展之后左移2位再相加。为什么要左移2位？由于跳转到的指令地址肯定是4的倍数（每条指令占4个字节），最低两位是“00”，因此将immediate放进指令码中的时候，是右移了2位的，也就是以上说的“指令之间指令条数”。 bne rs rt immediate 110101 rs(5位) rt(5位) immediate(16位) 功能：if(rs!=rt) pc←pc + 4 + (sign-extend)immediate &lt;&lt;2 else pc ←pc + 4特别说明：与beq不同点是，不等时转移，相等时顺序执行。 bltz rs immediate 110110 rs(5位) 00000 immediate(16位) 功能：if(rs&lt;$zero) pc←pc + 4 + (sign-extend)immediate &lt;&lt;2 else pc ←pc + 4。 跳转指令j addr 111000 addr[27:2] 功能：pc &lt;－{(pc+4)[31:28],addr[27:2],2'b00}，无条件跳转。说明：由于MIPS32的指令代码长度占4个字节，所以指令地址二进制数最低2位均为0，将指令地址放进指令代码中时，可省掉！这样，除了最高6位操作码外，还有26位可用于存放地址，事实上，可存放28位地址，剩下最高4位由pc+4最高4位拼接上。 jr rs 111001 rs(5位) 未用 未用 reserved 功能：pc &lt;－ rs，跳转。 调用子程序指令jal addr 111010 addr[27:2] 功能：调用子程序，pc &lt;－ {(pc+4)[31:28],addr[27:2],2'b00}；$31&lt;－pc+4，返回地址设置；子程序返回，需用指令 jr $31。跳转地址的形成同 j addr 指令。 停机指令halt 111111 00000000000000000000000000(26位) 功能：停机；不改变PC的值，PC保持不变。 实验原理多周期CPU指的是将整个CPU的执行过程分成几个阶段，每个阶段用一个时钟去完成，然后开始下一条指令的执行，而每种指令执行时所用的时钟数不尽相同，这就是所谓的多周期CPU。 CPU在处理指令的几个步骤123456graph LR取指令IF--&gt;指令译码ID指令译码ID--&gt;指令执行EXE指令执行EXE--&gt;存储器访问MEM存储器访问MEM--&gt;结果写回WB结果写回WB--&gt;取指令IF 图1 CPU指令处理过程 实验中就按照这五个阶段进行设计，这样一条指令的执行最长需要五个(小)时钟周期才能完成，但具体情况怎样？要根据该条指令的情况而定，有些指令不需要五个时钟周期的，这就是多周期的CPU。 取指令(IF)根据程序计数器pc中的指令地址，从存储器中取出一条指令，同时，pc根据指令字长度自动递增产生下一条指令所需要的指令地址，但遇到“地址转移”指令时，则控制器把“转移地址”送入pc，当然得到的“地址”需要做些变换才送入pc。 指令译码(ID)对取指令操作中得到的指令进行分析并译码，确定这条指令需要完成的操作，从而产生相应的操作控制信号，用于驱动执行状态中的各种操作。 指令执行(EXE)根据指令译码得到的操作控制信号，具体地执行指令动作，然后转移到结果写回状态。 存储器访问(MEM)所有需要访问存储器的操作都将在这个步骤中执行，该步骤给出存储器的数据地址，把数据写入到存储器中数据地址所指定的存储单元或者从存储器中得到数据地址单元中的数据。 结果写回(WB)指令执行的结果或者访问存储器中得到的数据写回相应的目的寄存器中。 MIPS指令的三种格式 缩写 说明 op 操作码 rs 只读，为第1个源操作数寄存器，寄存器地址（编号）是00000~11111，00~1F rt 可读可写，为第2个源操作数寄存器，或目的操作数寄存器，寄存器地址（同上） rd 只写，为目的操作数寄存器，寄存器地址（同上） sa 位移量（shift amt），移位指令用于指定移多少位 funct 功能码，在寄存器类型指令中（R类型）用来指定指令的功能与操作码配合使用 immediate 16位立即数，用作无符号的逻辑操作数、有符号的算术操作数、数据加载（Laod）/数据保存（Store）指令的数据地址字节偏移量和分支指令中相对程序计数器（PC）的有符号偏移量； address 地址 R类型 31-26 25-21 20-16 15-11 10-6 5-0 op rs rt rd sa func 6位 5位 5位 5位 5位 6位 I类型 31-26 25-21 20-16 15-0 op rs rt immediate 6位 5位 5位 16位 J类型： 31-26 25-0 op address 6位 26位 多周期CPU状态转移图状态的转移有的是无条件的，例如从sIF状态转移到sID就是无条件的；有些是有条件的，例如sEXE状态之后不止一个状态，到底转向哪个状态由该指令功能，即指令操作码决定。每个状态代表一个时钟周期。 多周期CPU控制部件的原理结构图 多周期CPU数据通路和控制线路图上图是一个简单的基本上能够在多周期CPU上完成所要求设计的指令功能的数据通路和必要的控制线路图。其中指令和数据各存储在不同存储器中，即有指令存储器和数据存储器。访问存储器时，先给出内存地址，然后由读或写信号控制操作。对于寄存器组，给出寄存器地址（编号），读操作时不需要时钟信号，输出端就直接输出相应数据；而在写操作时，在 WE使能信号为1时，在时钟边沿触发将数据写入寄存器。图中控制信号功能如表1所示，表2是ALU运算功能表。 特别提示，图上增加IR指令寄存器，目的是使指令代码保持稳定，pc写使能控制信号PCWre，是确保pc适时修改，原因都是和多周期工作的CPU有关。ADR、BDR、ALUoutDR、DBDR四个寄存器不需要写使能信号，其作用是切分数据通路，将大组合逻辑切分为若干个小组合逻辑，大延迟变为多个分段小延迟。 指令执行的结果总是在时钟下降沿保存到寄存器和存储器中，PC的改变是在时钟上升沿进行的，这样稳定性较好。另外，值得注意的问题，设计时，用模块化的思想方法设计，关于ALU设计、存储器设计、寄存器组设计等等，也是必须认真考虑的问题。 其中指令和数据各存储在不同存储器中，即有指令存储器和数据存储器。访问存储器时，先给出内存地址，然后由读或写信号控制操作。对于寄存器组，先给出寄存器地址，读操作时不需要时钟信号，输出端就直接输出相应数据；而在写操作时，在 WE使能信号为1时，在时钟边沿触发将数据写入寄存器。 控制信号的作用表以上数据通路图是根据要实现的指令功能的要求画出来的，同时，还必须确定ALU的运算功能(当然，以上指令没有完全用到提供的ALU所有功能，但至少必须能实现以上指令功能操作)。从数据通路图上可以看出控制单元部分需要产生各种控制信号，当然，也有些信号必须要传送给控制单元。从指令功能要求和数据通路图的关系得出以上表1，这样，从表1可以看出各控制信号与相应指令之间的相互关系，根据这种关系就可以得出控制信号与指令之间的关系（见下面表中的“相关指令”），从而写出各控制信号的逻辑表达式，这样控制单元部分就可实现了。 控制信号名 状态“0” 状态“1” RST 对于PC，初始化PC为程序首地址 对于PC，PC接收下一条指令地址 PCWre PC不更改，相关指令：halt，另外，除‘000’状态之外，其余状态慎改PC的值。 PC更改，相关指令：除指令halt外，另外，在‘000’状态时，修改PC的值合适。 ALUSrcA 来自寄存器堆data1输出，相关指令：add、sub、addiu、and、andi、ori、xori、slt、slti、sw、lw、beq、bne、bltz 来自移位数sa，同时，进行(zero-extend)sa，即{ {27{1'b0},sa}，相关指令：sll ALUSrcB 来自寄存器堆data2输出，相关指令：add、sub、and、slt、beq、bne、bltz 来自sign或zero扩展的立即数，相关指令：addiu、andi、ori、xori、slti、lw、sw、sll DBDataSrc 来自ALU运算结果的输出，相关指令：add、sub、addiu、and、andi、ori、xori、sll、slt、slti 来自数据存储器（Data MEM）的输出，相关指令：lw RegWre 无无写寄存器组寄存器，相关指令：beq、bne、bltz、j、sw、jr、halt 寄存器组寄存器写使能，相关指令：add、sub、addiu、and、andi、ori、xori、sll、slt、slti、lw、jal WrRegDSrc 写入寄存器组寄存器的数据来自pc+4(pc4），相关指令：jal，写$31 写入寄存器组寄存器的数据来自ALU运算结果或存储器读出的数据，相关指令：add、addiu、sub、and、andi、ori、xori、sll、slt、slti、lw InsMemRW 写指令存储器 读指令存储器(Ins. Data) mRD 输出高阻态 读数据存储器，相关指令：lw mWR 无操作 写数据存储器，相关指令：sw IRWre IR(指令寄存器)不更改 IR寄存器写使能。向指令存储器发出读指令代码后，这个信号也接着发出，在时钟上升沿，IR接收从指令存储器送来的指令代码。与每条指令都相关。 ALUOp的功能表 ALUOp[2..0] 功能 描述 相关指令 000 Y=A+B 加 add、addiu、sw、lw 001 Y=A–B 减 sub、beq、bne、bltz 010 Y=B&lt;&lt;A B左移A位 sll 011 Y=A∨B 或 ori 100 Y=A∧B 与 andi、and 101 Y=A&lt;B 不带符号比较A&lt;B 110 Y=A[31]!=B[31]?A[31]&gt;B[31]:A&lt;B 带符号比较A&lt;B slti、slt 111 Y=A^B 异或 xori ExtSel的功能表 ExtSel[1..0] 功能 相关指令 00 (zero-extend)sa sll 01 (zero-extend)immediate andi、xori、ori 10 (sign-extend)immediate addiu、slti、lw、sw、beq、bne、bltz 11 未用 PCSrc的功能表|PCSrc[1..0]|功能|相关指令||-|-|-|-||00|pc&lt;－pc+4|add、addiu、sub、and、andi、ori、xori、slt、slti、sll、sw、lw、beq(zero=0)、bne(zero=1)、bltz(sign=0)||01|pc&lt;－pc+4+(sign-extend)immediate ×4|beq(zero=1)、 bne(zero=0)、bltz(sign=1)||10|pc&lt;－rs|jr||11|pc&lt;－{pc[31:28],addr[27:2],2’b00}|j、jal| RegDs的功能表|RegDs[1..0]|写寄存器组寄存器的地址|相关指令||-|-|-|-||00|0x1F($31)|jal（用于保存返回地址$31&lt;-pc+4）||01|rt|addiu、andi、ori、xori、slti、lw||10|rd|add、sub、and、slt、sll||11|未用| 相关部件及引脚说明：Instruction Memory指令存储器。 Iaddr 指令存储器地址输入端口 IDataIn 指令存储器数据输入端口（指令代码输入端口） IDataOut 指令存储器数据输出端口（指令代码输出端口） RW 指令存储器读写控制信号，为0写，为1读 Data Memory数据存储器。 Daddr 数据存储器地址输入端口 DataIn 数据存储器数据输入端口 DataOut 数据存储器数据输出端口 RD 数据存储器读控制信号，为0读 WR 数据存储器写控制信号，为0写 Register File寄存器组。 Read Reg1 rs寄存器地址输入端口 Read Reg2 rt寄存器地址输入端口 Write Reg 将数据写入的寄存器端口，其地址来源rt或rd字段 Write Data 写入寄存器的数据输入端口 Read Data1 rs寄存器数据输出端口 Read Data2 rt寄存器数据输出端口 WE 写使能信号，为1时，在时钟边沿触发写入 IR指令寄存器，用于存放正在执行的指令代码。由于RW模块所需要的寄存器IR太多，因此合在了一起。 ALU：算术逻辑单元 result ALU运算结果 zero 运算结果标志，结果为0，则zero=1；否则zero=0 sign 运算结果标志，结果最高位为0，则sign=0，正数；否则，sign=1，负数 实验器材电脑一台，Xilinx Vivado 2017.4 软件一套，Basys3实验板一块。 实验过程与结果代码实现MultipleCPU.v多周期CPU的顶层连接文件，主要是调用下层模块并将它们输入输出连在一起。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566`timescale 1ns / 1psmodule MultipleCPU( input CLK, input Reset, output [5:0] op, output [4:0] rs, output [4:0] rt, output [4:0] rd, output [15:0] immediate, output [31:0] ReadData1, output [31:0] ReadData2, output [31:0] WriteData, output [31:0] DataOut, output [31:0] currentAddress, output [31:0] newAddress, output [31:0] result, output PCWre); wire [31:0] A,B; wire [31:0] currentAddress_4, extendImmediate, currentAddress_immediate, outAddress, ALUM2DR; wire [4:0] WriteReg; wire [25:0] address; wire zero,sign, ALUSrcA,ALUSrcB, ALUM2Reg, RegWre, WrRegData, InsMemRW, DataMemRW, IRWre; wire [1:0] ExtSel, PCSrc, RegOut; wire [2:0] ALUOp; wire [31:0] RegReadData1, RegReadData2, RegResult, RegDataOut; ControlUnit cu(CLK, Reset, op, zero,sign,PCWre, ALUSrcA, ALUSrcB, ALUM2Reg, RegWre, WrRegData, InsMemRW, DataMemRW, IRWre, ExtSel, PCSrc, RegOut, ALUOp); PC pc(CLK, Reset, PCWre, newAddress, currentAddress); InstructionMemory im(InsMemRW, currentAddress, CLK, IRWre, op, rs, rt, rd, immediate, address); RegisterFile rf(CLK, RegWre, rs, rt, WriteReg, WriteData, ReadData1, ReadData2); ALU alu(ALUOp, A, B, zero, result,sign); SignZeroExtend sze(ExtSel, immediate, extendImmediate); DataMemory dm(DataMemRW, RegResult, RegReadData2, DataOut); PCjump pcj(currentAddress, address, outAddress); assign currentAddress_4 = currentAddress + 4; assign currentAddress_immediate = currentAddress_4 + (extendImmediate &lt;&lt; 2); //线转寄存器 WireToReg wtrA(CLK, 1, ReadData1, RegReadData1); WireToReg wtrB(CLK, 1, ReadData2, RegReadData2); WireToReg wtrALU(CLK, 1, result, RegResult); WireToReg wtrMEM(CLK, 1, DataOut, RegDataOut); //2路选择器 MUX2L_32 mux2_1(WrRegData, currentAddress_4, ALUM2DR, WriteData); MUX2L_32 mux2_4(ALUSrcA, RegReadData1, RegReadData2, A); MUX2L_32 mux2_2(ALUSrcB, RegReadData2, extendImmediate, B); MUX2L_32 mux2_3(ALUM2Reg, result, RegDataOut, ALUM2DR); //4路选择器 MUX4L_5 mux4_1(RegOut, 5'b11111, rt, rd, 5'b00000, WriteReg); MUX4L_32 mux4_2(PCSrc, currentAddress_4, currentAddress_immediate, ReadData1, outAddress, newAddress);endmodule ControlUnit.v控制信号模块，通过解析op得到该指令的各种控制信号。定义了很多用到的常量，可读性还是比较高的。控制单元通过输入的zero零标志位与当前指令中对应的指令部分来确定当前整个CPU程序中各模块的工作和协作情况，根据CPU运行逻辑，事先对整个CPU中控制信号的控制，以此来达到指挥各个模块协同工作的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180`timescale 1ns / 1psmodule ControlUnit( input CLK, //时钟 input reset, //重置信号 input [5:0] op, //op操作符 input zero, //ALU的zero输出 input sign, output reg PCWre, //(PC)PC是否更改，如果为0，PC不更改，另外，除D_Tri == 000状态之外，其余状态也不能改变PC的值。 output reg ALUSrcA, output reg ALUSrcB, output reg ALUM2Reg, output reg RegWre, //(RF)写使能信号，为1时，在时钟上升沿写入 output reg WrRegData, //2路选择器，判断数据写入是否为PC指令，如果为1，则不是，jar用到 output reg InsMemRW, //(IM)读写控制信号，1为写，0位读，固定为0 output reg DataMemRW, //(DM)数据存储器读写控制信号，为1写，为0读 output reg IRWre, //寄存器写使能，暂时没什么用，固定为1 output reg[1:0] ExtSel, //(EXT)控制补位，如果为1，进行符号扩展，如果为0，全补0 output reg[1:0] PCSrc, //4路选择器，选择PC指令来源 output reg[1:0] RegOut, //4路选择器，判断写寄存器地址的来源 output reg[2:0] ALUOp //(ALU)ALU操作控制); parameter[2:0] _ADD= 3'b000, _SUB= 3'b001, _SLL= 3'b010, _OR= 3'b011, _AND= 3'b100, _SLTU= 3'b101, _SLT= 3'b110, _XOR= 3'b111, IF= 3'b000, //3位D触发器，代表8个状态 ID= 3'b001, EXELS= 3'b010, MEM= 3'b011, WBL= 3'b100, EXEBR= 3'b101, EXEAL= 3'b110, WBAL= 3'b111; parameter[5:0] ADD= 6'b000000, SUB= 6'b000001, ADDIU= 6'b000010, AND= 6'b010000, ANDI= 6'b010001, ORI= 6'b010010, XORI= 6'b010011, SLL= 6'b011000, SLTI= 6'b100110, SLT= 6'b100111, SW= 6'b110000, LW= 6'b110001, BEQ= 6'b110100, BNE= 6'b110101, BLTZ= 6'b110110, J= 6'b111000, JR= 6'b111001, JAL= 6'b111010, HALT= 6'b111111; reg[2:0] D_Tri; initial begin PCWre=0; ALUSrcB=0; ALUM2Reg=0; RegWre=0; WrRegData=0; //no change InsMemRW=0; DataMemRW=0; //no change IRWre=1; ExtSel=0; PCSrc=0; RegOut=0; ALUOp=0; D_Tri=0; end //D触发器变化，PS：为了避免竞争冒险，所有值变化改为下降沿触发 //PCWre，RegWre和DataMemRW的变化影响很大，要在这里写 always@(negedge CLK or posedge reset)begin if(reset)begin//重置属性 D_Tri=IF; PCWre=0; RegWre=0; end else begin case (D_Tri) //IF -&gt; ID IF: begin D_Tri &lt;= ID; //禁止写指令，寄存器，和内存 PCWre=0; RegWre=0; DataMemRW=0; end //ID -&gt; EXE ID:begin case (op) //如果是BEQ指令，跳到EXEBR BEQ, BNE, BLTZ: D_Tri &lt;= EXEBR; //如果是SW，LW指令，跳到EXELS SW, LW: D_Tri &lt;= EXELS; //如果是j，JAL，JR，HALT，跳到IF J, JAL, JR, HALT:begin D_Tri=IF; //如果指令是HALT，禁止写指令 if (op == HALT) PCWre=0; else PCWre=1; //如果指令是JAL，允许写寄存器 if (op == JAL) RegWre=1; else RegWre=0; end //其他，跳到EXEAL default: D_Tri=EXEAL; endcase end //EXEAL -&gt; WBAL EXEAL:begin D_Tri=WBAL; //允许写寄存器 RegWre=1; end //EXELS -&gt; MEM EXELS:begin D_Tri=MEM; //如果指令为SW，允许写内存 if (op == SW) DataMemRW=1; end //MEM -&gt; WBL MEM:begin //如果指令为SW，MEM -&gt; IF if (op == SW)begin D_Tri=IF; //允许写指令 PCWre=1; end //如果指令为LW，MEM -&gt; WBL else begin D_Tri=WBL; //允许写寄存器 RegWre=1; end end //其他 -&gt; IF default:begin D_Tri=IF; //允许写指令 PCWre=1; //禁止写寄存器 RegWre=0; end endcase end end always@(op or zero)begin//一般信号 ALUSrcA= op==SLL; ALUSrcB= op==ADDIU||op==ANDI||op==ORI||op==XORI||op==SLTI||op==LW||op==SW||op==SLL; ALUM2Reg= op==LW; WrRegData= op!=JAL; //2路选择器，判断数据写入是否为PC指令，如果为1，则不是，jar用到 InsMemRW= 0;//(IM)读写控制信号，1为写，0位读，固定为0 IRWre= 1; //寄存器写使能，暂时没什么用，固定为1 ExtSel= op==SLL?2'b00:op==ANDI||op==XORI||op==ORI?2'b01:2'b10; //(EXT)控制补位，如果为1，进行符号扩展，如果为0，全补0 PCSrc= op==J||op==JAL?2'b11: op==JR?2'b10: (op==BEQ&amp;&amp;zero==1)||(op==BNE&amp;&amp;zero==0)||(op==BLTZ&amp;&amp;sign==1)?2'b01: 2'b00; //4路选择器，选择PC指令来源 RegOut= op==JAL?2'b00: op==ADD||op==SUB||op==AND||op==SLT||op==SLL?2'b10: 2'b01; //4路选择器，判断写寄存器地址的来源 ALUOp= op==SUB||op==BEQ||op==BNE||op==BLTZ?_SUB: op==SLL?_SLL: op==ORI?_OR: op==ANDI||op==AND?_AND: op==SLT||op==SLTI?_SLT: op==XORI?_XOR:_ADD; //(ALU)ALU操作控制 endendmodule ALU.v该部分为算术逻辑单元，用于逻辑指令计算和跳转指令比较。ALUOp用于控制算数的类型，A、B为输入数，result为运算结果，zero、sign主要用于beq、bne、bltz等指令的判断。ALU算术逻辑单元的功能是根据控制信号从输入的数据中选取对应的操作数，根据操作码进行运算并输出结果与零标志位。 1234567891011121314151617181920212223242526272829303132333435`timescale 1ns / 1psmodule ALU( input[2:0] ALUOp, input[31:0] A, input[31:0] B, output zero, output reg[31:0] result, output sign); parameter _ADD= 3'b000; parameter _SUB= 3'b001; parameter _SLL= 3'b010; parameter _OR= 3'b011; parameter _AND= 3'b100; parameter _SLTU= 3'b101; parameter _SLT= 3'b110; parameter _XOR= 3'b111; assign zero= result==0; assign sign= result[31]; always@(*)begin case(ALUOp) _ADD: result= A+B; _SUB: result= A-B; _SLL: result= A&lt;&lt;B; _OR: result= A|B; _AND: result= A&amp;B; _SLTU: result= A&lt;B; _SLT: result= A[31]!=B[31]?A[31]&gt;B[31]:A&lt;B; _XOR: result= A^B; default: result= 0; endcase endendmodule DataMemory.v该部分控制内存存储，用于内存存储、读写。用256大小的8位寄存器数组模拟内存，采用小端模式。DataMenRW控制内存读写。由于指令为真实地址，所以不需要&lt;&lt;2。 1234567891011121314151617181920212223242526272829`timescale 1ns / 1psmodule DataMemory( input DataMemRW, input [31:0] DAddr, input [31:0] DataIn, output reg [31:0] DataOut); reg [7:0] memory[0:255]; integer i; initial begin for (i = 0; i &lt; 256; i = i + 1)memory[i] &lt;= 0; for (i = 0; i &lt; 32; i = i + 1)DataOut[i] &lt;= 0; end always@(DAddr or DataMemRW)begin if (DataMemRW)begin memory[DAddr] &lt;= DataIn[31:24]; memory[DAddr + 1] &lt;= DataIn[23:16]; memory[DAddr + 2] &lt;= DataIn[15:8]; memory[DAddr + 3] &lt;= DataIn[7:0]; end else begin DataOut[31:24] &lt;= memory[DAddr]; DataOut[23:16] &lt;= memory[DAddr + 1]; DataOut[15:8] &lt;= memory[DAddr + 2]; DataOut[7:0] &lt;= memory[DAddr + 3]; end endendmodule InstructionMemory.v该部分为指令寄存器，通过一个256大小的8位寄存器数组来保存从文件输入的全部指令。然后通过输入的地址，找到相应的指令，输出到IDataOut。指令存储器的功能是存储读入的所有32-bit位宽的指令，根据程序计数器PC中的指令地址进行取指令操作并对指令类型进行分析，通过指令类型对所取指令的各字段进行区分识别，最后将对应部分传递给其他模块进行后续处理。指令存储器中每个单元的位宽为8-bit，也就是存储每条32-bit位宽的指令都需要占据4个单元，所以第n（n大于或等于0）条指令所对应的起始地址为4n，且占据第4n，4n+1，4n+2，4n+3这四个单元。取出指令就是将这四个单元分别取出，因为指令的存储服从高位指令存储在低位地址的规则，所以4n单元中的字段是该条指令的最高8位，后面以此类推，并通过左移操作将指令的四个单元部分移动到相对应的位置，以此来得到所存指令。 1234567891011121314151617181920212223242526272829303132333435363738394041424344`timescale 1ns / 1psmodule InstructionMemory( input InsMemRW, //读写控制信号，1为写，0位读 input [31:0] IAddr, //指令地址输入入口 //input IDataIn, //没用到 input CLK, //时钟信号 input IRWre, //输出寄存器写使能 output reg[5:0] op, output reg[4:0] rs, output reg[4:0] rt, output reg[4:0] rd, output reg[15:0] immediate, //指令代码分时段输出 output reg[25:0] address); reg[7:0] mem[0:255]; //新建一个256位的数组用于储存指令 initial begin //初始化 op &lt;= 0; rs &lt;= 0; rt &lt;= 0; rd &lt;= 0; immediate &lt;= 0; address &lt;= 0; $readmemb(\"C:/Users/wukan/Documents/VIVADO/MultipleCPU/input.txt\",mem); end //从地址取值，然后输出 always@(posedge CLK or posedge IRWre)begin if (IRWre == 1)begin op = mem[IAddr][7:2]; rs[4:3] = mem[IAddr][1:0]; rs[2:0] = mem[IAddr + 1][7:5]; rt = mem[IAddr + 1][4:0]; rd = mem[IAddr + 2][7:3]; immediate[15:8] = mem[IAddr + 2]; immediate[7:0] = mem[IAddr + 3]; //地址赋值 address[25:21] = rs; address[20:16] = rt; address[15:0] = immediate; end endendmodule MUX2L_32.v三十二线双路选择器。 123456789`timescale 1ns / 1psmodule MUX2L_32( input control, input [31:0] in0, input [31:0] in1, output [31:0] out); assign out = control ? in1 : in0;endmodule MUX4L_32.v三十二线四路选择器。 1234567891011`timescale 1ns / 1psmodule MUX4L_32( input [1:0]control, input [31:0] in00, input [31:0] in01, input [31:0] in10, input [31:0] in11, output [31:0] out); assign out = control[0] ? (control[1] ? in11 : in01) : (control[1] ? in10 : in00);endmodule MUX4L_5.v五线四路选择器。 1234567891011`timescale 1ns / 1psmodule MUX4L_5( input [1:0] control, input [4:0] in00, input [4:0] in01, input [4:0] in10, input [4:0] in11, output [4:0] out); assign out = control[0] ? (control[1] ? in11 : in01) : (control[1] ? in10 : in00);endmodule PC.vCLK上升沿触发，更改指令地址。由于指令地址存储在寄存器里，一开始需要赋currentAddress为0。Reset是重置信号，当为1时，指令寄存器地址重置。PCWre的作用为保留现场，如果PCWre为0，指令地址不变。PC程序计数器用于存放当前指令的地址，当PC的值发生改变的时候，CPU会根据程序计数器PC中新得到的指令地址，从指令存储器中取出对应地址的指令，根据PCSrc控制信号的值选择指令地址是要进行PC+4或者跳转等操作。若PC程序计数器检测到Reset输入信号为1时，则对程序计数器存储的当前指令地址进行清零处理。 12345678910111213141516171819`timescale 1ns / 1psmodule PC( input CLK, //时钟 input Reset, //重置信号 input PCWre, //PC是否更改，如果为0，PC不更改 input [31:0] newAddress, //新指令 output reg[31:0] currentAddress //当前指令); initial begin currentAddress &lt;= 0; //非阻塞赋值 end always@(posedge CLK or posedge Reset)begin if (Reset == 1) currentAddress &lt;= 0; //如果重置，赋值为0 else begin if (PCWre) currentAddress &lt;= newAddress; else currentAddress &lt;= currentAddress; end endendmodule PCjump.v12345678910`timescale 1ns / 1psmodule PCjump( input [31:0] PC0, //指令 input [25:0] inAddress, //输入地址 output [31:0] outAddress //输出地址(指令)); assign outAddress[31:28] = PC0[31:28]; assign outAddress[27:2] = inAddress; assign outAddress[1:0] = 2'b00;endmodule RegisterFile.v该部分为寄存器读写单元，储存寄存器组，并根据地址对寄存器组进行读写。WE的作用是控制寄存器是否写入。同上，通过一个32大小的32位寄存器数组来模拟寄存器，开始时全部置0。通过访问寄存器的地址，来获取寄存器里面的值，并进行操作。（由于$0恒为0，所以写入寄存器的地址不能为0）寄存器组中的每个寄存器位宽32-bit,是存放ALU计算所需要的临时数据的,与数据存储器不同，可能会在程序执行的过程中被多次覆盖，而数据存储器内的数据一般只有sw指令才能进行修改覆盖。寄存器组会根据操作码opCode与rs，rt字段相应的地址读取数据,同时将rs，rt寄存器的地址和其中的数据输出，在CLK的下降沿到来时将数据存放到rd或者rt字段的相应地址的寄存器内。 1234567891011121314151617181920212223242526272829`timescale 1ns / 1psmodule RegisterFile( input CLK, //时钟 input RegWre, //写使能信号，为1时，在时钟上升沿写入 input [4:0] rs, //rs寄存器地址输入端口 input [4:0] rt, //rt寄存器地址输入端口 input [4:0] WriteReg, //将数据写入的寄存器端口，其地址来源rt或rd字段 input [31:0] WriteData, //写入寄存器的数据输入端口 output [31:0] ReadData1, //rs数据输出端口 output [31:0] ReadData2 //rt数据输出端口); reg [31:0] register[0:31]; //新建32个寄存器，用于操作 //初始时，将32个寄存器和ReadData全部赋值为0 integer i; initial begin for(i = 0; i &lt; 32; i = i + 1) register[i] &lt;= 0; end //直接读寄存器 assign ReadData1 = register[rs]; assign ReadData2 = register[rt]; //接受信号并读寄存器 always@(posedge CLK)begin //如果寄存器不为0，并且RegWre为真，写入数据 if (RegWre &amp;&amp; WriteReg != 0) register[WriteReg] = WriteData; endendmodule SignZeroExtend.v比较简单的一个模块，用于立即数的扩展。ExtSel为控制补位信号。判断后，将extendImmediate的前16位全补1或0即可。 12345678910`timescale 1ns / 1psmodule SignZeroExtend( input [1:0]ExtSel, //控制补位，如果为1X，进行符号扩展；01，immediate全补0；00，sa全补0 input [15:0] immediate, //16位立即数 output [31:0] extendImmediate //输出的32位立即数); assign extendImmediate[4:0] = (ExtSel == 2'b00) ? immediate[10:6] : immediate[4:0]; assign extendImmediate[15:5] = (ExtSel == 2'b00) ? 3'b00000000000 : immediate[15:5]; assign extendImmediate[31:16] = (ExtSel == 2'b10) ? (immediate[15] ? 16'hffff : 16'h0000) : 16'h0000;endmodule 仿真检验编写一个编译器，将MIPS汇编程序编译为二进制机器码使用支持c++11以上标准的编译器编译下述代码，得到编译器wkmips。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define TRANS(s,len) (bitset&lt;len&gt;(stoi(s,0,0)).to_string())using namespace std;string compiler(string s){ static unordered_map&lt;string,string&gt; mp { {\"add\",\"000000\"}, {\"sub\",\"000001\"}, {\"addiu\",\"000010\"}, {\"and\",\"010000\"}, {\"andi\",\"010001\"}, {\"ori\",\"010010\"}, {\"xori\",\"010011\"}, {\"sll\",\"011000\"}, {\"slti\",\"100110\"}, {\"slt\",\"100111\"}, {\"sw\",\"110000\"}, {\"lw\",\"110001\"}, {\"beq\",\"110100\"}, {\"bne\",\"110101\"}, {\"bltz\",\"110110\"}, {\"j\",\"111000\"}, {\"jr\",\"111001\"}, {\"jal\",\"111010\"}, {\"halt\",\"111111\"} }; vector&lt;string&gt; v; for(char &amp;c:s)if(!isgraph(c)||c=='$'||c=='('||c==')')c=','; for(istringstream sin(s); getline(sin,s,',');) if(!s.empty())v.push_back(s); if(v.empty())return \"\"; s=mp[v[0]]; if(v.size()==1)s+=string(26,'0'); else if(v.size()==2) { if(v[0]==\"jr\")s+=TRANS(v[1],5)+string(21,'0'); else s+=bitset&lt;26&gt;(stoi(v[1],0,0)&gt;&gt;2).to_string(); } else if(v.size()==3) { if(v[0]==\"bltz\")s+=TRANS(v[1],5)+string(5,'0')+TRANS(v[2],16); else s+=TRANS(v[1],5)+TRANS(v[2],21); } else { if(v[0]==\"sw\"||v[0]==\"lw\")swap(v[2],v[3]); if(v[0]==\"sll\") { s+=string(5,'0'); s+=TRANS(v[2],5)+TRANS(v[1],5); s+=TRANS(v[3],5)+string(6,'0'); } else if(v[0].find('i')!=v[0].npos ||v[0]==\"sw\"||v[0]==\"lw\" ||v[0]==\"beq\"||v[0]==\"bne\") { s+=TRANS(v[2],5)+TRANS(v[1],5); s+=TRANS(v[3],16); } else { s+=TRANS(v[2],5)+TRANS(v[3],5); s+=TRANS(v[1],5)+string(11,'0'); } } return s;}int main(int argc,char **argv){ if(argc&lt;2)return 0; ifstream fin(argv[1]); ofstream fout(argv[argc-1]); for(string s; getline(fin,s); fout&lt;&lt;'\\n') { s=compiler(s); for(int i=0; i&lt;s.size(); ++i) { fout&lt;&lt;s[i]; if(i%8==7)fout&lt;&lt;' '; } }} 待转换的MIPS代码test.txt内容如下： 123456789101112131415161718192021222324addiu $1,$0,8ori $2,$0,2xori $3,$2,8sub $4,$3,$1and $5,$4,$2sll $5,$5,2beq $5,$1,-2jal 0x0000050slt $8,$13,$1addiu $14,$0,-2slt $9,$8,$14slti $10,$9,2slti $11,$10,0add $11,$11,$10bne $11,$2,-2addiu $12,$0,-2addiu $12,$12,1bltz $12,-2andi $12,$2,2j 0x000005Csw $2,4($1)lw $13,4($1)jr $31halt 在命令行中键入wkmips test.txt input.txt，得到编译后文件input.txt： 12345678910111213141516171819202122232400001000 00000001 00000000 0000100001001000 00000010 00000000 0000001001001100 01000011 00000000 0000100000000100 01100001 00100000 0000000001000000 10000010 00101000 0000000001100000 00000101 00101000 1000000011010000 00100101 11111111 1111111011101000 00000000 00000000 0001010010011101 10100001 01000000 0000000000001000 00001110 11111111 1111111010011101 00001110 01001000 0000000010011001 00101010 00000000 0000001010011001 01001011 00000000 0000000000000001 01101010 01011000 0000000011010100 01001011 11111111 1111111000001000 00001100 11111111 1111111000001001 10001100 00000000 0000000111011001 10000000 11111111 1111111001000100 01001100 00000000 0000001011100000 00000000 00000000 0001011111000000 00100010 00000000 0000010011000100 00101101 00000000 0000010011100111 11100000 00000000 0000000011111100 00000000 00000000 00000000 检验：手动将指令转换成二进制代码如下表，可对比检验上述编译器转换结果无误。 地址 汇编程序 op（6） rs(5) rt(5) rd(5)/immediate(16) 16进制数代码 0x00000000 addiu $1,$0,8 000010 00000 00001 00000000 00001000 08010008 0x00000004 ori $2,$0,2 010010 00000 00010 00000000 00000010 48020002 0x00000008 xori $3,$2,8 010011 00010 00011 00000000 00001000 4c430008 0x0000000c sub $4,$3,$1 000001 00011 00001 00100000 00000000 04612000 0x00000010 and $5,$4,$2 010000 00100 00010 00101000 00000000 40822800 0x00000014 sll $5,$5,2 011000 00000 00101 00101000 10000000 60052880 0x00000018 beq $5,$1,-2 110100 00001 00101 11111111 11111110 d025fffe 0x0000001c jal 0x0000050 111010 00000 00000 00000000 00010100 e8000014 0x00000020 slt $8,$13,$1 100111 01101 00001 01000000 00000000 9da14000 0x00000024 addiu $14,$0,-2 000010 00000 01110 11111111 11111110 080efffe 0x00000028 slt $9,$8,$14 100111 01000 01110 01001000 00000000 9d0e4800 0x0000002c slti $10,$9,2 100110 01001 01010 00000000 00000010 992a0002 0x00000030 slti $11,$10,0 100110 01010 01011 00000000 00000000 994b0000 0x00000034 add $11,$11,$10 000000 01011 01010 01011000 00000000 016a5800 0x00000038 bne $11,$2,-2 110101 00010 01011 11111111 11111110 d44bfffe 0x0000003c addiu $12,$0,-2 000010 00000 01100 11111111 11111110 080cfffe 0x00000040 addiu $12,$12,1 000010 01100 01100 00000000 00000001 098c0001 0x00000044 bltz $12,-2 110110 01100 00000 11111111 11111110 d980fffe 0x00000048 andi $12,$2,2 010001 00010 01100 00000000 00000010 444c0002 0x0000004c j 0x000005C 111000 00000 00000 00000000 00010111 e0000017 0x00000050 sw $2,4($1) 110000 00001 00010 00000000 00000100 c0220004 0x00000054 lw $13,4($1) 110001 00001 01101 00000000 00000100 c42d0004 0x00000058 jr $31 111001 11111 00000 00000000 00000000 e7e00000 0x0000005c halt 111111 00000 00000 00000000 00000000 fc000000 Sim.v仿真模块。 1234567891011121314151617`timescale 1ns / 1psmodule Sim; reg CLK; //时钟信号 reg Reset; //置零信号 MultipleCPU mcpu(CLK,Reset); initial begin CLK= 0; Reset= 1; //刚开始设置pc为0 #50; //等待Reset完成 CLK= !CLK; //下降沿，使PC先清零 #50; Reset= 0; //清除保持信号 forever #50 begin //产生时钟信号，周期为50s CLK= !CLK; end endendmodule 仿真波形波形比较长，分成三部分逐一分析。第一次执行到地址0x00000018的时候，执行了beq $5,$1,-2，此时$5和$1都是8，回退到0x00000014；第二次执行到地址0x00000018的时候，$5是32，$1都是8，不等，继续执行下一条指令jal 0x0000050。于是跳到0x00000050，并在0x00000058地址上跳回0x00000020。第一次执行到地址0x00000038的时候，执行了bne $11,$2,-2，此时$11是1，$2是2，不等，回退到0x00000034；第二次执行到地址0x00000038的时候，$11和$2都是2，继续执行下一条指令。第一次执行到地址0x00000044的时候，执行了bltz $12,-2，此时$12是-1，小于0，回退到0x00000040；第二次执行到地址0x00000044的时候，$12是0，继续执行下一条指令。执行到地址0x0000004C的时候，执行了j 0x000005C，直接跳转到0x000005C，于是执行该地址上的Halt，波形不再变化。 烧写到Basys3实验板Basys3.v顶层模块。和单周期没有太大区别。（Reset的取值）改了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697`timescale 1ns / 1psmodule Basys3( input CLK, input[1:0] SW, //选择输出信号 input Reset, //重置按钮 input Button, //单脉冲 output reg[3:0] AN, //数码管位选择信号 output[7:0] Out //数码管输入信号); parameter T1MS= 100000; reg[16:0] showCounter; wire[31:0] ALU_Out; //ALU的result输出值 wire[31:0] CurPC; wire[31:0] WriteData; //DB总线值 wire[31:0] Reg1Out; //寄存器组rs寄存器的值 wire[31:0] Reg2Out; //寄存器组rt寄存器的值 wire[31:0] DataOut; wire[31:0] instcode; wire myCLK; reg[3:0] store; //记录当前要显示位的值 wire[31:0] newAddress; MultipleCPU mcpu(myCLK,Reset,instcode[31:26],instcode[25:21],instcode[20:16],instcode[15:11],instcode[15:0],Reg1Out,Reg2Out,WriteData,DataOut,CurPC,newAddress,ALU_Out); Debounce debounce(CLK,Button,myCLK); initial begin showCounter&lt;= 0; AN&lt;= 4'b0111; end always@(posedge CLK) begin if(Reset==1)begin showCounter&lt;= 0; AN&lt;= 4'b0000; end else begin showCounter&lt;= showCounter+1; if(showCounter==T1MS) begin showCounter&lt;= 0; case(AN) 4'b1110: begin AN&lt;= 4'b1101; end 4'b1101: begin AN&lt;= 4'b1011; end 4'b1011: begin AN&lt;= 4'b0111; end 4'b0111: begin AN&lt;= 4'b1110; end 4'b0000: begin AN&lt;= 4'b0111; end endcase end end end SegLED led(store,Reset,Out); always@(myCLK)begin case(AN) 4'b1110: begin case(SW) 2'b00: store&lt;= newAddress[3:0]; 2'b01: store&lt;= Reg1Out[3:0]; 2'b10: store&lt;= Reg2Out[3:0]; 2'b11: store&lt;= WriteData[3:0]; endcase end 4'b1101: begin case(SW) 2'b00: store&lt;= newAddress[7:4]; 2'b01: store&lt;= Reg1Out[7:4]; 2'b10: store&lt;= Reg2Out[7:4]; 2'b11: store&lt;= WriteData[7:4]; endcase end 4'b1011: begin case(SW) 2'b00: store&lt;= CurPC[3:0]; 2'b01: store&lt;= instcode[24:21]; 2'b10: store&lt;= instcode[19:16]; 2'b11: store&lt;= ALU_Out[3:0]; endcase end 4'b0111 : begin case(SW) 2'b00: store&lt;= CurPC[7:4]; 2'b01: store&lt;= {3'b000,instcode[25]}; 2'b10: store&lt;= {3'b000,instcode[20]}; 2'b11: store&lt;= ALU_Out[7:4]; endcase end endcase endendmodule Debounce.v和单周期一样的按键消抖模块。Basys3板采用的是机械按键，在按下按键时按键会出现人眼无法观测但是系统会检测到的抖动变化，这可能会使短时间内电平频繁变化，导致程序接收到许多错误的触发信号而出现许多不可知的错误。消抖操作是每当检测到CLK上升沿到来时检测一次当前电平信号并记录，同计数器开始计数，若在计数器达到5000之前电平发生变化，则将计数器清零，若达到5000，则将该记录电平取反输出。因为程序开始时已经运行第一条指令，为避免跳过第一条指令计算值的写入，我们的输入需要从下降沿开始，因此我们给按键信号取反后再输入。 1234567891011121314151617181920212223242526`timescale 1ns / 1psmodule Debounce(clk,key_in,key_out); parameter SAMPLE_TIME = 5000; input clk; input key_in; output key_out; reg [21:0] count_low; reg [21:0] count_high; reg key_out_reg; always @(posedge clk) if(key_in ==1'b0) count_low &lt;= count_low + 1; else count_low &lt;= 0; always @(posedge clk) if(key_in ==1'b1) count_high &lt;= count_high + 1; else count_high &lt;= 0; always @(posedge clk) if(count_high == SAMPLE_TIME) key_out_reg &lt;= 1; else if(count_low == SAMPLE_TIME) key_out_reg &lt;= 0; assign key_out = !key_out_reg;endmodule SegLED.v数码管译码模块。译码模块将CPU运算的结果转换成7段数码管中各个数码管显示所需的高低电平信号,该单元的输入为4-bit位宽的二进制数。其中，七段数码管的八个电平控制输出中最低位是小数点的显示信号，但小数点在CPU运行时没有用到，恰好用于标记Reset状态。 123456789101112131415161718192021222324252627282930`timescale 1ns / 1psmodule SegLED( input[3:0] Store, input Reset, output reg[7:0] Out); always@(Store or Reset)begin begin case(Store) 4'b0000: Out= 8'b00000011; //0 4'b0001: Out= 8'b10011111; //1 4'b0010: Out= 8'b00100101; //2 4'b0011: Out= 8'b00001101; //3 4'b0100: Out= 8'b10011001; //4 4'b0101: Out= 8'b01001001; //5 4'b0110: Out= 8'b01000001; //6 4'b0111: Out= 8'b00011111; //7 4'b1000: Out= 8'b00000001; //8 4'b1001: Out= 8'b00001001; //9 4'b1010: Out= 8'b00010001; //A 4'b1011: Out= 8'b11000001; //b 4'b1100: Out= 8'b01100011; //C 4'b1101: Out= 8'b10000101; //d 4'b1110: Out= 8'b01100001; //E 4'b1111: Out= 8'b01110001; //F default: Out= 8'b00000000; //all light endcase end endendmodule 运行结果端口映射 初始化所有寄存器被初始化为0。 第1条指令addiu $1,$0,8当前地址00，下一地址04。0号寄存器，值为0。1号寄存器。立即数8。运算结果8。 第2条指令ori $2,$0,2当前地址04，下一地址08。0号寄存器，值为0。2号寄存器，立即数2。ALU结果为2。 第3条指令xori $3,$2,8当前地址08，下一地址0c。2号寄存器，值为02。3号寄存器，值为0a（这里是已经写入后的结果）。ALU结果为0a。 第4条指令sub $4,$3,$1当前地址0c，下一地址10。3号寄存器，值为0a。1号寄存器，值为08。ALU结果为02。 第5条指令and $5,$4,$2当前地址10，下一地址14。4号寄存器，值为2。2号寄存器，值为2。ALU结果为2。 实验心得多周期CPU相对于单周期主要是要多思考一下自动状态机转换的问题。此外，还需要单独增加几个寄存器用于接收中间的结果，并且需要连上时钟。 两个学期的实验课终于到此告一段落。作为公认较难的一门课，即使学分较为少，我觉得对人的锻炼却是非常大的。每一年计组的课题都会略有区别，这让我们很难找到参考的地方；甚至很多东西往年的资料和今年的完全相反，如果不加思考完全照抄可能反而会带来误导。因此，虽然难度较大，但是却更加符合我们日后工作科研中可能会遇到的情况。不管怎样，自己总是算是做掉了多周期CPU，几天来的心血没有白费。","link":"/2018/12/23/2018-12-23-多周期CPU设计/"}],"tags":[{"name":"三维计算几何","slug":"三维计算几何","link":"/tags/三维计算几何/"},{"name":"最大流","slug":"最大流","link":"/tags/最大流/"},{"name":"单调队列","slug":"单调队列","link":"/tags/单调队列/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"NTT","slug":"NTT","link":"/tags/NTT/"},{"name":"单调栈","slug":"单调栈","link":"/tags/单调栈/"},{"name":"搜索","slug":"搜索","link":"/tags/搜索/"},{"name":"拓扑排序","slug":"拓扑排序","link":"/tags/拓扑排序/"},{"name":"无旋Treap","slug":"无旋Treap","link":"/tags/无旋Treap/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"珂朵莉树","slug":"珂朵莉树","link":"/tags/珂朵莉树/"},{"name":"老司机树","slug":"老司机树","link":"/tags/老司机树/"},{"name":"数论","slug":"数论","link":"/tags/数论/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","link":"/tags/莫比乌斯反演/"},{"name":"线段树","slug":"线段树","link":"/tags/线段树/"},{"name":"最短路","slug":"最短路","link":"/tags/最短路/"},{"name":"LCA","slug":"LCA","link":"/tags/LCA/"},{"name":"ICPC模板","slug":"ICPC模板","link":"/tags/ICPC模板/"},{"name":"可持久化","slug":"可持久化","link":"/tags/可持久化/"},{"name":"主席树","slug":"主席树","link":"/tags/主席树/"},{"name":"二分","slug":"二分","link":"/tags/二分/"},{"name":"原根","slug":"原根","link":"/tags/原根/"},{"name":"动态开点","slug":"动态开点","link":"/tags/动态开点/"},{"name":"树状数组","slug":"树状数组","link":"/tags/树状数组/"},{"name":"环境配置","slug":"环境配置","link":"/tags/环境配置/"},{"name":"Deepin","slug":"Deepin","link":"/tags/Deepin/"},{"name":"ChromeDriver","slug":"ChromeDriver","link":"/tags/ChromeDriver/"},{"name":"Python解释器的安装与配置","slug":"Python解释器的安装与配置","link":"/tags/Python解释器的安装与配置/"},{"name":"chromedriver","slug":"chromedriver","link":"/tags/chromedriver/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"虚拟环境","slug":"虚拟环境","link":"/tags/虚拟环境/"},{"name":"Pycharm","slug":"Pycharm","link":"/tags/Pycharm/"},{"name":"励志","slug":"励志","link":"/tags/励志/"},{"name":"Anaconda","slug":"Anaconda","link":"/tags/Anaconda/"},{"name":"谷歌输入法","slug":"谷歌输入法","link":"/tags/谷歌输入法/"},{"name":"二维计算几何","slug":"二维计算几何","link":"/tags/二维计算几何/"},{"name":"扫描线","slug":"扫描线","link":"/tags/扫描线/"},{"name":"MongoDB数据库","slug":"MongoDB数据库","link":"/tags/MongoDB数据库/"},{"name":"Bug","slug":"Bug","link":"/tags/Bug/"},{"name":"pymysql","slug":"pymysql","link":"/tags/pymysql/"},{"name":"系统配置","slug":"系统配置","link":"/tags/系统配置/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"},{"name":"虚拟机","slug":"虚拟机","link":"/tags/虚拟机/"}],"categories":[{"name":"Spider","slug":"Spider","link":"/categories/Spider/"},{"name":"程序设计","slug":"程序设计","link":"/categories/程序设计/"},{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"题解","slug":"ACM/题解","link":"/categories/ACM/题解/"},{"name":"算法竞赛入门经典训练指南","slug":"ACM/算法竞赛入门经典训练指南","link":"/categories/ACM/算法竞赛入门经典训练指南/"},{"name":"小工具","slug":"小工具","link":"/categories/小工具/"},{"name":"第5章 图论算法与模型","slug":"ACM/算法竞赛入门经典训练指南/第5章-图论算法与模型","link":"/categories/ACM/算法竞赛入门经典训练指南/第5章-图论算法与模型/"},{"name":"第4章 几何问题","slug":"ACM/算法竞赛入门经典训练指南/第4章-几何问题","link":"/categories/ACM/算法竞赛入门经典训练指南/第4章-几何问题/"},{"name":"函数程序设计实验","slug":"函数程序设计实验","link":"/categories/函数程序设计实验/"},{"name":"第2章 数学基础","slug":"ACM/算法竞赛入门经典训练指南/第2章-数学基础","link":"/categories/ACM/算法竞赛入门经典训练指南/第2章-数学基础/"},{"name":"网络流","slug":"ACM/算法竞赛入门经典训练指南/第5章-图论算法与模型/网络流","link":"/categories/ACM/算法竞赛入门经典训练指南/第5章-图论算法与模型/网络流/"},{"name":"三维几何","slug":"ACM/算法竞赛入门经典训练指南/第4章-几何问题/三维几何","link":"/categories/ACM/算法竞赛入门经典训练指南/第4章-几何问题/三维几何/"},{"name":"第3章 实用数据结构","slug":"ACM/算法竞赛入门经典训练指南/第3章-实用数据结构","link":"/categories/ACM/算法竞赛入门经典训练指南/第3章-实用数据结构/"},{"name":"吴恩达机器学习笔记","slug":"吴恩达机器学习笔记","link":"/categories/吴恩达机器学习笔记/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Template","slug":"ACM/Template","link":"/categories/ACM/Template/"},{"name":"数论","slug":"ACM/算法竞赛入门经典训练指南/第2章-数学基础/数论","link":"/categories/ACM/算法竞赛入门经典训练指南/第2章-数学基础/数论/"},{"name":"机器学习","slug":"机器学习","link":"/categories/机器学习/"},{"name":"区间信息维护","slug":"ACM/算法竞赛入门经典训练指南/第3章-实用数据结构/区间信息维护","link":"/categories/ACM/算法竞赛入门经典训练指南/第3章-实用数据结构/区间信息维护/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/计算机网络/"},{"name":"并行与分布式计算","slug":"并行与分布式计算","link":"/categories/并行与分布式计算/"},{"name":"超级计算机原理与操作","slug":"超级计算机原理与操作","link":"/categories/超级计算机原理与操作/"},{"name":"环境配置","slug":"环境配置","link":"/categories/环境配置/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/学习笔记/"},{"name":"计算机组成原理","slug":"计算机组成原理","link":"/categories/计算机组成原理/"}]}